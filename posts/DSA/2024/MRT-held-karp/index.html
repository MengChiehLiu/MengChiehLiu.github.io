<!doctypehtml><html lang=zh-TW><meta charset=UTF-8><meta content=width=device-width name=viewport><meta content=#222 name=theme-color><meta content="Hexo 6.3.0" name=generator><link href=/images/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/safari-pinned-tab.svg rel=mask-icon><link href=/images/site.webmanifest rel=manifest><link href=/css/main.css rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css integrity=sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc= rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity=sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE= rel=stylesheet><script class=next-config data-name=main type=application/json>{"hostname":"mengchiehliu.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.15.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜尋...","empty":"我們無法找到任何有關 ${query} 的搜索結果","hits_time":"${hits} 找到 ${time} 個結果","hits":"找到 ${hits} 個結果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta content="前言  台北捷運最近推出了一個很瘋狂的集章全制霸活動，集滿5條捷運路線(不含環狀線)，總共109個車站，就可以抽大獎，到底有誰會閒閒沒事想參加這個活動? 啊，我女朋友剛剛問我要不要參加，沒事沒事，真是個好活動! 問題來了，該如何用最短的時間集齊所有車站並回到出發地呢? 本文將使用 Held Karp 算法來計算從台北車站出發，遍歷 109 個車站，並在最後回到台北車站所需花費的最短時間與路徑，不" name=description><meta content=article property=og:type><meta content="遍歷台北捷運109個車站要花多久時間? 基於 Held Karp 算法尋找最佳路線!" property=og:title><meta content=https://mengchiehliu.github.io/posts/DSA/2024/MRT-held-karp/index.html property=og:url><meta content=米蟲的程式小窩 property=og:site_name><meta content="前言  台北捷運最近推出了一個很瘋狂的集章全制霸活動，集滿5條捷運路線(不含環狀線)，總共109個車站，就可以抽大獎，到底有誰會閒閒沒事想參加這個活動? 啊，我女朋友剛剛問我要不要參加，沒事沒事，真是個好活動! 問題來了，該如何用最短的時間集齊所有車站並回到出發地呢? 本文將使用 Held Karp 算法來計算從台北車站出發，遍歷 109 個車站，並在最後回到台北車站所需花費的最短時間與路徑，不" property=og:description><meta content=zh_TW property=og:locale><meta content=https://mengchiehliu.github.io/images/2024/07/27/image.png property=og:image><meta content=2024-07-27T09:59:47.110Z property=article:published_time><meta content=2024-07-27T10:38:37.038Z property=article:modified_time><meta content="Meng-Chieh Liu" property=article:author><meta content="Held Karp" property=article:tag><meta content=Dijkstra property=article:tag><meta content=summary name=twitter:card><meta content=https://mengchiehliu.github.io/images/2024/07/27/image.png name=twitter:image><link href=https://mengchiehliu.github.io/posts/DSA/2024/MRT-held-karp/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-TW","comments":true,"permalink":"https://mengchiehliu.github.io/posts/DSA/2024/MRT-held-karp/","path":"posts/DSA/2024/MRT-held-karp/","title":"遍歷台北捷運109個車站要花多久時間? 基於 Held Karp 算法尋找最佳路線!"}</script><script class=next-config data-name=calendar type=application/json>""</script><title>遍歷台北捷運109個車站要花多久時間? 基於 Held Karp 算法尋找最佳路線! | 米蟲的程式小窩</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切換導航欄 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <p class=site-title>米蟲的程式小窩</p> <i class=logo-line></i> </a><p class=site-subtitle itemprop=description>Viva La Vida</div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜尋 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首頁</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>關於</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>標籤</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分類</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>歸檔</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜尋 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜尋... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目錄<li class=sidebar-nav-overview>本站概要</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class=nav><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%89%8D%E8%A8%80><span class=nav-number>1.</span> <span class=nav-text> 前言</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%97%85%E8%A1%8C%E6%8E%A8%E9%8A%B7%E5%93%A1%E5%95%8F%E9%A1%8C><span class=nav-number>2.</span> <span class=nav-text> 旅行推銷員問題</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#held-karp-%E7%AE%97%E6%B3%95><span class=nav-number>3.</span> <span class=nav-text> Held Karp 算法</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#cut-the-tails-and-circle><span class=nav-number>4.</span> <span class=nav-text> Cut the tails and circle</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#compress-path><span class=nav-number>5.</span> <span class=nav-text> Compress path</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%AE%97%E6%B3%95%E5%AF%A6%E7%8F%BE><span class=nav-number>6.</span> <span class=nav-text> 算法實現</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#held-karp><span class=nav-number>6.1.</span> <span class=nav-text> Held Karp</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#dijkstra><span class=nav-number>6.2.</span> <span class=nav-text> Dijkstra</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%AE%8C%E6%95%B4%E7%A8%8B%E5%BC%8F%E7%A2%BC><span class=nav-number>7.</span> <span class=nav-text> 完整程式碼</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%B5%90%E6%9E%9C><span class=nav-number>8.</span> <span class=nav-text> 結果</span></a></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt="Meng-Chieh Liu" class=site-author-image itemprop=image src=/images/avatar.png><p class=site-author-name itemprop=name>Meng-Chieh Liu<div class=site-description itemprop=description>讀會計但一直寫程式的人</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>28</span> <span class=site-state-item-name>文章</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>5</span> <span class=site-state-item-name>分類</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>21</span> <span class=site-state-item-name>標籤</span></a></div></nav></div><div class="links-of-author animated"><span class=links-of-author-item> <a rel="noopener me" title="GitHub → https://github.com/MengChiehLiu" href=https://github.com/MengChiehLiu target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item> <a rel="noopener me" title="Linkedin → https://www.linkedin.com/in/meng-chieh-liu-615952235/" href=https://www.linkedin.com/in/meng-chieh-liu-615952235/ target=_blank><i class="fa-brands fa-linkedin fa-fw"></i>Linkedin</a> </span><span class=links-of-author-item> <a rel="noopener me" title="E-Mail → mailto:jk211896@gmail.com" href=mailto:jk211896@gmail.com target=_blank><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article lang=zh-TW><link href=https://mengchiehliu.github.io/posts/DSA/2024/MRT-held-karp/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/images/avatar.png itemprop=image> <meta content="Meng-Chieh Liu" itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=米蟲的程式小窩 itemprop=name> <meta content=讀會計但一直寫程式的人 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="遍歷台北捷運109個車站要花多久時間? 基於 Held Karp 算法尋找最佳路線! | 米蟲的程式小窩" itemprop=name> <meta itemprop=description> </span><header class=post-header><h1 itemprop="name headline" class=post-title>遍歷台北捷運109個車站要花多久時間? 基於 Held Karp 算法尋找最佳路線!</h1><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>發表於</span> <time itemprop="dateCreated datePublished" title="創建時間：2024-07-27 17:59:47" datetime=2024-07-27T17:59:47+08:00>2024-07-27</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分類於</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/DSA/ itemprop=url rel=index><span itemprop=name>DSA</span></a> </span> </span><span class=post-meta-item id=busuanzi_container_page_pv title=閱讀次數> <span class=post-meta-item-icon> <i class="far fa-eye"></i> </span> <span class=post-meta-item-text>閱讀次數：</span> <span id=busuanzi_value_page_pv></span> </span><span class=post-meta-break></span><span class=post-meta-item title=文章字數> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>文章字數：</span> <span>3k</span> </span><span class=post-meta-item title=所需閱讀時間> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>所需閱讀時間 ≈</span> <span>13 分鐘</span> </span></div></div></header><div class=post-body itemprop=articleBody><h2 id=前言><a class=markdownIt-Anchor href=#前言></a> 前言</h2><p><img alt="MRT event" src=/images/2024/07/27/image.png><p>台北捷運最近推出了一個很瘋狂的<a href=https://web.metro.taipei/event/metrotaipeistamp/ rel=noopener target=_blank>集章全制霸</a>活動，集滿5條捷運路線(不含環狀線)，總共109個車站，就可以抽大獎，到底有誰會閒閒沒事想參加這個活動? 啊，我女朋友剛剛問我要不要參加，沒事沒事，真是個好活動! 問題來了，該如何用最短的時間集齊所有車站並回到出發地呢?<p>本文將使用 Held Karp 算法來計算從台北車站出發，遍歷 109 個車站，並在最後回到台北車站所需花費的最短時間與路徑，不想看過程的人也可以直接到最後面看結果。XD</p><span id=more></span><h2 id=旅行推銷員問題><a class=markdownIt-Anchor href=#旅行推銷員問題></a> 旅行推銷員問題</h2><p>肯定有人發現了，這本質就是一個旅行推銷員問題，可以簡稱為TSP問題 (Travelling salesman problem)。借用<a href=https://zh.wikipedia.org/zh-tw/%E6%97%85%E8%A1%8C%E6%8E%A8%E9%94%80%E5%91%98%E9%97%AE%E9%A2%98 rel=noopener target=_blank>維基百科</a>的介紹，其問題內容為「給定一系列城市和每對城市之間的距離，求解訪問每座城市一次並回到起始城市的最短迴路。」<p>我們可以使用台北捷運開放資料 API 中的 <a href=https://tdx.transportdata.tw/api-service/swagger/basic/268fc230-2e04-471b-a728-a726167c1cfc#/Metro/MetroApi_Line_2091 rel=noopener target=_blank>捷運路線基本資料</a> 來建立 Graph，再搭配 TSP 算法理論上就能算出最佳路徑與花費時間了，為了方便計算先不考慮班次跟轉乘時間了。另外，雖然環狀線不在集章活動的範圍內，但身為一條「捷徑」，肯定還是要考慮進去的。<ul><li>資料格式 <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line>lines = [</span><br><span class=line>    {</span><br><span class=line>    "LineNo": "BL",</span><br><span class=line>    "LineID": "BL",</span><br><span class=line>    "RouteID": "BL-1",</span><br><span class=line>    "TrainType": 1,</span><br><span class=line>    "TravelTimes": [</span><br><span class=line>      {</span><br><span class=line>        "Sequence": 1,</span><br><span class=line>        "FromStationID": "BL23",</span><br><span class=line>        "FromStationName": {</span><br><span class=line>          "Zh_tw": "南港展覽館",</span><br><span class=line>          "En": "Taipei Nangang Exhibition Center"</span><br><span class=line>        },</span><br><span class=line>        "ToStationID": "BL22",</span><br><span class=line>        "ToStationName": {</span><br><span class=line>          "Zh_tw": "南港",</span><br><span class=line>          "En": "Nangang"</span><br><span class=line>        },</span><br><span class=line>        "RunTime": 112,</span><br><span class=line>        "StopTime": 0</span><br><span class=line>      },</span><br><span class=line>      </span><br><span class=line>      ... and more</span><br><span class=line>]</span><br></pre></table></figure><li>建 Graph <figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>original_graph = defaultdict(<span class=built_in>dict</span>)</span><br><span class=line><span class=keyword>for</span> line <span class=keyword>in</span> lines:</span><br><span class=line>    <span class=keyword>for</span> edge <span class=keyword>in</span> line[<span class=string>"TravelTimes"</span>]:</span><br><span class=line>        start = edge[<span class=string>'FromStationName'</span>][<span class=string>'Zh_tw'</span>]</span><br><span class=line>        end = edge[<span class=string>'ToStationName'</span>][<span class=string>'Zh_tw'</span>]</span><br><span class=line>        time = edge[<span class=string>"RunTime"</span>]</span><br><span class=line>        original_graph[start][end] = time</span><br><span class=line>        original_graph[end][start] = time</span><br></pre></table></figure></ul><h2 id=held-karp-算法><a class=markdownIt-Anchor href=#held-karp-算法></a> Held Karp 算法</h2><p>Held Karp 算法是基於動態規劃來求解TSP問題的一種算法，簡單來說，這個算法會遍歷所有可能的狀態，包括<em>已訪問節點</em>與<em>所在節點</em>，並根據當前狀態下去計算下一步該如何走。<p>為了記錄所有可能，我們可以用 binary 來表示已訪問節點，1表示已經過，0表示還沒經過，舉例來說<ul><li>000: 表示尚未訪問任何節點<li>001: 表示已訪問第1個節點<li>101: 表示已訪問第1跟第3個節點</ul><p>Held Karp 算法理論上能求出最佳解，可惜時間複雜度高，將已訪問節點 <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mo stretchy=false>(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>{(2^n)}</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mord><span class=mopen>(</span><span class=mord><span class=mord>2</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:0.664392em;><span style=top:-3.063em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class=mclose>)</span></span></span></span></span> x 當前節點 <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mo stretchy=false>(</mo><mi>n</mi><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>{(n)}</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mord><span class=mopen>(</span><span class="mord mathnormal">n</span><span class=mclose>)</span></span></span></span></span> x 下一節點 <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mo stretchy=false>(</mo><mi>n</mi><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>{(n)}</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mord><span class=mopen>(</span><span class="mord mathnormal">n</span><span class=mclose>)</span></span></span></span></span>，會得到時間複雜度是 <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>O</mi><mo stretchy=false>(</mo><msup><mi>n</mi><mn>2</mn></msup><msup><mn>2</mn><mi>n</mi></msup><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>{O(n^2 2^n)}</annotation></semantics></math></span><span aria-hidden=true class=katex-html><span class=base><span class=strut style=height:1.064108em;vertical-align:-0.25em;></span><span class=mord><span class="mord mathnormal" style=margin-right:0.02778em;>O</span><span class=mopen>(</span><span class=mord><span class="mord mathnormal">n</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:0.8141079999999999em;><span style=top:-3.063em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class=mord><span class=mord>2</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:0.664392em;><span style=top:-3.063em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class=mclose>)</span></span></span></span></span><p>Anyway，時間複雜度那麼高，最多也就容許圖中有20~25個節點，台北捷運109個站是要算到天荒地老? 所以我們的下個目標是要將圖縮小!<blockquote><p>BTW, 因為算法需要知道任意兩點之間的成本，所以下文中任意兩點間的距離使用 Dijkstra 來計算最短路徑。</blockquote><h2 id=cut-the-tails-and-circle><a class=markdownIt-Anchor href=#cut-the-tails-and-circle></a> Cut the tails and circle</h2><p>仔細觀察捷運圖，會發現大部分捷運尾巴的部分是可以分開計算的，比如民權西路到淡水、大安到動物園等，直覺上來說這些路線肯定只能原路折返，更準確地講我們可以不斷地將 indgree 為 1 的節點移除掉，用剩餘的節點計算就好。<p>接著看到文湖線與板南線圍起的圓圈，如果你今天要用最快的時間遍歷圓圈內的所有車站，你會怎麼走這個圓圈? 要馬順時鐘繞完要馬逆時鐘繞完，絕對不會有繞一半往回走的情況，所以這一段我們也可以先移除。<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>tails = [</span><br><span class=line>    (<span class=string>'淡水'</span>, <span class=string>'民權西路'</span>), (<span class=string>'新北投'</span>, <span class=string>'北投'</span>), (<span class=string>'蘆洲'</span>, <span class=string>'大橋頭'</span>), </span><br><span class=line>    (<span class=string>'迴龍'</span>, <span class=string>'頭前庄'</span>), (<span class=string>'頂埔'</span>, <span class=string>'板橋'</span>), (<span class=string>'南勢角'</span>, <span class=string>'景安'</span>), </span><br><span class=line>    (<span class=string>'新店'</span>, <span class=string>'大坪林'</span>), (<span class=string>'小碧潭'</span>, <span class=string>'七張'</span>), (<span class=string>'松山'</span>, <span class=string>'南京復興'</span>), </span><br><span class=line>    (<span class=string>'動物園'</span>, <span class=string>'大安'</span>), (<span class=string>'象山'</span>, <span class=string>'大安'</span>)</span><br><span class=line>]</span><br><span class=line></span><br><span class=line><span class=comment># 拆成3段算，否則用最短路徑算會直接走下去</span></span><br><span class=line>circles = [</span><br><span class=line>    (<span class=string>"南京復興"</span>, <span class=string>"內湖"</span>), (<span class=string>"內湖"</span>, <span class=string>"南港"</span>), (<span class=string>"南港"</span>, <span class=string>"忠孝復興"</span>)</span><br><span class=line>]</span><br></pre></table></figure><h2 id=compress-path><a class=markdownIt-Anchor href=#compress-path></a> Compress path</h2><p>算了一下，剩下的節點還是太多了啊，這時候就拿出第二招，<strong>壓縮路徑</strong>，留下不重要的節點從路徑中移除。舉例來說，從古亭到景安雖然要經過2站 (頂溪、永安市場)，但這2個站都在同一條線上且沒有分支，可以當作是順便「路過」，所以我們可以把中間的節點都移除，用頭尾的節點做計算就好。<p>前面提到的圓圈部分其實也能算是一種路線壓縮 (忠孝復興 &LT----> 南京復興)，只留下頭跟尾，中間部分都省略。<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=comment># Key Stations</span></span><br><span class=line>key_stations = [</span><br><span class=line>    <span class=string>'民權西路'</span>, <span class=string>'雙連'</span>, <span class=string>'中山'</span>, <span class=string>'台北車站'</span>, <span class=string>'台大醫院'</span>, <span class=string>'中正紀念堂'</span>, </span><br><span class=line>    <span class=string>'中山國小'</span>, <span class=string>'行天宮'</span>, <span class=string>'松江南京'</span>, <span class=string>'忠孝新生'</span>, <span class=string>'東門'</span>, </span><br><span class=line>    <span class=string>'古亭'</span>, <span class=string>'南京復興'</span>, <span class=string>'忠孝復興'</span>, <span class=string>'大安'</span>, <span class=string>'北門'</span>, <span class=string>'西門'</span>, </span><br><span class=line>    <span class=string>'小南門'</span>, <span class=string>'善導寺'</span>, <span class=string>'頭前庄'</span>, <span class=string>'板橋'</span>, <span class=string>'景安'</span>, <span class=string>'大坪林'</span></span><br><span class=line>]</span><br><span class=line></span><br><span class=line><span class=comment># compress path</span></span><br><span class=line>n = <span class=built_in>len</span>(key_stations)</span><br><span class=line>graph = [[<span class=number>0</span>]*n <span class=keyword>for</span> _ <span class=keyword>in</span> <span class=built_in>range</span>(n)]</span><br><span class=line>sub_paths = defaultdict(<span class=built_in>dict</span>)</span><br><span class=line><span class=keyword>for</span> start_idx <span class=keyword>in</span> <span class=built_in>range</span>(n-<span class=number>1</span>):</span><br><span class=line>    <span class=keyword>for</span> end_idx <span class=keyword>in</span> <span class=built_in>range</span>(start_idx+<span class=number>1</span>, n):</span><br><span class=line>        cost, path = dijkstra(original_graph, key_stations[start_idx], key_stations[end_idx])</span><br><span class=line>        graph[start_idx][end_idx] = cost</span><br><span class=line>        graph[end_idx][start_idx] = cost</span><br><span class=line>        sub_paths[start_idx][end_idx] = path</span><br><span class=line>        sub_paths[end_idx][start_idx] = path[::-<span class=number>1</span>]</span><br></pre></table></figure><p>如果我們只用頭跟尾去計算最佳路線，那我們要如何保證算法會經過那些被我們刪掉的節點呢? 同樣舉圓圈部分為例，要走入圓圈的前提是其中一段路的起點與終點分別是南京復興或忠孝復興，如果算出來根本不是這樣走呢?<p>其中一個解決方法是「提供誘因」，引誘算法選擇走這些路線，對於最短路徑算法來說，最大的誘因是什麼呢? 答案就是<strong>距離/時間</strong>，只要將兩點之間的距離/時間設為 0，那算法便會更偏好這條路徑。(當然，最後是會加回去的。)<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=comment># 引誘路線</span></span><br><span class=line>key_paths = [</span><br><span class=line>    (<span class=string>"忠孝復興"</span>, <span class=string>"南京復興"</span>), (<span class=string>"民權西路"</span>, <span class=string>"頭前庄"</span>), (<span class=string>"西門"</span>, <span class=string>"板橋"</span>),</span><br><span class=line>    (<span class=string>"古亭"</span>, <span class=string>"景安"</span>), (<span class=string>"古亭"</span>, <span class=string>"大坪林"</span>), (<span class=string>"大安"</span>, <span class=string>"東門"</span>)</span><br><span class=line>]</span><br><span class=line></span><br><span class=line>adjusted_graph = [row[:] <span class=keyword>for</span> row <span class=keyword>in</span> graph]</span><br><span class=line><span class=keyword>for</span> start, end <span class=keyword>in</span> key_paths:</span><br><span class=line>    start_idx = key_stations.index(start)</span><br><span class=line>    end_idx = key_stations.index(end)</span><br><span class=line>    adjusted_graph[start_idx][end_idx] = <span class=number>0</span></span><br><span class=line>    adjusted_graph[end_idx][start_idx] = <span class=number>0</span></span><br></pre></table></figure><p>既然這個做法聽起來那麼讚，那就把看起來能壓縮的路線全部壓一遍吧? 很遺憾，也不是所有路線都管用，舉例，從民權西路經中山國中、行天宮到松江南京的路線，就算將距離設為0，在很多情況下算法還是不會經過，而是選擇走其他條路，具體來說究竟哪些可以壓縮哪些不行我也說不清楚，如果有想法的話歡迎提供建議!<h2 id=算法實現><a class=markdownIt-Anchor href=#算法實現></a> 算法實現</h2><h3 id=held-karp><a class=markdownIt-Anchor href=#held-karp></a> Held Karp</h3><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br></pre><td class=code><pre><span class=line><span class=keyword>from</span> tqdm <span class=keyword>import</span> tqdm</span><br><span class=line></span><br><span class=line><span class=keyword>def</span> <span class="title function_">held_karp</span>(<span class=params>graph, adjusted_graph, start, end</span>):</span><br><span class=line></span><br><span class=line>    <span class=string>'''</span></span><br><span class=line><span class=string>    graph: n*n 的 matrix of distance</span></span><br><span class=line><span class=string>    adjusted_graph: n*n 的 matrix of adjusted distance</span></span><br><span class=line><span class=string>    start: (int) 起點的 index</span></span><br><span class=line><span class=string>    end: (int) 終點的 index</span></span><br><span class=line><span class=string>    '''</span></span><br><span class=line></span><br><span class=line>    n = <span class=built_in>len</span>(adjusted_graph)</span><br><span class=line>    dp = [[<span class=built_in>float</span>(<span class=string>'inf'</span>)] * n <span class=keyword>for</span> _ <span class=keyword>in</span> <span class=built_in>range</span>(<span class=number>1</span> << n)]</span><br><span class=line>    parent = [[-<span class=number>1</span>] * n <span class=keyword>for</span> _ <span class=keyword>in</span> <span class=built_in>range</span>(<span class=number>1</span> << n)]  <span class=comment># 用來追蹤路徑</span></span><br><span class=line>    dp[<span class=number>1</span> << start][start] = <span class=number>0</span>  <span class=comment># 起點，start</span></span><br><span class=line></span><br><span class=line>    <span class=keyword>for</span> mask <span class=keyword>in</span> tqdm(<span class=built_in>range</span>(<span class=number>1</span> << n)):</span><br><span class=line>        <span class=keyword>for</span> i <span class=keyword>in</span> <span class=built_in>range</span>(n):</span><br><span class=line>            <span class=keyword>if</span> <span class=keyword>not</span> (mask & (<span class=number>1</span> << i)):</span><br><span class=line>                <span class=keyword>continue</span>  <span class=comment># 節點 i 不在當前的子集中</span></span><br><span class=line>            <span class=keyword>for</span> j <span class=keyword>in</span> <span class=built_in>range</span>(n):</span><br><span class=line>                <span class=keyword>if</span> mask & (<span class=number>1</span> << j):</span><br><span class=line>                    <span class=keyword>continue</span>  <span class=comment># 節點 j 已經在子集中</span></span><br><span class=line>                new_mask = mask | (<span class=number>1</span> << j) <span class=comment># 將節點 j 加入子集</span></span><br><span class=line>                <span class=keyword>if</span> dp[new_mask][j] > dp[mask][i] + adjusted_graph[i][j]:</span><br><span class=line>                    dp[new_mask][j] = dp[mask][i] + adjusted_graph[i][j]</span><br><span class=line>                    parent[new_mask][j] = i</span><br><span class=line></span><br><span class=line>    <span class=comment># 計算到達終點的最小成本</span></span><br><span class=line>    min_cost = <span class=built_in>float</span>(<span class=string>'inf'</span>)</span><br><span class=line>    last_node = -<span class=number>1</span></span><br><span class=line>    <span class=keyword>for</span> i <span class=keyword>in</span> <span class=built_in>range</span>(<span class=number>1</span>, n):</span><br><span class=line>        cost = dp[(<span class=number>1</span> << n) - <span class=number>1</span>][i] + graph[i][end] <span class=comment># 回起點所花費的成本要用原本的 graph 做計算</span></span><br><span class=line>        <span class=keyword>if</span> min_cost > cost:</span><br><span class=line>            min_cost = cost</span><br><span class=line>            last_node = i</span><br><span class=line></span><br><span class=line>    <span class=comment># 重建路徑</span></span><br><span class=line>    path = []</span><br><span class=line>    mask = (<span class=number>1</span> << n) - <span class=number>1</span></span><br><span class=line>    <span class=keyword>while</span> last_node != -<span class=number>1</span>:</span><br><span class=line>        path.append(last_node)</span><br><span class=line>        new_mask = mask ^ (<span class=number>1</span> << last_node)</span><br><span class=line>        last_node = parent[mask][last_node]</span><br><span class=line>        mask = new_mask</span><br><span class=line>    </span><br><span class=line>    path.reverse()</span><br><span class=line>    <span class=keyword>if</span> path[-<span class=number>1</span>] != end:</span><br><span class=line>        path.append(end)</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> min_cost, path</span><br></pre></table></figure><h3 id=dijkstra><a class=markdownIt-Anchor href=#dijkstra></a> Dijkstra</h3><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> heapq</span><br><span class=line></span><br><span class=line><span class=keyword>def</span> <span class="title function_">dijkstra</span>(<span class=params>graph, start, end</span>):</span><br><span class=line>    <span class=comment># 儲存從源點到各點的最短距離</span></span><br><span class=line>    distances = {vertex: <span class=built_in>float</span>(<span class=string>'infinity'</span>) <span class=keyword>for</span> vertex <span class=keyword>in</span> graph}</span><br><span class=line>    distances[start] = <span class=number>0</span></span><br><span class=line>    </span><br><span class=line>    <span class=comment># 儲存前驅節點以便重建最短路徑</span></span><br><span class=line>    previous_nodes = {vertex: <span class=literal>None</span> <span class=keyword>for</span> vertex <span class=keyword>in</span> graph}</span><br><span class=line>    </span><br><span class=line>    <span class=comment># 儲存優先隊列（以最小距離為優先）</span></span><br><span class=line>    priority_queue = [(<span class=number>0</span>, start)]</span><br><span class=line>    </span><br><span class=line>    <span class=keyword>while</span> priority_queue:</span><br><span class=line>        current_distance, current_vertex = heapq.heappop(priority_queue)</span><br><span class=line>        </span><br><span class=line>        <span class=comment># 如果已經達到目的點，則停止計算</span></span><br><span class=line>        <span class=keyword>if</span> current_vertex == end:</span><br><span class=line>            <span class=keyword>break</span></span><br><span class=line>        </span><br><span class=line>        <span class=comment># 如果已經處理過的節點，則跳過</span></span><br><span class=line>        <span class=keyword>if</span> current_distance > distances[current_vertex]:</span><br><span class=line>            <span class=keyword>continue</span></span><br><span class=line>        </span><br><span class=line>        <span class=comment># 更新相鄰節點的距離</span></span><br><span class=line>        <span class=keyword>for</span> neighbor, weight <span class=keyword>in</span> graph[current_vertex].items():</span><br><span class=line>            distance = current_distance + weight</span><br><span class=line>            </span><br><span class=line>            <span class=comment># 如果找到更短的路徑，則更新並加入優先隊列</span></span><br><span class=line>            <span class=keyword>if</span> distance < distances[neighbor]:</span><br><span class=line>                distances[neighbor] = distance</span><br><span class=line>                previous_nodes[neighbor] = current_vertex</span><br><span class=line>                heapq.heappush(priority_queue, (distance, neighbor))</span><br><span class=line>    </span><br><span class=line>    <span class=comment># 重建最短路徑</span></span><br><span class=line>    path = []</span><br><span class=line>    current_node = end</span><br><span class=line>    <span class=keyword>while</span> current_node <span class=keyword>is</span> <span class=keyword>not</span> <span class=literal>None</span>:</span><br><span class=line>        path.append(current_node)</span><br><span class=line>        current_node = previous_nodes[current_node]</span><br><span class=line>    path.reverse()</span><br><span class=line>    </span><br><span class=line>    <span class=keyword>return</span> distances[end], path</span><br></pre></table></figure><h2 id=完整程式碼><a class=markdownIt-Anchor href=#完整程式碼></a> 完整程式碼</h2><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br></pre><td class=code><pre><span class=line><span class=keyword>from</span> data <span class=keyword>import</span> key_stations, key_paths, lines, tails, circles</span><br><span class=line><span class=keyword>from</span> collections <span class=keyword>import</span> defaultdict</span><br><span class=line><span class=keyword>from</span> dijkstra <span class=keyword>import</span> dijkstra</span><br><span class=line><span class=keyword>from</span> held_karp <span class=keyword>import</span> held_karp</span><br><span class=line></span><br><span class=line><span class=comment># build graph</span></span><br><span class=line>original_graph = defaultdict(<span class=built_in>dict</span>)</span><br><span class=line><span class=keyword>for</span> line <span class=keyword>in</span> lines:</span><br><span class=line>    <span class=keyword>for</span> edge <span class=keyword>in</span> line[<span class=string>"TravelTimes"</span>]:</span><br><span class=line>        start = edge[<span class=string>'FromStationName'</span>][<span class=string>'Zh_tw'</span>]</span><br><span class=line>        end = edge[<span class=string>'ToStationName'</span>][<span class=string>'Zh_tw'</span>]</span><br><span class=line>        time = edge[<span class=string>"RunTime"</span>]</span><br><span class=line>        original_graph[start][end] = time</span><br><span class=line>        original_graph[end][start] = time</span><br><span class=line></span><br><span class=line><span class=comment># cacluate cost of tails, round-trip</span></span><br><span class=line>tail_cost = <span class=number>0</span></span><br><span class=line><span class=keyword>for</span> start, end <span class=keyword>in</span> tails:</span><br><span class=line>    cost, path = dijkstra(original_graph, start, end)</span><br><span class=line>    tail_cost += cost * <span class=number>2</span></span><br><span class=line></span><br><span class=line><span class=comment># cacluate cost of circles, one-way</span></span><br><span class=line>circle_cost = <span class=number>0</span></span><br><span class=line><span class=keyword>for</span> start, end <span class=keyword>in</span> circles:</span><br><span class=line>    cost, path = dijkstra(original_graph, start, end)</span><br><span class=line>    circle_cost += cost</span><br><span class=line></span><br><span class=line><span class=comment># compress path</span></span><br><span class=line>n = <span class=built_in>len</span>(key_stations)</span><br><span class=line>graph = [[<span class=number>0</span>]*n <span class=keyword>for</span> _ <span class=keyword>in</span> <span class=built_in>range</span>(n)]</span><br><span class=line>sub_paths = defaultdict(<span class=built_in>dict</span>)</span><br><span class=line><span class=keyword>for</span> start_idx <span class=keyword>in</span> <span class=built_in>range</span>(n-<span class=number>1</span>):</span><br><span class=line>    <span class=keyword>for</span> end_idx <span class=keyword>in</span> <span class=built_in>range</span>(start_idx+<span class=number>1</span>, n):</span><br><span class=line>        cost, path = dijkstra(original_graph, key_stations[start_idx], key_stations[end_idx])</span><br><span class=line>        graph[start_idx][end_idx] = cost</span><br><span class=line>        graph[end_idx][start_idx] = cost</span><br><span class=line>        sub_paths[start_idx][end_idx] = path</span><br><span class=line>        sub_paths[end_idx][start_idx] = path[::-<span class=number>1</span>]</span><br><span class=line></span><br><span class=line><span class=comment># adjust compressed graph</span></span><br><span class=line>adjusted_graph = [row[:] <span class=keyword>for</span> row <span class=keyword>in</span> graph]</span><br><span class=line><span class=keyword>for</span> start, end <span class=keyword>in</span> key_paths:</span><br><span class=line>    start_idx = key_stations.index(start)</span><br><span class=line>    end_idx = key_stations.index(end)</span><br><span class=line>    adjusted_graph[start_idx][end_idx] = <span class=number>0</span></span><br><span class=line>    adjusted_graph[end_idx][start_idx] = <span class=number>0</span></span><br><span class=line></span><br><span class=line><span class=comment># held karp</span></span><br><span class=line>start_station = <span class=string>"台北車站"</span></span><br><span class=line>end_station = <span class=string>"台北車站"</span></span><br><span class=line>start_idx = key_stations.index(start_station)</span><br><span class=line>end_idx = key_stations.index(end_station)</span><br><span class=line>core_cost, path = held_karp(graph, adjusted_graph, start_idx, end_idx)</span><br><span class=line></span><br><span class=line><span class=comment># add key_path back, start from 1</span></span><br><span class=line><span class=keyword>for</span> start, end <span class=keyword>in</span> key_paths[<span class=number>1</span>:]:</span><br><span class=line>    start_idx = key_stations.index(start)</span><br><span class=line>    end_idx = key_stations.index(end)</span><br><span class=line>    core_cost += graph[start_idx][end_idx]</span><br><span class=line></span><br><span class=line><span class=comment># show result</span></span><br><span class=line>total_cost = tail_cost + circle_cost + core_cost</span><br><span class=line>h = total_cost // <span class=number>3600</span></span><br><span class=line>m = total_cost // <span class=number>60</span> % <span class=number>60</span></span><br><span class=line>s = total_cost % <span class=number>60</span></span><br><span class=line><span class=built_in>print</span>(<span class=string>f"總耗時: <span class=subst>{h}</span>h <span class=subst>{m}</span>m <span class=subst>{s}</span>s"</span>)</span><br><span class=line><span class=built_in>print</span>(<span class=string>''</span>)</span><br><span class=line><span class=built_in>print</span>(<span class=string>"核心部分路線:"</span>)</span><br><span class=line><span class=keyword>for</span> i <span class=keyword>in</span> <span class=built_in>range</span>(<span class=built_in>len</span>(path)-<span class=number>1</span>):</span><br><span class=line>    start_idx = path[i]</span><br><span class=line>    end_idx = path[i+<span class=number>1</span>]</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>f"<span class=subst>{i+<span class=number>1</span>}</span>. <span class=subst>{<span class=string>'-->'</span>.join(sub_paths[start_idx][end_idx])}</span>"</span>)</span><br></pre></table></figure><h2 id=結果><a class=markdownIt-Anchor href=#結果></a> 結果</h2><p>終於來到本篇文章精華? 根據計算結果，從台北車站出發，遍歷 109 個車站，並在最後回到台北車站所需花費的時間是<strong>4小時52分鐘7秒</strong>，核心路線如下，記得遇到 tails 與 circle 時要繞過去就行了。<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line>1. 台北車站-->善導寺</span><br><span class=line>2. 善導寺-->忠孝新生</span><br><span class=line>3. 忠孝新生-->東門</span><br><span class=line>4. 東門-->大安森林公園-->大安</span><br><span class=line>5. 大安-->忠孝復興</span><br><span class=line>6. 忠孝復興-->南京復興</span><br><span class=line>7. 南京復興-->松江南京</span><br><span class=line>8. 松江南京-->行天宮</span><br><span class=line>9. 行天宮-->中山國小</span><br><span class=line>10. 中山國小-->民權西路-->雙連-->中山</span><br><span class=line>11. 中山-->雙連</span><br><span class=line>12. 雙連-->民權西路</span><br><span class=line>13. 民權西路-->大橋頭-->台北橋-->菜寮-->三重-->先嗇宮-->頭前庄</span><br><span class=line>14. 頭前庄-->新埔民生-->板橋</span><br><span class=line>15. 板橋-->新埔-->江子翠-->龍山寺-->西門</span><br><span class=line>16. 西門-->北門</span><br><span class=line>17. 北門-->西門-->小南門</span><br><span class=line>18. 小南門-->中正紀念堂-->古亭-->頂溪-->永安市場-->景安</span><br><span class=line>19. 景安-->景平-->秀朗橋-->十四張-->大坪林</span><br><span class=line>20. 大坪林-->景美-->萬隆-->公館-->台電大樓-->古亭</span><br><span class=line>21. 古亭-->中正紀念堂</span><br><span class=line>22. 中正紀念堂-->台大醫院</span><br><span class=line>23. 台大醫院-->台北車站</span><br></pre></table></figure><p>不過說真的，雖然路線可能是最好沒錯，但這個計算結果肯定是低估多了，原因如文章中所提，並沒有將班次與轉乘的因素考慮進去。再者，這只是「遍歷」所花費的時間，大家還記得活動的目的是要集章嗎? 這些集章的機台大多都在站外，也就是你各位要出站啊 😂😂😂，保守一點算，假設每站要多停留5分鐘，換算下來差不多就要再多個 9 小時，這還只是保守，實際上肯定更久啦，除非你一大早就起床集章，並且整天都很認真跑路線集章，否則這裡強烈建議:<p><em>“跟一個有買通勤月票的朋友借卡，然後多分幾天跑完，如此一來還不用花到半毛錢喔”</em> 😉</div><footer class=post-footer><div class=post-copyright><ul><li class=post-copyright-author><strong>作者： </strong>Meng-Chieh Liu<li class=post-copyright-link><strong>文章連結：</strong> <a title="遍歷台北捷運109個車站要花多久時間? 基於 Held Karp 算法尋找最佳路線!" href=https://mengchiehliu.github.io/posts/DSA/2024/MRT-held-karp/>https://mengchiehliu.github.io/posts/DSA/2024/MRT-held-karp/</a><li class=post-copyright-license><strong>版權聲明： </strong>本網誌所有文章除特別聲明外，均採用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 許可協議。轉載請註明出處！</ul></div><div class=post-tags><a href=/tags/Held-Karp/ rel=tag><i class="fa fa-tag"></i> Held Karp</a><a href=/tags/Dijkstra/ rel=tag><i class="fa fa-tag"></i> Dijkstra</a></div><div class=post-nav><div class=post-nav-item><a title="試著自己寫了一個 Hexo 外掛：Hexo + HackMD" href=/posts/Blog/2024/hexo-hackmd/ rel=prev> <i class="fa fa-chevron-left"></i> 試著自己寫了一個 Hexo 外掛：Hexo + HackMD </a></div><div class=post-nav-item></div></div></footer></article></div><div class="comments utterances-container"></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>Meng-Chieh Liu</span></div><div class=busuanzi-count><span class=post-meta-item id=busuanzi_container_site_uv> <span class=post-meta-item-icon> <i class="fa fa-user"></i> </span> <span class=site-uv title=訪客總數> <span id=busuanzi_value_site_uv></span> </span> </span><span class=post-meta-item id=busuanzi_container_site_pv> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=site-pv title=總瀏覽次數> <span id=busuanzi_value_site_pv></span> </span> </span></div></div></footer><div aria-label=回到頂端 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div><div class=reading-progress-bar></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script><script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/next-boot.js></script><script crossorigin=anonymous integrity=sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc= src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js></script><script src=/js/third-party/search/local-search.js></script><script async src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><script class=next-config data-name=enableMath type=application/json>true</script><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.css integrity=sha256-gMRN4/6qeELzO1wbFa8qQLU8kfuF2dnAPiUoI0ATjx8= rel=stylesheet><script class=next-config data-name=utterances type=application/json>{"enable":true,"repo":"MengChiehLiu/MengChiehLiu.github.io","issue_term":"pathname","theme":"github-light"}</script><script src=/js/third-party/comments/utterances.js></script><div id=sakana style=position:fixed;right:0;bottom:0px;></div><script async onload=initSakanaWidget({"character":"BMO","enable":true,"enable_mobile":false,"controls":false,"threshold":0.15,"customCharacters":[{"base":"chisato","name":"BMO","image":"/images/BMO.png","i":0.08,"s":0.1,"d":0.96,"r":12}],"size":200,"autoFit":false,"bottom":"0px","stroke":{"color":"#b4b4b4","width":10},"rotate":0}) src=https://cdn.jsdelivr.net/npm/sakana-widget@2.3.0/lib/sakana.min.js></script><script>function log(msg) {
        console.log("[hexo-sakana] " + msg);
      }

      function initSakanaWidget(config) {
        if (
          !config.enable_mobile &&
          window.navigator.userAgent.match(
            /(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i
          )
        ) {
          log(
            '检测为移动端，且配置中未开启在移动端启用组件，hexo-sakana 已禁用'
          );
          return;
        }
        for (character of config.customCharacters) {
          if (!["takina", "chisato"].includes(character.base)) {
            log(`无效基础角色 ${character.base}，取消注册`);
            continue;
          }
          if (character.name === "") {
            log("名称为空，取消注册");
            continue;
          }
          const originCharacter = SakanaWidget.getCharacter(character.base);
          originCharacter.initialState = {
            ...originCharacter.initialState,
            ...character,
          };
          originCharacter.image = !character.image ? originCharacter.image : character.image
          SakanaWidget.registerCharacter(character.name, originCharacter);
          log(`注册自定义角色：${character.name}`)
        }
        new SakanaWidget({
          character: config.character,
          size: config.size,
          autoFit: config.autoFit,
          controls: config.controls,
          stroke: config.stroke,
          threshold: config.threshold,
          rotate: config.rotate,
        }).mount("#sakana");
      }</script>