<!doctypehtml><html lang=zh-TW><meta charset=UTF-8><meta content=width=device-width name=viewport><meta content=#222 name=theme-color><meta content="Hexo 6.3.0" name=generator><link href=/images/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/safari-pinned-tab.svg rel=mask-icon><link href=/images/site.webmanifest rel=manifest><link href=/css/main.css rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css integrity=sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc= rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity=sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE= rel=stylesheet><script class=next-config data-name=main type=application/json>{"hostname":"mengchiehliu.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.15.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜尋...","empty":"我們無法找到任何有關 ${query} 的搜索結果","hits_time":"${hits} 找到 ${time} 個結果","hits":"找到 ${hits} 個結果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta content="介紹  介數中心性（Betweenness Centrality）是社會網絡分析中常用的一種指標，用於度量一個節點在整個網絡中扮演了多重要的角色，簡單來說，介數中心性指標評估了一個節點在網絡中擔任了多少條最短路徑的中介者角色。 更白話一點，介數中心性看的是一個節點有多常被其他人經過，舉例來說：某些公車站點連接了不同的公車路線，這些公車站點對於連接整個公車網絡起著重要的作用，如果這些公車站發生了任" name=description><meta content=article property=og:type><meta content="深入瞭解社會網絡分析中的介數中心性(Betweenness Centrality) - 計算方法與 Python 程式實作" property=og:title><meta content=https://mengchiehliu.github.io/posts/Others/2023/betweenness-centrality/index.html property=og:url><meta content=米蟲的程式小窩 property=og:site_name><meta content="介紹  介數中心性（Betweenness Centrality）是社會網絡分析中常用的一種指標，用於度量一個節點在整個網絡中扮演了多重要的角色，簡單來說，介數中心性指標評估了一個節點在網絡中擔任了多少條最短路徑的中介者角色。 更白話一點，介數中心性看的是一個節點有多常被其他人經過，舉例來說：某些公車站點連接了不同的公車路線，這些公車站點對於連接整個公車網絡起著重要的作用，如果這些公車站發生了任" property=og:description><meta content=zh_TW property=og:locale><meta content=https://mengchiehliu.github.io/images/2023/03/29/Betweenness_Centrality.png property=og:image><meta content=https://mengchiehliu.github.io/images/2023/03/29/formula.png property=og:image><meta content=https://mengchiehliu.github.io/images/2023/03/29/simple_network.png property=og:image><meta content=https://mengchiehliu.github.io/images/2023/03/29/normalization_formula.png property=og:image><meta content=https://mengchiehliu.github.io/images/2023/03/29/binomial_coefficient.png property=og:image><meta content=https://mengchiehliu.github.io/images/2023/03/29/pseudo_code.webp property=og:image><meta content=https://mengchiehliu.github.io/images/2023/03/29/simple_network_2.png property=og:image><meta content=2023-03-29T14:27:34.000Z property=article:published_time><meta content=2024-04-14T12:27:29.523Z property=article:modified_time><meta content="Meng-Chieh Liu" property=article:author><meta content="Social Network Analysis" property=article:tag><meta content="Betweenness Centrality" property=article:tag><meta content=summary name=twitter:card><meta content=https://mengchiehliu.github.io/images/2023/03/29/Betweenness_Centrality.png name=twitter:image><link href=https://mengchiehliu.github.io/posts/Others/2023/betweenness-centrality/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-TW","comments":true,"permalink":"https://mengchiehliu.github.io/posts/Others/2023/betweenness-centrality/","path":"posts/Others/2023/betweenness-centrality/","title":"深入瞭解社會網絡分析中的介數中心性(Betweenness Centrality) - 計算方法與 Python 程式實作"}</script><script class=next-config data-name=calendar type=application/json>""</script><title>深入瞭解社會網絡分析中的介數中心性(Betweenness Centrality) - 計算方法與 Python 程式實作 | 米蟲的程式小窩</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切換導航欄 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <p class=site-title>米蟲的程式小窩</p> <i class=logo-line></i> </a><p class=site-subtitle itemprop=description>Viva La Vida</div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜尋 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首頁</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>關於</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>標籤</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分類</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>歸檔</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜尋 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜尋... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目錄<li class=sidebar-nav-overview>本站概要</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#%E4%BB%8B%E7%B4%B9><span class=nav-number>1.</span> <span class=nav-text> 介紹</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#%E8%A8%88%E7%AE%97%E6%96%B9%E6%B3%95><span class=nav-number>2.</span> <span class=nav-text> 計算方法</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%BB%8B%E6%95%B8%E4%B8%AD%E5%BF%83%E6%80%A7><span class=nav-number>2.1.</span> <span class=nav-text> 介數中心性</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%A8%99%E6%BA%96%E5%8C%96><span class=nav-number>2.2.</span> <span class=nav-text> 標準化</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#python-%E5%AF%A6%E4%BD%9C><span class=nav-number>3.</span> <span class=nav-text> Python 實作</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#pseudo-code><span class=nav-number>3.1.</span> <span class=nav-text> Pseudo Code</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%A8%8B%E5%BC%8F%E9%82%8F%E8%BC%AF><span class=nav-number>3.2.</span> <span class=nav-text> 程式邏輯</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%B0%A1%E5%8C%96%E7%89%88%E6%9E%B6%E6%A7%8B><span class=nav-number>3.3.</span> <span class=nav-text> 簡化版架構</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%AE%8C%E6%95%B4%E7%A8%8B%E5%BC%8F%E7%A2%BC><span class=nav-number>3.4.</span> <span class=nav-text> 完整程式碼</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E7%B5%90%E8%AA%9E><span class=nav-number>4.</span> <span class=nav-text> 結語</span></a></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt="Meng-Chieh Liu" class=site-author-image itemprop=image src=/images/avatar.png><p class=site-author-name itemprop=name>Meng-Chieh Liu<div class=site-description itemprop=description>讀會計但一直寫程式的人</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>26</span> <span class=site-state-item-name>文章</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>5</span> <span class=site-state-item-name>分類</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>19</span> <span class=site-state-item-name>標籤</span></a></div></nav></div><div class="links-of-author animated"><span class=links-of-author-item> <a rel="noopener me" title="GitHub → https://github.com/MengChiehLiu" href=https://github.com/MengChiehLiu target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item> <a rel="noopener me" title="Linkedin → https://www.linkedin.com/in/meng-chieh-liu-615952235/" href=https://www.linkedin.com/in/meng-chieh-liu-615952235/ target=_blank><i class="fa-brands fa-linkedin fa-fw"></i>Linkedin</a> </span><span class=links-of-author-item> <a rel="noopener me" title="E-Mail → mailto:jk211896@gmail.com" href=mailto:jk211896@gmail.com target=_blank><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span></div></div></div></div><div class="sidebar-inner sidebar-post-related"><div class=animated><div class=links-of-blogroll-title><i class="fa fa-signs-post fa-fw"></i> 相關文章</div><ul class=popular-posts><li class=popular-posts-item><a class=popular-posts-link href=/posts/DSA/2024/monotonic-stack/ rel=bookmark> <time class=popular-posts-time>2024-04-13</time> <br> Monotonic Stack </a></ul></div></div></aside></div><div class="main-inner post posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article lang=zh-TW><link href=https://mengchiehliu.github.io/posts/Others/2023/betweenness-centrality/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/images/avatar.png itemprop=image> <meta content="Meng-Chieh Liu" itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=米蟲的程式小窩 itemprop=name> <meta content=讀會計但一直寫程式的人 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="深入瞭解社會網絡分析中的介數中心性(Betweenness Centrality) - 計算方法與 Python 程式實作 | 米蟲的程式小窩" itemprop=name> <meta itemprop=description> </span><header class=post-header><h1 itemprop="name headline" class=post-title>深入瞭解社會網絡分析中的介數中心性(Betweenness Centrality) - 計算方法與 Python 程式實作</h1><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>發表於</span> <time itemprop="dateCreated datePublished" title="創建時間：2023-03-29 22:27:34" datetime=2023-03-29T22:27:34+08:00>2023-03-29</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分類於</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Others/ itemprop=url rel=index><span itemprop=name>Others</span></a> </span> </span><span class=post-meta-item id=busuanzi_container_page_pv title=閱讀次數> <span class=post-meta-item-icon> <i class="far fa-eye"></i> </span> <span class=post-meta-item-text>閱讀次數：</span> <span id=busuanzi_value_page_pv></span> </span><span class=post-meta-break></span><span class=post-meta-item title=文章字數> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>文章字數：</span> <span>2.3k</span> </span><span class=post-meta-item title=所需閱讀時間> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>所需閱讀時間 ≈</span> <span>10 分鐘</span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=介紹><a class=markdownIt-Anchor href=#介紹></a> 介紹</h1><p><img alt="Betweenness Centrality" src=/images/2023/03/29/Betweenness_Centrality.png><p>介數中心性（Betweenness Centrality）是社會網絡分析中常用的一種指標，用於度量一個節點在整個網絡中扮演了多重要的角色，簡單來說，介數中心性指標評估了一個節點在網絡中擔任了多少條<strong>最短路徑</strong>的中介者角色。<p>更白話一點，介數中心性看的是一個節點有<strong>多常被其他人經過</strong>，舉例來說：某些公車站點連接了不同的公車路線，這些公車站點對於連接整個公車網絡起著重要的作用，如果這些公車站發生了任何問題，整個公車路線都會受到影響。這些公車站點就是具有高介數中心性的節點。</p><span id=more></span><h1 id=計算方法><a class=markdownIt-Anchor href=#計算方法></a> 計算方法</h1><h2 id=介數中心性><a class=markdownIt-Anchor href=#介數中心性></a> 介數中心性</h2><p><img alt="Betweenness Centrality Formula" src=/images/2023/03/29/formula.png><p>公式中，𝜎(sigma)表示最短路徑的數量，分母的意思是從點s到點w的最短路徑的數量，分子的意思是從點s到點w的最短路徑中經過v點的數量，聽起來有點抽象，我們用下面這張圖來解釋：<blockquote><p><img alt="Simple Network" src=/images/2023/03/29/simple_network.png><br> 從s點到w點的最短路徑總共有4條，分別是<br> <code>s -> 1 -> v -> w</code><br> <code>s -> 2 -> v -> w</code><br> <code>s -> 3 -> v -> w</code><br> <code>s -> 3 -> 4 -> w</code><br> 所以分母就是4，其中經過v的有三條所以分子就是3，能算出在s到w的路徑中，v的介數中心性就是<code>3/4</code>。<br> 但要注意的是網絡中的任一點都有可能是s或是w，因此若要計算整個網絡當中v的中心性，我們要將網絡中的所有組合加總(Σ)才能得到最後的結果。</blockquote><h2 id=標準化><a class=markdownIt-Anchor href=#標準化></a> 標準化</h2><p>聰明的你可能會發現網絡中的節點越多，算出來的值也越大(因為是加總)，因此，為了讓不同網絡之間能被拿來比較，我們要對其進行標準化。<p><img alt="Normalization Formula" src=/images/2023/03/29/normalization_formula.png><p>其中，分母是Binomial Coefficient，指的是一個網絡的最大可能介數中心性(網路中任選兩點、n-1取2)：<br> <img alt="Binomial Coefficient" src=/images/2023/03/29/binomial_coefficient.png><p>(上面標準化公式的假設是網絡是沒有方向性的，如果有方向性的話就不用除2了。)<h1 id=python-實作><a class=markdownIt-Anchor href=#python-實作></a> Python 實作</h1><p>網路上很多有關Betweenness Centrality的教學都是直接套<code>networkx</code>套件，但對於程式邏輯究竟如何實現卻是著墨很少，因此接下來要以<strong>不用套件</strong>的方式來實現unweighted graph中Betweenness Centrality的計算！<p>在開始實作前，我們要先把 unweighted graph 轉換成以下格式：<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>graph = {</span><br><span class=line>    <span class=number>0</span> : [<span class=number>1</span>, <span class=number>2</span>, <span class=number>3</span>], <span class=comment># 節點 : [他的鄰居]</span></span><br><span class=line>    <span class=number>1</span> : [<span class=number>0</span>, <span class=number>4</span>],</span><br><span class=line>    ...</span><br><span class=line>}</span><br></pre></table></figure><h2 id=pseudo-code><a class=markdownIt-Anchor href=#pseudo-code></a> Pseudo Code</h2><p>來看看Pseudo Code，這個算法可以計算出graph中各個點的Betweenness Centrality:<br> <img alt="Pseudo Code for Betweenness Centrality" src=/images/2023/03/29/pseudo_code.webp><h2 id=程式邏輯><a class=markdownIt-Anchor href=#程式邏輯></a> 程式邏輯</h2><p>看了霧煞煞? 沒關係，來解釋一下變數的意涵：<blockquote><p>s: 起點<br> v: 中介點<br> w: 終點<br> S: stack，後進先出的佇列，用來儲存已經遍歷過的節點<br> P: path，s到w的最短路徑中，所經過的鄰居v<br> σ: sigma，s到其他點的最短路徑的數量<br> d: distance，s到其他點的最短距離<br> Q: queue，先進先出的佇列，用來實現BFS<br> δ: delta，介數中心性 (單一個節點s的結果)<br> C: centrality，介數中心性 (sum of delta)</blockquote><p>程式邏輯其實很簡單，先初始化graph的共用的變數(<code>C</code>)，接著就是對每個節點(<code>for s in graph:</code>)做下面三個步驟：<ol><li>初始化變量</ol><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>S = [] <span class=comment># stack</span></span><br><span class=line>P = {node: [] <span class=keyword>for</span> node <span class=keyword>in</span> graph} <span class=comment># path</span></span><br><span class=line>sigma = {node: <span class=number>0</span> <span class=keyword>for</span> node <span class=keyword>in</span> graph} <span class=comment># 初始化為-1，因為原點是0</span></span><br><span class=line>sigma[s] = <span class=number>1</span> </span><br><span class=line>d = {node: -<span class=number>1</span> <span class=keyword>for</span> node <span class=keyword>in</span> graph} <span class=comment># distance</span></span><br><span class=line>d[s] = <span class=number>0</span></span><br><span class=line>Q = deque([s]) <span class=comment># queue</span></span><br></pre></table></figure><ul><li>這部分就是根據各個變量的性質去初始化而已，唯一需要注意的是距離(<code>d</code>)一開始要初始化為-1，因為原點會是0。</ul><ol start=2><li>計算最短路徑 (BFS)</ol><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>while</span> Q:</span><br><span class=line>    v = Q.popleft()</span><br><span class=line>    S.append(v)</span><br><span class=line>    <span class=keyword>for</span> w <span class=keyword>in</span> graph[v]: <span class=comment># for neighbor in neighbors</span></span><br><span class=line>        <span class=keyword>if</span> d[w] < <span class=number>0</span>: <span class=comment># 如果遇到新的節點才去更新他的距離</span></span><br><span class=line>            Q.append(w)</span><br><span class=line>            d[w] = d[v] + <span class=number>1</span></span><br><span class=line>        <span class=comment># -----------------------------------------------       </span></span><br><span class=line>        <span class=keyword>if</span> d[w] == d[v] + <span class=number>1</span>: <span class=comment># 判斷v是否在s到w的最短路徑中</span></span><br><span class=line>            sigma[w] += sigma[v] <span class=comment># 透過v去更新w的最短路徑數</span></span><br><span class=line>            P[w].append(v)</span><br></pre></table></figure><ul><li>在這段程式中，我們可以把他切成兩半，前半段是基本的BFS演算法，比較不一樣的地方在於我們將queue彈出的節點再存入stack中，紀錄所有遍歷過的點；後半段則是從w的鄰居中，去尋找鄰居v是否位於最短路徑當中(透過判斷最短距離是否相差1)，如果是的話那就透過v去更新更新w的sigma，並且將v記錄至w的<code>path</code>中。</ul><ol start=3><li>計算Betweenness Centrality</ol><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>delta = {node: <span class=number>0</span> <span class=keyword>for</span> node <span class=keyword>in</span> graph}</span><br><span class=line><span class=comment># -----------------------------------------------   </span></span><br><span class=line><span class=keyword>while</span> S:</span><br><span class=line>    w = S.pop() <span class=comment># 從遍歷過的節點中pop一個</span></span><br><span class=line>    <span class=keyword>for</span> v <span class=keyword>in</span> P[w]:</span><br><span class=line>        delta[v] += (sigma[v]/sigma[w]) * (<span class=number>1</span> + delta[w])</span><br><span class=line>    <span class=keyword>if</span> w != s:</span><br><span class=line>        C[w] += delta[w]</span><br></pre></table></figure><ul><li>delta其實也是初始化變量的一部分啦，只是Pseudo Code放在這部分所以寫在這邊。<li>我們將節點從stack中取出來，去更新這些點的Betweenness Centrality，之所以用stack有兩個原因，第一個原因是我們只需要考慮能到達的節點，第二個原因是我們希望由終點往起點去更新。<li>接著我們將每個w的path中的v取出，去更新這些v，<code>sigma[v]/sigma[w]</code>表示經過v的最短路徑數/經過w的最短路徑數，這邊比較讓人confused的點應該是，根據前面提到的Betweenness Centrality公式，不是只有<code>sigma[v]/sigma[w]</code>嗎?為什麼要乘以<code>1+delta[w]</code>呢?原因是目前的介數中心性只考慮了v之於w的影響，我們要對其進行修正以納入w後面的節點的影響，我們一樣拿前面用過的例子來解釋：</ul><blockquote><p><img alt="simple network 2" src=/images/2023/03/29/simple_network_2.png><br> 我們把原本的v當成新的w，把點1當成新的v，從s到w的最短路徑有三條，分別是<br> <code>s -> v -> w</code><br> <code>s -> 2 -> w</code><br> <code>s -> 3 -> w</code><br> 其中，經過v的只有一條，所以算出來Betweenness Centrality就是<code>sigma[v]/sigma[w] = 1/3</code>，但是!!! v不只在<code>s -> w</code>的最短的路徑上，他也位於<code>s -> w'</code>的最短路徑中，這部分也要考慮進去，前面提到從<code>s -> w'</code>共有4條最短路徑，經過現在的v的只有1條，因此這部分是<code>sigma[v]/sigma[w'] = 1/4</code>，而這個值其實會等於<code>1/3 * 3/4</code>，其中<code>3/4</code>是我們前面算得的<code>delta[w]</code>，因此把<code>s -> w</code>與<code>s -> w'</code>的結果加起來，就會是：<br> <code>(sigma[v]/sigma[w]) + (sigma[v]/sigma[w'])</code><br> =<code>(sigma[v]/sigma[w]) + (sigma[v]/sigma[w])*delta[w]</code><br> =<code>(sigma[v]/sigma[w]) * (1+delta[w])</code></blockquote><ul><li>最後，針對非起點s的節點，我們將其更新到最終結果中。</ul><p>標準化的部分雖然不在Pseudo Code中，但一般來說會順便做，方法如同公式的部分提到的，除以<code>((n-1)*(n-2))/2</code>就好。<figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>for</span> node <span class=keyword>in</span> graph:</span><br><span class=line>    C[node] /= ((n-<span class=number>1</span>)*(n-<span class=number>2</span>))/<span class=number>2</span></span><br></pre></table></figure><h2 id=簡化版架構><a class=markdownIt-Anchor href=#簡化版架構></a> 簡化版架構</h2><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>def</span> <span class="title function_">betweenness_centrality</span>(<span class=params>graph</span>):</span><br><span class=line>    C = {node: <span class=number>0</span> <span class=keyword>for</span> node <span class=keyword>in</span> graph}</span><br><span class=line></span><br><span class=line>    <span class=keyword>for</span> s <span class=keyword>in</span> graph:</span><br><span class=line>        <span class=number>1.</span> 初始化變量</span><br><span class=line>        <span class=number>2.</span> 計算最短路徑 (BFS)</span><br><span class=line>        <span class=number>3.</span> 計算centrality</span><br><span class=line>    </span><br><span class=line>    do Normalization</span><br><span class=line>    <span class=keyword>return</span> C</span><br></pre></table></figure><h2 id=完整程式碼><a class=markdownIt-Anchor href=#完整程式碼></a> 完整程式碼</h2><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br></pre><td class=code><pre><span class=line><span class=keyword>def</span> <span class="title function_">betweenness_centrality</span>(<span class=params>graph</span>):</span><br><span class=line></span><br><span class=line>    C = {node: <span class=number>0</span> <span class=keyword>for</span> node <span class=keyword>in</span> graph} <span class=comment># centrality</span></span><br><span class=line>    n = <span class=built_in>len</span>(C)</span><br><span class=line></span><br><span class=line>    <span class=comment># 遍歷每個節點</span></span><br><span class=line>    <span class=keyword>for</span> s <span class=keyword>in</span> graph:</span><br><span class=line>        <span class=comment># 1. 初始化變量</span></span><br><span class=line>        S = [] <span class=comment># stack</span></span><br><span class=line>        P = {node: [] <span class=keyword>for</span> node <span class=keyword>in</span> graph} <span class=comment># path</span></span><br><span class=line>        sigma = {node: <span class=number>0</span> <span class=keyword>for</span> node <span class=keyword>in</span> graph} <span class=comment># 初始化為-1，因為原點是0</span></span><br><span class=line>        sigma[s] = <span class=number>1</span> </span><br><span class=line>        d = {node: -<span class=number>1</span> <span class=keyword>for</span> node <span class=keyword>in</span> graph} <span class=comment># distance</span></span><br><span class=line>        d[s] = <span class=number>0</span></span><br><span class=line>        Q = deque([s]) <span class=comment># queue</span></span><br><span class=line>        </span><br><span class=line>        <span class=comment># 2. 計算最短路徑 (BFS)</span></span><br><span class=line>        <span class=keyword>while</span> Q:</span><br><span class=line>            v = Q.popleft()</span><br><span class=line>            S.append(v)</span><br><span class=line>            <span class=keyword>for</span> w <span class=keyword>in</span> graph[v]: <span class=comment># for neighbor in neighbors</span></span><br><span class=line>                <span class=keyword>if</span> d[w] < <span class=number>0</span>: <span class=comment># 如果遇到新的節點才去更新他的距離</span></span><br><span class=line>                    Q.append(w)</span><br><span class=line>                    d[w] = d[v] + <span class=number>1</span></span><br><span class=line>                <span class=keyword>if</span> d[w] == d[v] + <span class=number>1</span>: <span class=comment># 判斷v是否在s到w的最短路徑中</span></span><br><span class=line>                    sigma[w] += sigma[v] <span class=comment># 透過v去更新w的最短路徑數</span></span><br><span class=line>                    P[w].append(v)</span><br><span class=line></span><br><span class=line>        <span class=comment># 3. 計算centrality</span></span><br><span class=line>        delta = {node: <span class=number>0</span> <span class=keyword>for</span> node <span class=keyword>in</span> graph}</span><br><span class=line>        <span class=keyword>while</span> S:</span><br><span class=line>            w = S.pop() <span class=comment># 從遍歷過的節點中pop一個</span></span><br><span class=line>            <span class=keyword>for</span> v <span class=keyword>in</span> P[w]:</span><br><span class=line>                delta[v] += (sigma[v]/sigma[w]) * (<span class=number>1</span> + delta[w])</span><br><span class=line>            <span class=keyword>if</span> w != s:</span><br><span class=line>                C[w] += delta[w]</span><br><span class=line></span><br><span class=line>    <span class=comment># Normalization</span></span><br><span class=line>    <span class=keyword>for</span> node <span class=keyword>in</span> graph:</span><br><span class=line>        C[node] /= ((n-<span class=number>1</span>)*(n-<span class=number>2</span>))/<span class=number>2</span> <span class=comment># 將每個節點除以最大可能值</span></span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> C</span><br></pre></table></figure><h1 id=結語><a class=markdownIt-Anchor href=#結語></a> 結語</h1><p>如果真的遇到要計算Betweenness Centrality的情況，當然還是直接用<code>networkx</code>套件裡的<code>betweenness_centrality</code>就好了啦，寫這篇單純是因為網路上都找不到有人說明算法的邏輯，所以希望寫這篇能幫助到其他想了解算法的人。<br> 要注意上面的算法建立在所有edge的權重都是一樣的情況下，也就是點與點之間不是1就是0的binary關係，那如果每條edge有不同的權重呢?方法其實也不太意外，就是把程式中計算最短路徑的部分換掉就好了，根據實際情況可以選擇Dijkstra或是Bellman–Ford等。</div><footer class=post-footer><div class=post-copyright><ul><li class=post-copyright-author><strong>作者： </strong>Meng-Chieh Liu<li class=post-copyright-link><strong>文章連結：</strong> <a title="深入瞭解社會網絡分析中的介數中心性(Betweenness Centrality) - 計算方法與 Python 程式實作" href=https://mengchiehliu.github.io/posts/Others/2023/betweenness-centrality/>https://mengchiehliu.github.io/posts/Others/2023/betweenness-centrality/</a><li class=post-copyright-license><strong>版權聲明： </strong>本網誌所有文章除特別聲明外，均採用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 許可協議。轉載請註明出處！</ul></div><div class=post-tags><a href=/tags/Social-Network-Analysis/ rel=tag><i class="fa fa-tag"></i> Social Network Analysis</a><a href=/tags/Betweenness-Centrality/ rel=tag><i class="fa fa-tag"></i> Betweenness Centrality</a></div><div class=post-nav><div class=post-nav-item><a title="Trie (字典樹) - Design Add and Search Words Data Structure" href=/posts/DSA/2023/trie-2/ rel=prev> <i class="fa fa-chevron-left"></i> Trie (字典樹) - Design Add and Search Words Data Structure </a></div><div class=post-nav-item><a title="Hello Hexo！簡單三步驟搞定 Google SEO 和 Bing SEO！(3)" href=/posts/Blog/2023/Hello-Hexo-3/ rel=next> Hello Hexo！簡單三步驟搞定 Google SEO 和 Bing SEO！(3) <i class="fa fa-chevron-right"></i> </a></div></div></footer></article></div><div class="comments utterances-container"></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>Meng-Chieh Liu</span></div><div class=busuanzi-count><span class=post-meta-item id=busuanzi_container_site_uv> <span class=post-meta-item-icon> <i class="fa fa-user"></i> </span> <span class=site-uv title=訪客總數> <span id=busuanzi_value_site_uv></span> </span> </span><span class=post-meta-item id=busuanzi_container_site_pv> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=site-pv title=總瀏覽次數> <span id=busuanzi_value_site_pv></span> </span> </span></div></div></footer><div aria-label=回到頂端 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div><div class=reading-progress-bar></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script><script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/next-boot.js></script><script crossorigin=anonymous integrity=sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc= src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js></script><script src=/js/third-party/search/local-search.js></script><script async src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><script class=next-config data-name=enableMath type=application/json>false</script><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.css integrity=sha256-gMRN4/6qeELzO1wbFa8qQLU8kfuF2dnAPiUoI0ATjx8= rel=stylesheet><script class=next-config data-name=utterances type=application/json>{"enable":true,"repo":"MengChiehLiu/MengChiehLiu.github.io","issue_term":"pathname","theme":"github-light"}</script><script src=/js/third-party/comments/utterances.js></script>