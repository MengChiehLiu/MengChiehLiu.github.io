class MinHeap{constructor(){this.heap=[]}length(){return this.heap.length}parent(t){return Math.floor((t-1)/2)}leftChild(t){return 2*t+1}rightChild(t){return 2*t+2}swap(t,e){[this.heap[t],this.heap[e]]=[this.heap[e],this.heap[t]]}push(t){this.heap.push(t),this.heapifyUp(this.heap.length-1)}heapifyUp(t){let e=this.parent(t);for(;t>0&&this.heap[t][0]<this.heap[e][0];)this.swap(t,e),t=e,e=this.parent(t)}heapifyDown(t){const e=this.leftChild(t),h=this.rightChild(t);let s=t;e<this.heap.length&&this.heap[e][0]<this.heap[s][0]&&(s=e),h<this.heap.length&&this.heap[h][0]<this.heap[s][0]&&(s=h),s!==t&&(this.swap(t,s),this.heapifyDown(s))}pop(){if(0===this.heap.length)throw new Error("Heap is empty");if(1===this.heap.length)return this.heap.pop();this.swap(0,this.heap.length-1);const t=this.heap.pop();return this.heapifyDown(0),t}}const ways=[[0,1],[1,0],[0,-1],[-1,0]];function future_cost(t,e,h,s){return Math.abs(h-t)+Math.abs(s-e)}function barrier(t,e,h,s,a){return 1==s?2&t[e][h].dataset.type:1==a?1&t[e][h].dataset.type:-1==s?2&t[e-1][h].dataset.type:1&t[e][h-1].dataset.type}
// A star
function findPath(){if(null===start||null===end)throw new Error("No start or end point");const t=parseInt(document.getElementById("height").value),e=parseInt(document.getElementById("width").value),h=Array.from({length:t},(()=>Array(e).fill(1/0)));h[start.row][start.col]=0;const s=new MinHeap;s.push([0,0,start.row,start.col]);const a=Array.from({length:t},(()=>Array(e).fill(null)));for(;s.length()>0;){let[r,n,p,i]=s.pop();if(p==end.row&&i==end.col)break;n++;for(let[r,o]of ways){const l=p+r,c=i+o;l<0||c<0||l==t||c==e||(barrier(cells,p,i,r,o)||n<h[l][c]&&(h[l][c]=n,a[l][c]=[p,i],tot_cost=future_cost(l,c,end.row,end.col)+n,s.push([tot_cost,n,l,c])))}}let r=end.row,n=end.col;for(path=[[r,n]];null!=a[r][n];)[r,n]=a[r][n],path.push([r,n]),cells[r][n].classList.add("path");cells[r][n].classList.remove("path")}