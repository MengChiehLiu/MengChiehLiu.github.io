<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello Hexo！用Hexo在GitHub Pages上架設個人部落格吧！(1)</title>
    <url>/posts/Hello-Hexo-1/</url>
    <content><![CDATA[<h1 id="Hexo-介紹"><a href="#Hexo-介紹" class="headerlink" title="Hexo 介紹"></a>Hexo 介紹</h1><p>Hexo 是一個基於Node.js 的自動化部落格部署框架，有近400種網頁主題可供選擇，支援Markdown語言撰寫文章內容而且部署相當迅速，簡直是自己架設部落格的必備神器呀！什麼？你說之前沒用過Node.js怎麼辦？沒關係，因為我之前也沒用過XD。事實上，只要掌握幾個基本的指令，就能夠架出漂漂亮亮、功能齊全的個人部落格囉！就讓我們一起看下去吧～<br>Hexo 官網：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a><br>Hexo GitHub：<a href="https://github.com/hexojs/hexo">https://github.com/hexojs/hexo</a></p>
<span id="more"></span>

<h1 id="前置作業"><a href="#前置作業" class="headerlink" title="前置作業"></a>前置作業</h1><ul>
<li><p>安裝 Node.js<br>官方載點：<a href="https://nodejs.org/zh-tw/download/">https://nodejs.org/zh-tw/download/</a></p>
<blockquote>
<p>進入網站後選擇LTS版本，然後選擇下載安裝程式，我自己是用Windows作業系統，直接點擊Windows icon就開始下載了，下載好後打開安裝程式一路確認到最後就安裝好啦～安裝完成後可以用 <code>npm --version</code> 來確認是否安裝成功。<br><img src="/../images/2023/03/14/nodejs.png" alt="Node.js"></p>
</blockquote>
</li>
<li><p>安裝 git<br>官方載點：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p>
<blockquote>
<p>選擇對應的作業系統直接下載就好～這裡一樣以Windows為例，選擇的是Standalone Installer下的64-bit Git for Windows Setup，下載好後打開安裝程式一路確認到最後就安裝好啦～安裝完成後可以用 <code>git --version</code> 來確認是否安裝成功。<br><img src="/../images/2023/03/14/git.png" alt="git"></p>
</blockquote>
</li>
<li><p>註冊GitHub帳號<br>官網連結：<a href="https://github.com/">https://github.com/</a></p>
</li>
</ul>
<h1 id="安裝-Hexo"><a href="#安裝-Hexo" class="headerlink" title="安裝 Hexo"></a>安裝 Hexo</h1><ul>
<li><p>安裝 Hexo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化資料夾，並將當前路徑移動到該資料夾下(blog 是資料夾名稱，可以改成自己喜歡的名字)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br></pre></td></tr></table></figure>
</li>
<li><p>下載 Hexo 所需套件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></li>
</ul>
<p>做完上面這些步驟後，我們就可以啟動伺服器來看看目前部落格的樣子囉。</p>
<ul>
<li>啟動伺服器<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server #or</span><br><span class="line">hexo s      </span><br></pre></td></tr></table></figure>
<blockquote>
<p>預設主題是landscape，也可以使用其他主題，下一篇文章會教大家如何套用Hexo上的熱門主題nexT！<br><img src="/../images/2023/03/14/landscape.png" alt="landscape"></p>
</blockquote>
</li>
</ul>
<h1 id="Hexo-架構"><a href="#Hexo-架構" class="headerlink" title="Hexo 架構"></a>Hexo 架構</h1><p>在開始加工我們的網站之前，先來認識一下Hexo的資料夾架構！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">|   ├── draft</span><br><span class="line">|   ├── page</span><br><span class="line">|   └── post</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">├── themes</span><br><span class="line">|   └── yourTheme</span><br><span class="line">|       └── _config.yml</span><br><span class="line">└── _config.yml</span><br></pre></td></tr></table></figure>

<ul>
<li>package.json<br>用來存放node.js的各種套件，一班情況下不太需要動到這個資料夾。</li>
<li>scaffolds<br>鷹架資料夾，裡面有三個檔案draft、page與post，分別對應了我們能建立的三種佈局，Hexo會依據這些佈局來生成新的頁面。</li>
<li>source<br>來源資料夾，用來存放文章、頁面以及圖片等內容，其中_drafts用來存放草稿，_posts用來存放已經發布的文章。</li>
<li>themes<br>主題資料夾，可以下載自己喜歡的主題放到裡面，在每個主題底下會有一個與主題設定檔，與主題有關的東西都在那裡進行設定。</li>
<li>_config.yml<br>網頁設定檔，與網頁有關的東西都在這裡進行設定。 (跟主題設定檔不一樣！)</li>
</ul>
<h1 id="Config-設置"><a href="#Config-設置" class="headerlink" title="Config 設置"></a>Config 設置</h1><p>進到_config.yml檔案中，對Site部分進行修改，可以參考下面的設置：</p>
<blockquote>
<p>subtitle跟description可寫可不寫<br>language預設是英文，可以改成zh-TW顯示繁體中文<br>keyword跟Google關鍵字搜尋有關，這裡先忽略不管他，未來有機會再來詳細介紹！<br><img src="/../images/2023/03/14/config_site.png" alt="config_site"></p>
</blockquote>
<h1 id="撰寫文章-x2F-新增頁面"><a href="#撰寫文章-x2F-新增頁面" class="headerlink" title="撰寫文章&#x2F;新增頁面"></a>撰寫文章&#x2F;新增頁面</h1><p>在Hexo當中共有三種佈局，分別是draft、post與page，其中draft跟page屬於文章，page則屬於頁面。</p>
<ul>
<li><p>post<br>所有draft都會被存放在_posts資料夾當中，會出現在網頁上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># post 可以省略</span><br><span class="line">hexo new post &quot;My Post&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>draft<br>draft是草稿，會另外從放於_drafts資料夾下，且不會出現在網頁上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new draft &quot;My Draft&quot;</span><br></pre></td></tr></table></figure>
<p>可以用指令將draft轉成post，原理只是換個資料夾而已，其實也可以手動作，反過來手動把post丟到draft也行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo publish &quot;My Draft&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>page<br>page是功能頁面，常見的有about、tags、categories等，下一篇文章就會介紹如何在nexT主題下建立對應的page！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;My Page&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="生成靜態文件"><a href="#生成靜態文件" class="headerlink" title="生成靜態文件"></a>生成靜態文件</h1><p>每次修改config檔或是寫完文章後，記得不要忘記重新生成一次網頁的靜態文件，不然剛剛做的變動網頁上是不會呈現出來的喔！</p>
<ul>
<li><p>清空原本的靜態文件&#x2F;暫存<br>這個步驟相當重要！否則容易出現新加的東西更新不上去的情況。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clear #or</span><br><span class="line">hexo cl</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成靜態文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate #or</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure>
</li>
<li><p>做完記得打開server確認一下結果！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server #or</span><br><span class="line">hexo s </span><br></pre></td></tr></table></figure></li>
</ul>
<p>這三個指令<br>非常重要！！！<br>非常重要！！！<br>非常重要！！！<br>簡單來說有動到東西請執行一下就對了！</p>
<h1 id="部署至-GitHub-Pages"><a href="#部署至-GitHub-Pages" class="headerlink" title="部署至 GitHub Pages"></a>部署至 GitHub Pages</h1><ol>
<li><p>在GitHub中創建一個新的repository (點右上角加號)<br><img src="/../images/2023/03/14/repository.png" alt="repository"></p>
</li>
<li><p>repository名稱取為<code>user_name.github.io</code>，然後直接create repository<br><img src="/../images/2023/03/14/repository_create.png" alt="repository_create"></p>
</li>
<li><p>修改網頁_config.yml中的URL設置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url: https://user_name.github.io/</span><br><span class="line">root: /</span><br></pre></td></tr></table></figure>
<blockquote>
<p>這裡的url是GitHub Pages的網址<br>root設成 &#x2F;<br><img src="/../images/2023/03/14/config_url.png" alt="config_url"></p>
</blockquote>
</li>
<li><p>修改網頁_config.yml中的deploy設置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/user_name/user_name.github.io.git</span><br></pre></td></tr></table></figure>
<blockquote>
<p>這裡選擇用HTTPS的方式連結，部署時直接輸入帳號密碼就行，也可以用SSH，不過就要設置金鑰，比較麻煩一些<br><img src="/../images/2023/03/14/config_deploy.png" alt="config_deploy"></p>
</blockquote>
</li>
<li><p>修改完後記得重新生成一次靜態文件</p>
</li>
<li><p>開始部署</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo deploy #or</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
</li>
<li><p>打開GitHub Pages的網址就能看到我們剛剛部署上去的網頁啦！<br><img src="/../images/2023/03/14/gitpage.png" alt="Alt text"></p>
</li>
</ol>
<h1 id="預告"><a href="#預告" class="headerlink" title="預告"></a>預告</h1><p>下一篇文章我將會介紹如何套用nexT主題，除了講解外觀設定以外，也將帶著大家打造標籤頁及站內搜尋等功能！</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Hexo！NexT 主題太單調？跟著這些美化步驟為部落格加入個人風格！(5)</title>
    <url>/posts/Hello-Hexo-5/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="/../images/2023/04/17/cover.png" alt="cover"></p>
<p>Hexo Next雖然已經將許多常見的設定整合到主題當中，但大家都採用一樣的設定的話其實挺無聊的，所以今天要在Hexo Next的基礎上帶大家來美化自己的部落格，為部落格加入<strong>個人風格</strong>，如果還不知道Hexo或者NexT是什麼可以參考我之前寫的<a href="/categories/Hexo/">Hello Hexo！</a>系列文章。 </p>
<span id="more"></span>

<h1 id="大綱"><a href="#大綱" class="headerlink" title="大綱"></a>大綱</h1><ul>
<li><a href="#%E5%A5%97%E7%94%A8%E8%83%8C%E6%99%AF%E5%9C%96%E7%89%87">套用背景圖片</a></li>
<li><a href="#%E8%AA%BF%E6%95%B4%E5%8D%80%E5%A1%8A%E9%80%8F%E6%98%8E%E5%BA%A6">調整區塊透明度</a></li>
<li><a href="#%E8%A8%AD%E7%BD%AE%E5%8D%80%E5%A1%8A%E5%9C%93%E8%A7%92">設置區塊圓角</a></li>
<li><a href="#%E6%96%87%E7%AB%A0%E5%8D%80%E5%A1%8A%E7%89%88%E9%9D%A2%E5%AF%AC%E5%BA%A6">文章區塊版面寬度</a></li>
<li><a href="#%E7%A8%8B%E5%BC%8F%E7%A2%BC%E5%8D%80%E5%A1%8A%E4%B8%BB%E9%A1%8C">程式碼區塊主題</a></li>
<li><a href="#%E8%AE%8A%E6%9B%B4%E6%96%87%E5%AD%97%E6%A8%A3%E5%BC%8F">變更文字樣式</a></li>
<li><a href="#%E8%AE%8A%E6%9B%B4%E5%AD%97%E9%AB%94%E9%A1%9E%E5%9E%8B">變更字體類型</a></li>
<li><a href="#%E5%9C%96%E7%89%87%E6%94%BE%E5%A4%A7%E6%AA%A2%E8%A6%96">圖片放大檢視</a></li>
</ul>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><h2 id="套用背景圖片"><a href="#套用背景圖片" class="headerlink" title="套用背景圖片"></a>套用背景圖片</h2><ol>
<li>準備一張圖片放到<code>themes/next/source/images/</code>路徑中。</li>
<li>到<code>themes/next/_config.yml</code>中，找到<code>custom_file_path</code>，將<code>style</code>的註解取消掉。<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.njk</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.njk</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.njk</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.njk</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.njk</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.njk</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.njk</span></span><br><span class="line">  <span class="comment">#variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure></li>
<li>在<code>source</code>內新增<code>_data</code>資料夾(<strong>注意是blog的，不是next裡面的!</strong>)，接著在裡面新增一個<code>styles.styl</code>文件。</li>
<li>在<code>styles.styl</code>中加入:<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>:<span class="built_in">url</span>(/images/background.jpg);  <span class="comment">// 背景圖片位置</span></span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-attachment</span>: fixed;            <span class="comment">// 是否滾動，fixed固定</span></span><br><span class="line">  <span class="attribute">background-size</span>: cover;                  <span class="comment">// 填滿畫面</span></span><br><span class="line">  <span class="attribute">background-position</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="調整區塊透明度"><a href="#調整區塊透明度" class="headerlink" title="調整區塊透明度"></a>調整區塊透明度</h2><p>套用背景圖片後，你可能會發現你的圖片大部分都被區塊擋住了!為了讓大家看到你美美的圖片，所以我們要來調整一下區跨的透明度，網路上很多調整透明度的方法都沒有用我試過了，最後在<a href="https://hui-shao.cn/next-transparent-background/" title="{rel=&#39;nofollow&#39;}">這篇文章</a>中找到讓我滿意的效果，這邊直接講結論，在<code>styles.styl</code>加入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:root &#123;</span><br><span class="line">  --content-bg-color:#ffffffe6;  // 白色半透明</span><br><span class="line">  --content-bg-color:#000000e6;  // 黑色半透明，兩者擇一</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>補充: 上面的設定是直接將區塊換成指定顏色，如果有開啟深色模式可以用黑色半透明，如果沒有的話可以用白色半透明，但切記不要混者用，否則文字會看不清楚。</p>
</blockquote>
<h2 id="設置區塊圓角"><a href="#設置區塊圓角" class="headerlink" title="設置區塊圓角"></a>設置區塊圓角</h2><ol>
<li><p>到<code>themes/next/_config.yml</code>中，找到<code>custom_file_path</code>，將<code>variable</code>的註解也取消掉。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.njk</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.njk</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.njk</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.njk</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.njk</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.njk</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.njk</span></span><br><span class="line">  <span class="attr">variable:</span> <span class="string">source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>source</code>內新增<code>_data</code>資料夾(<strong>注意是blog的，不是next裡面的!</strong>)，接著在裡面新增一個<code>variables.styl</code>文件。</p>
</li>
<li><p>在<code>variables.styl</code>中加入:</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="variable">$border</span>-radius-inner     = <span class="number">30px</span> <span class="number">30px</span> <span class="number">30px</span> <span class="number">30px</span>;  <span class="comment">// (內角) 左上 右上 右下 左下</span></span><br><span class="line"><span class="variable">$border</span>-radius           = <span class="number">30px</span>;                 <span class="comment">// (外角) 只填一個數字表示4個角</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="文章區塊版面寬度"><a href="#文章區塊版面寬度" class="headerlink" title="文章區塊版面寬度"></a>文章區塊版面寬度</h2><p>我們先來看一下預設的寬度(指的是網頁版，手機或平板都是用響應式網頁):</p>
<ul>
<li>Muse &#x2F; Mist<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="variable">$content</span>-desktop         = <span class="number">700px</span>   <span class="comment">// when screen width &lt; 1200px</span></span><br><span class="line"><span class="variable">$content</span>-desktop-large   = <span class="number">800px</span>   <span class="comment">// when screen width &gt;= 1200px</span></span><br><span class="line"><span class="variable">$content</span>-desktop-largest = <span class="number">900px</span>   <span class="comment">// when screen width &gt;= 1600px</span></span><br></pre></td></tr></table></figure></li>
<li>Pisces &#x2F; Gemini<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="variable">$content</span>-desktop         = <span class="string">&#x27;calc(100% - %s)&#x27;</span> % <span class="built_in">unit</span>(<span class="variable">$content</span>-desktop-<span class="attribute">padding</span> / <span class="number">2</span>, <span class="string">&#x27;px&#x27;</span>)</span><br><span class="line"><span class="variable">$content</span>-desktop-large   = <span class="number">1160px</span></span><br><span class="line"><span class="variable">$content</span>-desktop-largest = <span class="number">73%</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>可以看到不同主題的寬度定義方式不太一樣，如果要更改的話，我們可以到<code>variables.styl</code>中把預設的寬度覆蓋掉，舉例來說我使用Gemini，下面是我採用的設定:</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="variable">$content</span>-desktop         = <span class="number">90%</span>  <span class="comment">// 可以用百分比</span></span><br><span class="line"><span class="variable">$content</span>-desktop-large   = <span class="number">80%</span>  <span class="comment">// 也可用絕對數值 ex: 1000px</span></span><br></pre></td></tr></table></figure>


<h2 id="程式碼區塊主題"><a href="#程式碼區塊主題" class="headerlink" title="程式碼區塊主題"></a>程式碼區塊主題</h2><p>Hexo提供了<code>highlight.js</code>以及<code>prism.js</code>兩種程式碼區塊主題engine，可以參考<a href="https://theme-next.js.org/highlight/" title="{rel=&#39;nofollow&#39;}">NexT Highlight Theme Preview</a>來做挑選，以下已我自己套用<code>highlight.js</code>中的<code>night-owl</code>主題為例。</p>
<ol>
<li><p>到<code>_config.yml</code>中(不是next裡的)，找到<code>highlight</code>，將<code>enable</code>改成true。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span>   <span class="comment"># 是否顯示行數</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span>  <span class="comment"># 是否自動偵測語言(建議不要開，聽說很吃效能)</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hljs:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">prismjs:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span>       <span class="comment"># 如果是用prismjs的話那就是這裡改true，不要同時開兩個</span></span><br><span class="line">  <span class="attr">preprocess:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>到<code>themes/next/_config.yml</code>中，找到<code>codeblock</code>，根據是否開啟深色模式來填入主題名稱。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="attr">theme:</span>                      <span class="comment"># highlight.js 改這</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">night-owl</span>          <span class="comment"># (範例)淺色模式下套用night-owl </span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">stackoverflow-dark</span></span><br><span class="line">  <span class="attr">prism:</span>                      <span class="comment"># prism.js 改這</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">prism</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">prism-dark</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span>             <span class="comment"># 是否顯示複製按鈕</span></span><br><span class="line">    <span class="attr">style:</span>                    <span class="comment"># 風格(Available values: default | flat | mac)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="變更文字樣式"><a href="#變更文字樣式" class="headerlink" title="變更文字樣式"></a>變更文字樣式</h2><p>這部分主要是分享我在網路上找到的，覺得很不錯的設定，以下修改都是加在<code>source/_data/styles.styl</code>中。</p>
<ol>
<li><p>短網址樣式</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">code</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#c7254e</span>; <span class="comment">//文字顏色</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#f9f2f4</span>; <span class="comment">//底色</span></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>內文連結樣式</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> a&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0593d3</span>;</span><br><span class="line">  <span class="selector-pseudo">&amp;:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fc6423</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: none;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#fc6423</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改選中文字底色</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* webkit, opera, IE9 */</span></span><br><span class="line"><span class="selector-pseudo">::selection</span> &#123; </span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#00c4b6</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f7f7f7</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* firefox */</span></span><br><span class="line">::-moz-selection &#123; </span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#00c4b6</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f7f7f7</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改頁腳配色</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//頁腳統計文字顏色</span><br><span class="line">.footer&#123;</span><br><span class="line">  color: #F0D784</span><br><span class="line">&#125;</span><br><span class="line">//修改頁腳備案鏈接顏色</span><br><span class="line">.footer a&#123;</span><br><span class="line">  color: #F0D784</span><br><span class="line">&#125;</span><br><span class="line">//修改頁腳統計人數的顏色</span><br><span class="line">.footer .with-love&#123;</span><br><span class="line">  color: #F0D784</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="變更字體類型"><a href="#變更字體類型" class="headerlink" title="變更字體類型"></a>變更字體類型</h2><p>NexT可以直接使用<a href="https://fonts.google.com/" title="{rel=&#39;nofollow&#39;}">Google Fonts</a>提供的字體，但如果你使用的是繁體中文的話，你會發現其實也就只有兩種可以選而已XDDD，NexT預設是使用<strong>微軟正黑體</strong>，另外一種是<strong>唐宋思源體</strong>，我們今天就來試者把字體換成唐宋思源體看看吧!</p>
<ol>
<li>到<code>themes/next/_config.yml</code>中，找到<code>font</code>將<code>enable</code>改成<code>true</code>，接著更改<code>global</code>的設定(後面的不用改)。<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>              <span class="comment"># 設成true</span></span><br><span class="line">  <span class="attr">host:</span> </span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span>          <span class="comment"># 設成true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Noto</span> <span class="string">Serif</span> <span class="string">TC</span>   <span class="comment"># 唐宋思源體(TC: Traditional Chinese)</span></span><br><span class="line">    <span class="attr">size:</span>                   <span class="comment"># 字體大小，默認為1（16px）</span></span><br></pre></td></tr></table></figure></li>
<li>這邊特別說明<code>host</code>部分，在台灣基本上是不用設，但因為預設的host是Google的api，所以大陸地區的用戶在看我們的網站時可能會遇到一些穩定性上的問題?如果你部落格的target是整個大中華地區的話可以另外設個host，這邊提供<a href="https://github.com/cdnjs/cdnjs" title="{rel=&#39;nofollow&#39;}">cdnjs</a>的鏡像api給有需要的人:<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">host:</span> <span class="string">https://fonts.loli.net</span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>補充: 你可能會想問「如果我想要用的字體Google Fonts沒有提供怎麼辦?」，其實也是有辦法使用本地的字體喔，不過這部分稍微麻煩一丟丟，所以之後另外寫一篇文章介紹!</p>
</blockquote>
<h2 id="圖片放大檢視"><a href="#圖片放大檢視" class="headerlink" title="圖片放大檢視"></a>圖片放大檢視</h2><p>NexT目前提供兩種片放大檢視的工具，分別是<a href="https://fancyapps.com/fancybox/" title="{rel=&#39;nofollow&#39;}">FancyBox</a>以及<a href="https://medium-zoom.francoischalifour.com/" title="{rel=&#39;nofollow&#39;}">Medium Zoom</a>，可以看一下自己喜歡哪種。</p>
<p>到<code>themes/next/_config.yml</code>中找到<code>fancybox</code>&#x2F;<code>mediumzoom</code>，將其改為<code>true</code>，注意不要同時開啟兩個功能!!!</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">fancybox:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">mediumzoom:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>補充: FancyBox的功能比較多且可以顯示註解，不過有<a href="https://github.com/ppoffice/hexo-theme-icarus/issues/868" title="{rel=&#39;nofollow&#39;}">issue</a>表示FancyBox對於行動裝置似乎不是很友好? 不知道改了沒，Medium Zoom就跟Medium放大圖片的功能一樣，介面比較簡潔。</p>
</blockquote>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><p>文章內容大多是網路上的資料整理而來，再加上自己的採坑經驗，如果有遺漏來源的話再麻煩告知補上!</p>
<ul>
<li><a href="https://zenreal.github.io/posts/44730/" title="{rel=&#39;nofollow&#39;}">最新 Hexo NexT v7.4.1 主題優化</a></li>
<li><a href="https://hui-shao.cn/next-transparent-background/" title="{rel=&#39;nofollow&#39;}">Hexo + NexT8主题配置透明背景过程踩坑小记</a></li>
<li><a href="https://spartazhc.github.io/2020/06/03/Next%E4%B8%BB%E9%A2%98%E5%AD%97%E4%BD%93%E9%85%8D%E7%BD%AE/" title="{rel=&#39;nofollow&#39;}">Next主题字体配置</a></li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>Hello Hexo！簡單三步驟搞定Google SEO和Bing SEO！(3)</title>
    <url>/posts/Hello-Hexo-3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="/../images/2023/04/11/google_bing.png" alt="google and bing logo"></p>
<p>好不容易架設好Hexo網站，下一個問題就是如何讓自己寫的文章被其他人看見，大家可以在Google搜尋中輸入<code>site: 你的網站url</code>，看看Google能不能找到你的網站，沒意外的話Google應該還找不到你的網站，換做是Bing也一樣，原因是這些搜尋引擎還不認識我們的網站，本篇文章會帶大家使用Google Search Console以及Bing Webmaster來進行SEO。<br>(ps. 網路上已經有很多文章介紹Hexo的Google SEO，但在Bing與ChatGPT合作後，搜尋量有了明顯的提升，因此這篇文章除了介紹Google SEO外，也會介紹Bing SEO)</p>
<span id="more"></span>

<h1 id="Sitemap"><a href="#Sitemap" class="headerlink" title="Sitemap"></a>Sitemap</h1><p>Sitemap就是網站的地圖，搜尋引擎會透過Sitemap來認識我們的網站架構，我們可以透過下面指令安裝hexo的sitemap套件，之後hexo每次generate都會自動替我們生成sitemap。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap</span><br></pre></td></tr></table></figure>

<h1 id="Google-SEO"><a href="#Google-SEO" class="headerlink" title="Google SEO"></a>Google SEO</h1><p>我們要在<a href="https://search.google.com/search-console/about">Google Search Console</a>來設定Google的SEO，</p>
<h2 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h2><p>我們首先要驗證我們的網頁，選擇<strong>網站前置字元</strong>，將你的網站url複製上去(舉例:<code>https://MengChiehLiu.github.io/</code>)。<br><img src="/../images/2023/04/11/google_search_console.png" alt="google search console - resource type"></p>
<h2 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h2><p>我們使用建議的驗證方式，將html檔案下載下來，放到<code>/source</code>路徑下，我們要將檔案內容改成下面這樣:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 加上這段 --&gt;</span></span><br><span class="line">---</span><br><span class="line">layout: false</span><br><span class="line">---</span><br><span class="line"><span class="comment">&lt;!-- 原本的 --&gt;</span></span><br><span class="line">google-site-verification: googled0a70fa73d09cd65.html</span><br></pre></td></tr></table></figure>
<p>重新部署網頁後(這很重要!)就可以回到Google Search Console按下驗證。<br><img src="/../images/2023/04/11/google_search_console_2.png" alt="google search console - html verification"></p>
<h2 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h2><p>我們到Sitemap頁面中將加入<code>sitemap.xml</code>，這樣Google搜尋引擎就會定期到我們的sitemap去看我們的部落格有沒有更新了。<br><img src="/../images/2023/04/11/google_search_console_3.png" alt="google search console - sitemap"></p>
<h1 id="Bing-SEO"><a href="#Bing-SEO" class="headerlink" title="Bing SEO"></a>Bing SEO</h1><p>我們要在<a href="https://www.bing.com/webmasters/about">Bing Webmaster</a>來設定Bing的SEO，Bing的SEO超級簡單，登入後直接從Google Search Console匯入網站資訊就好。<br><img src="/../images/2023/04/11/bing_webmaster.png" alt="bing webmaster"></p>
<h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>做完這些設定後，Google和Bing會需要一些時間把我們的網站納入搜尋引擎當中，這個過程可能會需要1~2天。<br>上面這些設定只是讓搜尋引擎找的到我們的網站，屬於最基本的SEO，其他如關鍵字以、網址長度也會影響到網站排名，但最重要的還是文章的品質，所以努力寫出好文章也是SEO的關鍵喔。</p>
<blockquote>
<p>關鍵字設定<br>可以直接將<code>scaffolds/post.md</code>改成下面格式，之後new post的時候會自動套用下面格式。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">    -</span><br><span class="line">    -</span><br><span class="line">categories: </span><br><span class="line">keywords:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>使用時注意關鍵字與關鍵字之間用逗號分開不留空格!例如:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">keywords: Hexo,SEO,Google,Bing,Google Search Console,Bing Webmaster</span><br></pre></td></tr></table></figure>


<blockquote>
<p>網址長度<br>hexo預設使用<code>年/月/日/檔案名稱</code>來當作文章url，我們可以修改<code>/_config.yml</code>中的<code>permalink</code>來讓url更加精簡，詳細規則可以參考<a href="https://hexo.io/zh-tw/docs/permalinks.html">hexo官方文檔</a>，我自己是改成下面這樣:</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span> <span class="comment"># default</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:title/</span> <span class="comment"># shorter version</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Hexo！套用NexT主題打造簡潔頁面！(2)</title>
    <url>/posts/Hello-Hexo-2/</url>
    <content><![CDATA[<h1 id="NexT-介紹"><a href="#NexT-介紹" class="headerlink" title="NexT 介紹"></a>NexT 介紹</h1><p>NexT是一個相當受歡迎的Hexo主題，外觀簡潔、功能強大，且持續有在維護，今天會教大家如何套用NexT主題，並啟用標籤頁及站內搜尋等功能。<br>NexT 官網：<a href="https://theme-next.js.org/">https://theme-next.js.org/</a><br>NexT GitHub：<a href="https://github.com/next-theme/hexo-theme-next">https://github.com/next-theme/hexo-theme-next</a></p>
<span id="more"></span>

<h1 id="安裝-NexT"><a href="#安裝-NexT" class="headerlink" title="安裝 NexT"></a>安裝 NexT</h1><p>有兩個方法，第一個方法是透過npm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-theme-next</span><br></pre></td></tr></table></figure>
<p>第二個方法是透過git</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/next-theme/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p>我個人是喜歡第二種方法(git)，因為資源為自動進到themes資料夾當中，如果使用第二種方法(npm)的話資源會跑到node_modules資料夾中，雖然在功能上不會有差異，但未來要對主題的config檔做調整時要找比較久。</p>
<h1 id="套用主題"><a href="#套用主題" class="headerlink" title="套用主題"></a>套用主題</h1><p>到<strong>網頁</strong>的config檔(<code>/_config.yml</code>)，搜尋<strong>theme</strong>將主題設置成next就行了。<br><img src="/../images/2023/03/15/config_theme.png" alt="config_theme"></p>
<p>另外Next其實有提供4種版面可以做選擇，分別是：💟 <a href="https://theme-next.js.org/muse/">Muse</a> | 🔯 <a href="https://theme-next.js.org/mist/">Mist</a> | ♓️ <a href="https://theme-next.js.org/pisces/">Pisces</a> | ♊️ <a href="https://theme-next.js.org/">Gemini</a></p>
<p>大家可以點擊連結看看自己喜歡哪種版面，預設是使用Muse，如果要做更改的話，到<strong>主題</strong>的config檔(<code>themes/next/_config.yml</code>)中搜尋<strong>Schemes</strong>，將喜歡的佈局取消註解就可以了，另外下面的<strong>darkmode</strong>改成true的話則是可以讓網頁變成黑色模式。<br><img src="/../images/2023/03/15/next_schemes.png" alt="next_schemes"></p>
<p>NexT也支援canvas背景動畫，我們可以在<strong>主題</strong>config檔搜尋<strong>canvas_ribbon</strong>，將下方的enable改為true，部屬後網頁背景就會出現酷炫的彩色絲帶動畫了～</p>
<h1 id="添加頭像-avatar"><a href="#添加頭像-avatar" class="headerlink" title="添加頭像 avatar"></a>添加頭像 avatar</h1><ol>
<li>把準備好的圖片放入<code>themes/next/source/images</code>或<code>source/images</code>當中。</li>
<li>在<strong>主題</strong>config檔搜尋<strong>avatar</strong>，修改成自己準備的圖片路徑或者修改圖片名稱使其一致。<blockquote>
<p>rounded改成true的話頭像會是圓形，rotated改成true的話滑鼠移到頭像上時會有快速旋轉的動畫。<br><img src="/../images/2023/03/15/next_avatar.png" alt="next_avatar"></p>
</blockquote>
</li>
</ol>
<h1 id="更改網站圖示-favicon"><a href="#更改網站圖示-favicon" class="headerlink" title="更改網站圖示 favicon"></a>更改網站圖示 favicon</h1><p>我們可以把網站圖示換成自己的圖片，官方文件中建議可以使用<a href="https://realfavicongenerator.net/">Favicon Generator</a>來生成客製化的網站圖示。</p>
<ol>
<li>把準備好的圖片放入<code>themes/next/source/images</code>或<code>source/images</code>當中。</li>
<li>在<strong>主題</strong>config檔搜尋<strong>favicon</strong>，修改成自己準備的圖片路徑或者修改圖片名稱使其一致。<br><img src="/../images/2023/03/15/next_favicon.png" alt="next_favicon"></li>
</ol>
<h1 id="社群媒體連結-social-link"><a href="#社群媒體連結-social-link" class="headerlink" title="社群媒體連結 social link"></a>社群媒體連結 social link</h1><p>在<strong>主題</strong>config檔搜尋<strong>social</strong>，將自己的社群媒體連結填入並取消註解就可以了，下方的social_icon則可以設定是否顯示icon及icon外觀。<br><img src="/../images/2023/03/15/next_social.png" alt="next_social"></p>
<p>Hexo NexT使用<a href="https://fontawesome.com/icons">Font Awesome</a>提供的icons，因此我們可以為新的連結挑選適合的icon，接下來我們來新增一個Linkedin連結看看(包含icon)。</p>
<ol>
<li>先到Font Awesome上搜尋Linkedin，選擇自己喜歡的icon，複製綠色的那段文字。<br><img src="/../images/2023/03/15/font_awesome_linkedin.png" alt="font_awesome_linkedin"></li>
<li>依<code>標題: 連結 || 綠色文字</code>的格式在social下加入新的一行，舉例來說。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linkedin: https://www.linkedin.com/in/meng-chieh-liu-615952235/ || fa-brands fa-linkedin</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="啟用功能選單-Menu"><a href="#啟用功能選單-Menu" class="headerlink" title="啟用功能選單 Menu"></a>啟用功能選單 Menu</h1><p>在<strong>主題</strong>config檔搜尋<strong>menu</strong>，可以看到NexT預先幫我們建立好許多功能選單，其中home跟archives是預設就開啟的，我們可以取消註解來啟用其他功能選單，但目前那些頁面還是空的喔！所以我們的下一步就是要建立相應的分頁。<br><img src="/../images/2023/03/15/next_menu.png" alt="next_menu"></p>
<p>這邊介紹如何建立tags&#x2F;categories頁面：</p>
<ol>
<li><p>建立新頁面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;tags&quot;</span><br><span class="line">hexo new page &quot;categories&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>找到<code>source/tags/index.md</code>檔案，在檔案中加入<code>type: &quot;tags&quot;</code>，注意這裡的tags要加<strong>雙引號</strong>！！！<br>(categories比照辦理)<br><img src="/../images/2023/03/15/tags.png" alt="tags"></p>
</li>
<li><p>在post裡面加入tags&#x2F;categories，重新部署後這些tags&#x2F;categories就會出現對應的頁面上啦～<br><img src="/../images/2023/03/15/post_tags.png" alt="post_tags"></p>
</li>
</ol>
<h1 id="站內搜尋功能-local-search"><a href="#站內搜尋功能-local-search" class="headerlink" title="站內搜尋功能 local search"></a>站內搜尋功能 local search</h1><ol>
<li><p>安裝<code>hexo-generator-searchdb</code>套件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<strong>主題</strong>config檔搜尋<strong>local_search</strong>，將enable調為true。<br><img src="/../images/2023/03/15/next_local_search.png" alt="next_local_search"></p>
</li>
<li><p>在<strong>網頁</strong>config檔加入下面設置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新部署後就能開始使用站內搜尋啦～<br><img src="/../images/2023/03/15/local_search.png" alt="local_search"></p>
</li>
</ol>
<h1 id="預告"><a href="#預告" class="headerlink" title="預告"></a>預告</h1><p>下一篇文章將會帶大家做SEO，設定keywords與sitemap讓Google搜的到我們的部落格&#x2F;文章。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Hexo！功能全部開起來看起來就很厲害了吧？NexT常見設定整理 (4)</title>
    <url>/posts/Hello-Hexo-4/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="/../images/2023/04/14/cover.png" alt="cover image"></p>
<p>Next之所以受到歡迎，一大原因是因為NexT將很多常用的功能都整合進入主題當中，只要修改一下主題設定檔(config)、下載一下插件(plugins)，就能實現大部分的功能，今天就帶大家看一些常見的功能在NexT主題下要如何實現。</p>
<span id="more"></span>
<h1 id="大綱"><a href="#大綱" class="headerlink" title="大綱"></a>大綱</h1><ul>
<li><a href="#%E7%95%99%E8%A8%80%E6%9D%BF">留言板</a></li>
<li><a href="#%E7%89%88%E6%AC%8A%E8%81%B2%E6%98%8E">版權聲明</a></li>
<li><a href="#%E9%96%B1%E8%AE%80%E9%80%B2%E5%BA%A6">閱讀進度</a></li>
<li><a href="#%E5%9B%9E%E5%88%B0%E9%A0%82%E9%83%A8">回到頂部</a></li>
<li><a href="#%E8%A8%AA%E5%AE%A2%E7%B5%B1%E8%A8%88%E3%80%81%E6%96%87%E7%AB%A0%E9%96%B1%E8%AE%80%E7%B5%B1%E8%A8%88">訪客統計、文章閱讀次數</a></li>
<li><a href="#%E6%96%87%E7%AB%A0%E5%AD%97%E6%95%B8%E3%80%81%E9%96%B1%E8%AE%80%E6%99%82%E9%96%93">文章字數、閱讀時間</a></li>
</ul>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><h2 id="留言板"><a href="#留言板" class="headerlink" title="留言板"></a>留言板</h2><p>留言板是一個很奇妙的東西，雖然心裡想到底有誰會來留言，但沒有的話又好像少了些什麼，所以姑且還是放一下XD。<br>NexT支援多種留言版插件，網路上推薦使用的是disqus或utterances (gitalk因為權限要求過高所以沒什麼推薦了)，二選一的情況下，disqus要另外去註冊一個帳號有點麻煩，反觀utterances可以直接連結github repository來儲存評論，且外觀比較簡潔，所以最後決定使用utterances。</p>
<ol>
<li><p>到<a href="https://github.com/apps/utterances" title="{rel=&#39;nofollow&#39;}">utterances app</a>把app安裝到github上，將權限開給指定的專案repository。(我是直接跟部落格使用同一個，當然你也可以另外開一個新的repository。)</p>
</li>
<li><p>找到<code>next/_config.yml</code>中的<code>utterances</code>，將<code>enable</code>改成<code>true</code>，在<code>repo</code>填入剛剛開啟權限的repository名稱，舉例來說我是填<code>MengChiehLiu/MengChiehLiu.github.io</code>，<code>theme</code>參數可以設定不同留言板風格，大家可以自己試試看。</p>
</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">utterances:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">MengChiehLiu/MengChiehLiu.github.io</span></span><br><span class="line">  <span class="attr">issue_term:</span> <span class="string">pathname</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">github-light</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>最後如果你希望留言板只出現在文章頁面，而不要出現在其他page(ex: 標籤頁、分類頁)的話，那要到page下的<code>index.md</code>下修改標頭檔。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: </span><br><span class="line">date: </span><br><span class="line">type: </span><br><span class="line">&lt;!-- 加入下面這一行 --&gt;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="版權聲明"><a href="#版權聲明" class="headerlink" title="版權聲明"></a>版權聲明</h2><p>找到<code>next/_config.yml</code>中的<code>creative_commons</code>，將<code>post</code>改成<code>true</code>就可以了，協議的版本可以參考<a href="https://creativecommons.org/about/cclicenses/" title="{rel=&#39;nofollow&#39;}">About CC Licenses</a>自己做挑選。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">size:</span> <span class="string">small</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">language:</span></span><br></pre></td></tr></table></figure>

<p>我自己覺得預設的內容就挺不錯的，不過也可以自訂內容，這邊提供一篇不錯的文章給有興趣的人:</p>
<ul>
<li><a href="https://guiblogs.com/hexo30-21/" title="{rel=&#39;nofollow&#39;}">Day 21：在 Hexo 增加作者版權聲明（使用 Next 佈景）</a></li>
</ul>
<h2 id="閱讀進度"><a href="#閱讀進度" class="headerlink" title="閱讀進度"></a>閱讀進度</h2><p>找到<code>next/_config.yml</code>中的<code>reading_progress</code>，將<code>enable</code>改成<code>true</code>，開啟後會在網頁頂部&#x2F;底部顯示閱讀進度條。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">reading_progress:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">start_at:</span> <span class="string">left</span>   <span class="comment"># left/right，從左或右開始</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">top</span>    <span class="comment"># top/bottom，顯示在網頁頂部或底部</span></span><br><span class="line">  <span class="attr">reversed:</span> <span class="literal">false</span>  <span class="comment"># 開啟的話會從全滿開始扣</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;#37c6c0&quot;</span> <span class="comment"># 顏色</span></span><br><span class="line">  <span class="attr">height:</span> <span class="string">3px</span>      <span class="comment"># 進度條寬度</span></span><br></pre></td></tr></table></figure>


<h2 id="回到頂部"><a href="#回到頂部" class="headerlink" title="回到頂部"></a>回到頂部</h2><p>就是網頁往下滑右下角會出現的那個箭頭，按下去會回到網頁的頂部，找到<code>next/_config.yml</code>中的<code>back2top</code>，將<code>enable</code>改成<code>true</code>。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">back2top:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span>        <span class="comment"># 是否也顯示在側邊欄中</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">false</span>  <span class="comment"># 是否顯示百分比</span></span><br></pre></td></tr></table></figure>


<h2 id="訪客統計、文章閱讀統計"><a href="#訪客統計、文章閱讀統計" class="headerlink" title="訪客統計、文章閱讀統計"></a>訪客統計、文章閱讀統計</h2><p><a href="https://busuanzi.ibruce.info/" title="{rel=&#39;nofollow&#39;}">不蒜子</a>是一款極簡的前端計數工具，NexT已經幫我們將不蒜子整合在主題當中，只要修改<code>next/_config.yml</code>中的<code>busuanzi_count</code>，將<code>enable</code>改成<code>true</code>，就可以啟用訪客統計、文章閱讀次數的功能。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span>  <span class="comment"># 訪客人數</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span>     <span class="comment"># 全站閱覽次數</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span>      <span class="comment"># 文章閱讀統計</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">far</span> <span class="string">fa-eye</span></span><br></pre></td></tr></table></figure>

<h2 id="文章字數、閱讀時間"><a href="#文章字數、閱讀時間" class="headerlink" title="文章字數、閱讀時間"></a>文章字數、閱讀時間</h2><ol>
<li><p>下載<code>hexo-word-counter</code>插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install hexo-word-counter</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo clean</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在Hexo的config檔中(主目錄裡的)加入下面設定</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span>             <span class="comment"># 文章字數</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span>                <span class="comment"># 文章時間</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">false</span>      <span class="comment"># 總文章字數 (顯示在網頁底部)</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">false</span>         <span class="comment"># 總文章時間 (顯示在網頁底部)</span></span><br><span class="line">  <span class="attr">exclude_codeblock:</span> <span class="literal">false</span>  <span class="comment"># 不考慮程式碼部分</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span>                  <span class="comment"># Words Per Minute</span></span><br><span class="line">  <span class="attr">suffix:</span> <span class="string">&quot;mins.&quot;</span>           <span class="comment"># 時間單位</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>wpm官方文檔中給的建議是<br>Slow ≈ 200<br>Normal ≈ 275<br>Fast ≈ 350<br>如果主要是中文的話可以設300，中英夾雜維持275就好。</p>
</blockquote>
</li>
<li><p>這個插件有被整合進NexT當中，在完成前一個步驟後，我們可以修改theme config來調整外觀顯示</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span>        <span class="comment"># 是否顯示文字部分(文章)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span>   <span class="comment"># 是否獨立一行</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">false</span> <span class="comment"># 是否顯示文字部分(網頁底部)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>不顯示文字的話就不會有<code>文章字數：</code>和<code>所需閱讀時間 ≈</code>，只會有最前面的圖示。</p>
</blockquote>
</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>站內搜尋、主選單等功能我在<a href="/posts/Hello-Hexo-2/">這篇文章</a>中有介紹過了，有興趣的人可以去看看。</p>
<h1 id="預告"><a href="#預告" class="headerlink" title="預告"></a>預告</h1><p>下一篇文章會帶大家美化部落格!包括更換背景圖片、變更字體以及其他風格設定~</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>深入瞭解社會網絡分析中的介數中心性(Betweenness Centrality) - 計算方法與Python程式實作</title>
    <url>/posts/betweenness-centrality/</url>
    <content><![CDATA[<h1 id="介紹"><a href="#介紹" class="headerlink" title="介紹"></a>介紹</h1><p><img src="/../images/2023/03/29/Betweenness_Centrality.png" alt="Betweenness Centrality"></p>
<p>介數中心性（Betweenness Centrality）是社會網絡分析中常用的一種指標，用於度量一個節點在整個網絡中扮演了多重要的角色，簡單來說，介數中心性指標評估了一個節點在網絡中擔任了多少條<strong>最短路徑</strong>的中介者角色。</p>
<p>更白話一點，介數中心性看的是一個節點有<strong>多常被其他人經過</strong>，舉例來說：某些公車站點連接了不同的公車路線，這些公車站點對於連接整個公車網絡起著重要的作用，如果這些公車站發生了任何問題，整個公車路線都會受到影響。這些公車站點就是具有高介數中心性的節點。</p>
<span id="more"></span>

<h1 id="計算方法"><a href="#計算方法" class="headerlink" title="計算方法"></a>計算方法</h1><h2 id="介數中心性"><a href="#介數中心性" class="headerlink" title="介數中心性"></a>介數中心性</h2><p><img src="/../images/2023/03/29/formula.png" alt="Betweenness Centrality Formula"></p>
<p>公式中，𝜎(sigma)表示最短路徑的數量，分母的意思是從點s到點w的最短路徑的數量，分子的意思是從點s到點w的最短路徑中經過v點的數量，聽起來有點抽象，我們用下面這張圖來解釋：</p>
<blockquote>
<p><img src="/../images/2023/03/29/simple_network.png" alt="Simple Network"><br>從s點到w點的最短路徑總共有4條，分別是<br><code>s -&gt; 1 -&gt; v -&gt; w</code><br><code>s -&gt; 2 -&gt; v -&gt; w</code><br><code>s -&gt; 3 -&gt; v -&gt; w</code><br><code>s -&gt; 3 -&gt; 4 -&gt; w</code><br>所以分母就是4，其中經過v的有三條所以分子就是3，能算出在s到w的路徑中，v的介數中心性就是<code>3/4</code>。<br>但要注意的是網絡中的任一點都有可能是s或是w，因此若要計算整個網絡當中v的中心性，我們要將網絡中的所有組合加總(Σ)才能得到最後的結果。</p>
</blockquote>
<h2 id="標準化"><a href="#標準化" class="headerlink" title="標準化"></a>標準化</h2><p>聰明的你可能會發現網絡中的節點越多，算出來的值也越大(因為是加總)，因此，為了讓不同網絡之間能被拿來比較，我們要對其進行標準化。</p>
<p><img src="/../images/2023/03/29/normalization_formula.png" alt="Normalization Formula"></p>
<p>其中，分母是Binomial Coefficient，指的是一個網絡的最大可能介數中心性(網路中任選兩點、n-1取2)：<br><img src="/../images/2023/03/29/binomial_coefficient.png" alt="Binomial Coefficient"></p>
<p>(上面標準化公式的假設是網絡是沒有方向性的，如果有方向性的話就不用除2了。)</p>
<h1 id="Python-實作"><a href="#Python-實作" class="headerlink" title="Python 實作"></a>Python 實作</h1><p>網路上很多有關Betweenness Centrality的教學都是直接套<code>networkx</code>套件，但對於程式邏輯究竟如何實現卻是著墨很少，因此接下來要以<strong>不用套件</strong>的方式來實現unweighted graph中Betweenness Centrality的計算！</p>
<p>在開始實作前，我們要先把 unweighted graph 轉換成以下格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">graph = &#123;</span><br><span class="line">    <span class="number">0</span> : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="comment"># 節點 : [他的鄰居]</span></span><br><span class="line">    <span class="number">1</span> : [<span class="number">0</span>, <span class="number">4</span>],</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Pseudo-Code"><a href="#Pseudo-Code" class="headerlink" title="Pseudo Code"></a>Pseudo Code</h2><p>來看看Pseudo Code，這個算法可以計算出graph中各個點的Betweenness Centrality:<br><img src="/../images/2023/03/29/pseudo_code.webp" alt="Pseudo Code for Betweenness Centrality"></p>
<h2 id="程式邏輯"><a href="#程式邏輯" class="headerlink" title="程式邏輯"></a>程式邏輯</h2><p>看了霧煞煞? 沒關係，來解釋一下變數的意涵：</p>
<blockquote>
<p>s: 起點<br>v: 中介點<br>w: 終點<br>S: stack，後進先出的佇列，用來儲存已經遍歷過的節點<br>P: path，s到w的最短路徑中，所經過的鄰居v<br>σ: sigma，s到其他點的最短路徑的數量<br>d: distance，s到其他點的最短距離<br>Q: queue，先進先出的佇列，用來實現BFS<br>δ: delta，介數中心性 (單一個節點s的結果)<br>C: centrality，介數中心性 (sum of delta)</p>
</blockquote>
<p>程式邏輯其實很簡單，先初始化graph的共用的變數(<code>C</code>)，接著就是對每個節點(<code>for s in graph:</code>)做下面三個步驟：</p>
<ol>
<li>初始化變量<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = [] <span class="comment"># stack</span></span><br><span class="line">P = &#123;node: [] <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125; <span class="comment"># path</span></span><br><span class="line">sigma = &#123;node: <span class="number">0</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125; <span class="comment"># 初始化為-1，因為原點是0</span></span><br><span class="line">sigma[s] = <span class="number">1</span> </span><br><span class="line">d = &#123;node: -<span class="number">1</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125; <span class="comment"># distance</span></span><br><span class="line">d[s] = <span class="number">0</span></span><br><span class="line">Q = deque([s]) <span class="comment"># queue</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>這部分就是根據各個變量的性質去初始化而已，唯一需要注意的是距離(<code>d</code>)一開始要初始化為-1，因為原點會是0。</li>
</ul>
<ol start="2">
<li>計算最短路徑 (BFS)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> Q:</span><br><span class="line">    v = Q.popleft()</span><br><span class="line">    S.append(v)</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> graph[v]: <span class="comment"># for neighbor in neighbors</span></span><br><span class="line">        <span class="keyword">if</span> d[w] &lt; <span class="number">0</span>: <span class="comment"># 如果遇到新的節點才去更新他的距離</span></span><br><span class="line">            Q.append(w)</span><br><span class="line">            d[w] = d[v] + <span class="number">1</span></span><br><span class="line">        <span class="comment"># -----------------------------------------------       </span></span><br><span class="line">        <span class="keyword">if</span> d[w] == d[v] + <span class="number">1</span>: <span class="comment"># 判斷v是否在s到w的最短路徑中</span></span><br><span class="line">            sigma[w] += sigma[v] <span class="comment"># 透過v去更新w的最短路徑數</span></span><br><span class="line">            P[w].append(v)</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>在這段程式中，我們可以把他切成兩半，前半段是基本的BFS演算法，比較不一樣的地方在於我們將queue彈出的節點再存入stack中，紀錄所有遍歷過的點；後半段則是從w的鄰居中，去尋找鄰居v是否位於最短路徑當中(透過判斷最短距離是否相差1)，如果是的話那就透過v去更新更新w的sigma，並且將v記錄至w的<code>path</code>中。</li>
</ul>
<ol start="3">
<li>計算Betweenness Centrality<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delta = &#123;node: <span class="number">0</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125;</span><br><span class="line"><span class="comment"># -----------------------------------------------   </span></span><br><span class="line"><span class="keyword">while</span> S:</span><br><span class="line">    w = S.pop() <span class="comment"># 從遍歷過的節點中pop一個</span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> P[w]:</span><br><span class="line">        delta[v] += (sigma[v]/sigma[w]) * (<span class="number">1</span> + delta[w])</span><br><span class="line">    <span class="keyword">if</span> w != s:</span><br><span class="line">        C[w] += delta[w]</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>delta其實也是初始化變量的一部分啦，只是Pseudo Code放在這部分所以寫在這邊。</li>
<li>我們將節點從stack中取出來，去更新這些點的Betweenness Centrality，之所以用stack有兩個原因，第一個原因是我們只需要考慮能到達的節點，第二個原因是我們希望由終點往起點去更新。  </li>
<li>接著我們將每個w的path中的v取出，去更新這些v，<code>sigma[v]/sigma[w]</code>表示經過v的最短路徑數&#x2F;經過w的最短路徑數，這邊比較讓人confused的點應該是，根據前面提到的Betweenness Centrality公式，不是只有<code>sigma[v]/sigma[w]</code>嗎?為什麼要乘以<code>1+delta[w]</code>呢?原因是目前的介數中心性只考慮了v之於w的影響，我們要對其進行修正以納入w後面的節點的影響，我們一樣拿前面用過的例子來解釋：</li>
</ul>
<blockquote>
<p><img src="/../images/2023/03/29/simple_network_2.png" alt="simple network 2"><br>我們把原本的v當成新的w，把點1當成新的v，從s到w的最短路徑有三條，分別是<br><code>s -&gt; v -&gt; w</code><br><code>s -&gt; 2 -&gt; w</code><br><code>s -&gt; 3 -&gt; w</code><br>其中，經過v的只有一條，所以算出來Betweenness Centrality就是<code>sigma[v]/sigma[w] = 1/3</code>，但是!!! v不只在<code>s -&gt; w</code>的最短的路徑上，他也位於<code>s -&gt; w&#39;</code>的最短路徑中，這部分也要考慮進去，前面提到從<code>s -&gt; w&#39;</code>共有4條最短路徑，經過現在的v的只有1條，因此這部分是<code>sigma[v]/sigma[w&#39;] = 1/4</code>，而這個值其實會等於<code>1/3 * 3/4</code>，其中<code>3/4</code>是我們前面算得的<code>delta[w]</code>，因此把<code>s -&gt; w</code>與<code>s -&gt; w&#39;</code>的結果加起來，就會是：<br> <code>(sigma[v]/sigma[w]) + (sigma[v]/sigma[w&#39;])</code><br>&#x3D;<code>(sigma[v]/sigma[w]) + (sigma[v]/sigma[w])*delta[w]</code><br>&#x3D;<code>(sigma[v]/sigma[w]) * (1+delta[w])</code></p>
</blockquote>
<ul>
<li>最後，針對非起點s的節點，我們將其更新到最終結果中。</li>
</ul>
<p>標準化的部分雖然不在Pseudo Code中，但一般來說會順便做，方法如同公式的部分提到的，除以<code>((n-1)*(n-2))/2</code>就好。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> graph:</span><br><span class="line">    C[node] /= ((n-<span class="number">1</span>)*(n-<span class="number">2</span>))/<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="簡化版架構"><a href="#簡化版架構" class="headerlink" title="簡化版架構"></a>簡化版架構</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">betweenness_centrality</span>(<span class="params">graph</span>):</span><br><span class="line">    C = &#123;node: <span class="number">0</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> graph:</span><br><span class="line">        <span class="number">1.</span> 初始化變量</span><br><span class="line">        <span class="number">2.</span> 計算最短路徑 (BFS)</span><br><span class="line">        <span class="number">3.</span> 計算centrality</span><br><span class="line">    </span><br><span class="line">    do Normalization</span><br><span class="line">    <span class="keyword">return</span> C</span><br></pre></td></tr></table></figure>

<h2 id="完整程式碼"><a href="#完整程式碼" class="headerlink" title="完整程式碼"></a>完整程式碼</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">betweenness_centrality</span>(<span class="params">graph</span>):</span><br><span class="line"></span><br><span class="line">    C = &#123;node: <span class="number">0</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125; <span class="comment"># centrality</span></span><br><span class="line">    n = <span class="built_in">len</span>(C)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍歷每個節點</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> graph:</span><br><span class="line">        <span class="comment"># 1. 初始化變量</span></span><br><span class="line">        S = [] <span class="comment"># stack</span></span><br><span class="line">        P = &#123;node: [] <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125; <span class="comment"># path</span></span><br><span class="line">        sigma = &#123;node: <span class="number">0</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125; <span class="comment"># 初始化為-1，因為原點是0</span></span><br><span class="line">        sigma[s] = <span class="number">1</span> </span><br><span class="line">        d = &#123;node: -<span class="number">1</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125; <span class="comment"># distance</span></span><br><span class="line">        d[s] = <span class="number">0</span></span><br><span class="line">        Q = deque([s]) <span class="comment"># queue</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2. 計算最短路徑 (BFS)</span></span><br><span class="line">        <span class="keyword">while</span> Q:</span><br><span class="line">            v = Q.popleft()</span><br><span class="line">            S.append(v)</span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> graph[v]: <span class="comment"># for neighbor in neighbors</span></span><br><span class="line">                <span class="keyword">if</span> d[w] &lt; <span class="number">0</span>: <span class="comment"># 如果遇到新的節點才去更新他的距離</span></span><br><span class="line">                    Q.append(w)</span><br><span class="line">                    d[w] = d[v] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> d[w] == d[v] + <span class="number">1</span>: <span class="comment"># 判斷v是否在s到w的最短路徑中</span></span><br><span class="line">                    sigma[w] += sigma[v] <span class="comment"># 透過v去更新w的最短路徑數</span></span><br><span class="line">                    P[w].append(v)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 計算centrality</span></span><br><span class="line">        delta = &#123;node: <span class="number">0</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125;</span><br><span class="line">        <span class="keyword">while</span> S:</span><br><span class="line">            w = S.pop() <span class="comment"># 從遍歷過的節點中pop一個</span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> P[w]:</span><br><span class="line">                delta[v] += (sigma[v]/sigma[w]) * (<span class="number">1</span> + delta[w])</span><br><span class="line">            <span class="keyword">if</span> w != s:</span><br><span class="line">                C[w] += delta[w]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Normalization</span></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> graph:</span><br><span class="line">        C[node] /= ((n-<span class="number">1</span>)*(n-<span class="number">2</span>))/<span class="number">2</span> <span class="comment"># 將每個節點除以最大可能值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C</span><br></pre></td></tr></table></figure>



<h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>如果真的遇到要計算Betweenness Centrality的情況，當然還是直接用<code>networkx</code>套件裡的<code>betweenness_centrality</code>就好了啦，寫這篇單純是因為網路上都找不到有人說明算法的邏輯，所以希望寫這篇能幫助到其他想了解算法的人。<br>要注意上面的算法建立在所有edge的權重都是一樣的情況下，也就是點與點之間不是1就是0的binary關係，那如果每條edge有不同的權重呢?方法其實也不太意外，就是把程式中計算最短路徑的部分換掉就好了，根據實際情況可以選擇Dijkstra或是Bellman–Ford等。</p>
]]></content>
      <categories>
        <category>Social Network Analysis</category>
      </categories>
      <tags>
        <tag>Betweenness Centrality</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>資料結構筆記 - 布隆過濾器 Bloom Filter</title>
    <url>/posts/bloom-filter/</url>
    <content><![CDATA[<p><img src="/../images/2024/01/10/bloom-filter-new.png" alt="bloom-filter"></p>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><ul>
<li>用途: 用來快速判斷元素是否存在於一個集合中</li>
<li>優點: 快速、節省空間</li>
<li>缺點: 可能有 false positive (不存在但判定為存在)</li>
<li>應用: <ul>
<li>Check Duplicate: name、email 等是否已被使用</li>
<li>Filters: 過濾惡意請求 (ex: <a href="https://www.explainthis.io/zh-hant/swe/cache-mechanism">Cache penetration</a>)、垃圾郵件等</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>對元素使用 k 個 Hash Functions，將其映射到長度為 m 的 Array 中，寫入時將映射到的 k 個位置標示為 1，檢查時如果映射到的 k 個位置都命中，表示該元素<strong>可能存在</strong>。</p>
<ol>
<li><p>由預期的 <strong>False positive rate (p)</strong> 以及存入的<strong>資料筆數 (n)</strong> 來求出 <strong>Array Size (m)</strong> 以及 <strong>Hash Functions數 (k)</strong></p>
<ul>
<li><strong>False positive rate</strong><br>  <img src="/../images/2024/01/10/false-positive-probability.png" alt="false-positive-probability"></li>
<li><strong>Array size</strong><br>  <img src="/../images/2024/01/10/array-size.png" alt="array-size"></li>
<li><strong>Number of hash functions</strong><br>  <img src="/../images/2024/01/10/number-of-hash-functions.png" alt="number-of-hash-functions"></li>
</ul>
</li>
<li><p>選擇 Hash function<br>可以使用 <strong>Non-Cryptographic Hash</strong> (非密碼雜湊函數)，雖然有 collision 的可能，但足夠好了，而且比較快。<br>例如: MurmurHash、FarmHash、SpookyHash</p>
</li>
</ol>
<h1 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h1><p><strong>非原創!</strong> 基本上是下面參考文章中的程式碼，寫的很不錯所以只有小小修改一下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python 3 program to build Bloom Filter </span></span><br><span class="line"><span class="comment"># Install mmh3 and bitarray 3rd party module first </span></span><br><span class="line"><span class="comment"># pip install mmh3 </span></span><br><span class="line"><span class="comment"># pip install bitarray </span></span><br><span class="line"><span class="keyword">import</span> math </span><br><span class="line"><span class="keyword">import</span> mmh3 </span><br><span class="line"><span class="keyword">from</span> bitarray <span class="keyword">import</span> bitarray </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BloomFilter</span>(<span class="title class_ inherited__">object</span>): </span><br><span class="line"></span><br><span class="line">	<span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">	Class for Bloom filter, using murmur3 hash function </span></span><br><span class="line"><span class="string">	&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, items_count, fp_prob</span>): </span><br><span class="line">		<span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">		items_count : int </span></span><br><span class="line"><span class="string">			Number of items expected to be stored in bloom filter </span></span><br><span class="line"><span class="string">		fp_prob : float </span></span><br><span class="line"><span class="string">			False Positive probability in decimal </span></span><br><span class="line"><span class="string">		&#x27;&#x27;&#x27;</span></span><br><span class="line">		<span class="comment"># False possible probability in decimal </span></span><br><span class="line">		self.fp_prob = fp_prob </span><br><span class="line"></span><br><span class="line">		<span class="comment"># Size of bit array to use </span></span><br><span class="line">		self.size = self.get_size(items_count, fp_prob) </span><br><span class="line"></span><br><span class="line">		<span class="comment"># number of hash functions to use </span></span><br><span class="line">		self.hash_count = self.get_hash_count(self.size, items_count) </span><br><span class="line"></span><br><span class="line">		<span class="comment"># Bit array of given size, default all 0 </span></span><br><span class="line">		self.bit_array = bitarray(self.size) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, item</span>): </span><br><span class="line">		<span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">		Add an item in the filter </span></span><br><span class="line"><span class="string">		&#x27;&#x27;&#x27;</span></span><br><span class="line">		digests = [] </span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.hash_count): </span><br><span class="line"></span><br><span class="line">			<span class="comment"># create digest for given item. </span></span><br><span class="line">			<span class="comment"># i work as seed to mmh3.hash() function </span></span><br><span class="line">			<span class="comment"># With different seed, digest created is different </span></span><br><span class="line">			digest = mmh3.<span class="built_in">hash</span>(item, i) % self.size </span><br><span class="line">			digests.append(digest) </span><br><span class="line"></span><br><span class="line">			<span class="comment"># set the bit True in bit_array </span></span><br><span class="line">			self.bit_array[digest] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">self, item</span>): </span><br><span class="line">		<span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">		Check for existence of an item in filter </span></span><br><span class="line"><span class="string">		&#x27;&#x27;&#x27;</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.hash_count): </span><br><span class="line">			digest = mmh3.<span class="built_in">hash</span>(item, i) % self.size </span><br><span class="line">			<span class="keyword">if</span> self.bit_array[digest] == <span class="literal">False</span>: </span><br><span class="line"></span><br><span class="line">				<span class="comment"># if any of bit is False then,its not present </span></span><br><span class="line">				<span class="comment"># in filter </span></span><br><span class="line">				<span class="comment"># else there is probability that it exist </span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">	@staticmethod</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">get_size</span>(<span class="params">n, p</span>): </span><br><span class="line">		<span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">		Return the size of bit array(m) to used using </span></span><br><span class="line"><span class="string">		following formula </span></span><br><span class="line"><span class="string">		m = -(n * lg(p)) / (lg(2)^2) </span></span><br><span class="line"><span class="string">		n : int </span></span><br><span class="line"><span class="string">			number of items expected to be stored in filter </span></span><br><span class="line"><span class="string">		p : float </span></span><br><span class="line"><span class="string">			False Positive probability in decimal </span></span><br><span class="line"><span class="string">		&#x27;&#x27;&#x27;</span></span><br><span class="line">		m = -(n * math.log(p))/(math.log(<span class="number">2</span>)**<span class="number">2</span>) </span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">int</span>(m) </span><br><span class="line"></span><br><span class="line"><span class="meta">	@staticmethod</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">get_hash_count</span>(<span class="params">m, n</span>): </span><br><span class="line">		<span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">		Return the hash function(k) to be used using </span></span><br><span class="line"><span class="string">		following formula </span></span><br><span class="line"><span class="string">		k = (m/n) * lg(2) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		m : int </span></span><br><span class="line"><span class="string">			size of bit array </span></span><br><span class="line"><span class="string">		n : int </span></span><br><span class="line"><span class="string">			number of items expected to be stored in filter </span></span><br><span class="line"><span class="string">		&#x27;&#x27;&#x27;</span></span><br><span class="line">		k = (m/n) * math.log(<span class="number">2</span>) </span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">int</span>(k)</span><br></pre></td></tr></table></figure>

<p>看一下成果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">100000</span> <span class="comment"># Number of items to add </span></span><br><span class="line">p = <span class="number">0.05</span> <span class="comment"># False positive probability </span></span><br><span class="line">  </span><br><span class="line">bloomf = BloomFilter(n,p) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Array size: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(bloomf.size)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of hash functions: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(bloomf.hash_count)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;False positive probability: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(bloomf.fp_prob)) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Add items</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">	bloomf.add(<span class="built_in">str</span>(i))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check false positive rate on Test data</span></span><br><span class="line">fp = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n, <span class="number">2</span>*n):</span><br><span class="line">	<span class="keyword">if</span> bloomf.check(<span class="built_in">str</span>(i)):</span><br><span class="line">		fp += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;False positive rate on test data: &#123;:.4f&#125;&quot;</span>.<span class="built_in">format</span>(fp/n)) </span><br></pre></td></tr></table></figure>

<p>可以看到實際的 FP Rate 與我們設定的非常接近。<br><img src="/../images/2024/01/10/filter-result.png" alt="filter-result"></p>
<h1 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h1><p><a href="https://www.geeksforgeeks.org/bloom-filters-introduction-and-python-implementation/">Bloom Filters – Introduction and Implementation</a></p>
]]></content>
      <categories>
        <category>DSA</category>
      </categories>
      <tags>
        <tag>資料結構</tag>
        <tag>Bloom Filter</tag>
      </tags>
  </entry>
  <entry>
    <title>系統架構筆記 - 常見的五種部署策略</title>
    <url>/posts/deployment-strategies/</url>
    <content><![CDATA[<p><img src="/../images/2024/01/16/strategies.png" alt="strategies"></p>
<p>這篇文章簡單紀錄了常見的五種部署策略: Big Bang Deployment、Rolling Deployment (滾動部署)、Blue-Green Deployment (藍綠部署)、Canary Deployment (金絲雀部署) 與 Shadow Deployment (影子部署)。</p>
<span id="more"></span>

<h1 id="Big-Bang-Deployment"><a href="#Big-Bang-Deployment" class="headerlink" title="Big Bang Deployment"></a>Big Bang Deployment</h1><p>名字聽起來很 Dramatic 的部署策略，將舊版本完全下線後部署新版本。</p>
<ul>
<li>優點: <ul>
<li>easy、一次性完成</li>
</ul>
</li>
<li>缺點: <ul>
<li>有 downtime，一般生產環境下不會使用</li>
</ul>
</li>
</ul>
<h1 id="Rolling-Deployment-滾動部署"><a href="#Rolling-Deployment-滾動部署" class="headerlink" title="Rolling Deployment (滾動部署)"></a>Rolling Deployment (滾動部署)</h1><p><img src="/../images/2024/01/16/rolling.png" alt="rolling"></p>
<p>將舊版本逐步 (one by one) 更新為新版本，在這個過程中，舊版本和新版本會共存一段時間。</p>
<ul>
<li>優點: <ul>
<li>no downtime</li>
</ul>
</li>
<li>缺點: <ul>
<li>新舊版本間沒有隔離，可能需要處理版本之間的相容性與數據一致性</li>
<li>rollback 也是逐步滾回去，複雜且耗時</li>
</ul>
</li>
</ul>
<h1 id="Blue-Green-Deployment-藍綠部署"><a href="#Blue-Green-Deployment-藍綠部署" class="headerlink" title="Blue-Green Deployment (藍綠部署)"></a>Blue-Green Deployment (藍綠部署)</h1><p><img src="/../images/2024/01/16/blue-green.png" alt="blue-green"></p>
<p>同時維護兩個平行的環境，一個為主要環境 (Blue)，另一個為即將上線的新版本 (Green)，於測試環境測試完新版本後，直接將兩個環境的流量做切換。</p>
<ul>
<li>優點: <ul>
<li>no downtime</li>
<li>直接切換流量即可完成版本切換，rollback 也是</li>
</ul>
</li>
<li>缺點: <ul>
<li>要同時維護兩個環境，成本高</li>
</ul>
</li>
</ul>
<h1 id="Canary-Deployment-金絲雀部署"><a href="#Canary-Deployment-金絲雀部署" class="headerlink" title="Canary Deployment (金絲雀部署)"></a>Canary Deployment (金絲雀部署)</h1><p><img src="/../images/2024/01/16/canary.png" alt="canary"></p>
<p>將新版本釋出給少量用戶做測試，測試沒問題後才將剩下的部署為新版本。</p>
<ul>
<li>優點: <ul>
<li>no downtime</li>
<li>能於生產環境中評估新版本效能，降低新版本風險</li>
<li>rollback 較容易</li>
</ul>
</li>
<li>缺點: <ul>
<li>部署時間較長</li>
<li>某些問題無法靠少量用戶就發現</li>
</ul>
</li>
<li>與 Rolling Deployment 的差異<ul>
<li>Canary Deployment 是階段式的過程，先部署少部分，確定沒問題才擴大部署</li>
<li>Rolling Deployment 則連續的過程，一次對整個系統做升級，只是過程上是逐步部署</li>
</ul>
</li>
</ul>
<h1 id="Shadow-Deployment-影子部署"><a href="#Shadow-Deployment-影子部署" class="headerlink" title="Shadow Deployment (影子部署)"></a>Shadow Deployment (影子部署)</h1><p>同時維護兩個平行的環境，新版本在幕後運行 (in the shadow)，使用者的 request 會被複製一份到新版本用於測試</p>
<ul>
<li>優點:<ul>
<li>不會對使用者造成實際影響，同時能測試新版本效能</li>
</ul>
</li>
<li>缺點<ul>
<li>實作上比較困難</li>
<li>成本高</li>
</ul>
</li>
</ul>
<h2 id="其他-Feature-Toggle"><a href="#其他-Feature-Toggle" class="headerlink" title="其他: Feature Toggle"></a>其他: Feature Toggle</h2><p><img src="/../images/2024/01/16/feature-toggle.png" alt="feature-toggle"></p>
<p>封面的圖片裡還有提到一個 Feature Toggle，概念是在程式中設計一個開關來控制新功能的狀態，可以針對特定用戶開啟，用來觀察新功能的效能、反饋如何，通常是用來做 A&#x2F;B Test，本質上跟前面提到的幾個部署方法有點差異。</p>
]]></content>
      <categories>
        <category>system design</category>
      </categories>
      <tags>
        <tag>deployment strategy</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 自學筆記 01 - Basics</title>
    <url>/posts/java-learning-01/</url>
    <content><![CDATA[<h2 id="JVM-JRE-amp-JDK"><a href="#JVM-JRE-amp-JDK" class="headerlink" title="JVM, JRE &amp; JDK"></a>JVM, JRE &amp; JDK</h2><p><img src="/../images/2024/03/18/JVM_JRE_JDK.png" alt="JVM, JRE &amp; JDK"></p>
<h3 id="Java-vs-C"><a href="#Java-vs-C" class="headerlink" title="Java vs C"></a>Java vs C</h3><p>當開發 C 或 C++ 程式時，通常會先將原始碼透過編譯器轉換成目標機器可以理解的 Object Code。這個 Object Code 是特定於目標機器架構的，因此在不同的硬體平台上可能會產生不同的機器碼。因此，當將程式移植到不同的機器或架構時，通常需要重新編譯原始碼以生成適用於該特定平台的新 Object Code。</p>
<span id="more"></span>

<h3 id="JVM-Java-Virtual-Machine"><a href="#JVM-Java-Virtual-Machine" class="headerlink" title="JVM (Java Virtual Machine)"></a>JVM (Java Virtual Machine)</h3><p>Java 通過 JVM 來解決跨平台的問題，程式在編譯時是先翻譯成 JVM 的 Byte code，執行時才由 JVM 轉換為機器碼，由於不是直接編譯成機械碼，這表示只要新的平台有安裝 JVM，就不用重新編譯一遍了。<br>某方面來說 JVM 算是一種 interpreter，負責執行 Byte code。<br><img src="/../images/2024/03/18/JVM.png" alt="JVM"></p>
<h3 id="JRE-Java-Runtime-Environment"><a href="#JRE-Java-Runtime-Environment" class="headerlink" title="JRE (Java Runtime Environment)"></a>JRE (Java Runtime Environment)</h3><p>JRE 包含了執行 Java 程式所需的所有檔案和庫，包括 JVM、Class Libraries、Java API 等，也就是說單單是執行而不需要開發的話安裝 JRE 就夠了。</p>
<h3 id="JDK-Java-Development-Kit"><a href="#JDK-Java-Development-Kit" class="headerlink" title="JDK (Java Development Kit)"></a>JDK (Java Development Kit)</h3><p>JDK 是一個完整的 Java 開發套件，包括了 JRE、編譯器 (javac) 以及開發所需要的各種工具和庫。</p>
<h2 id="Hello-Java"><a href="#Hello-Java" class="headerlink" title="Hello Java"></a>Hello Java</h2><ul>
<li><p>Hello.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> <span class="comment">//Class 的名稱要跟檔名一模一樣</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">   &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello Java&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>compile</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">javac Hello.java</span></span><br></pre></td></tr></table></figure></li>
<li><p>run</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java Hello</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Data-Type"><a href="#Data-Type" class="headerlink" title="Data Type"></a>Data Type</h2><p><img src="/../images/2024/03/18/java_data_type.png" alt="Java Data Type"></p>
<h3 id="資料型態轉換"><a href="#資料型態轉換" class="headerlink" title="資料型態轉換"></a>資料型態轉換</h3><ul>
<li><p>浮點數大於整數<br>  double &gt; float &gt; long &gt; int &gt; short &gt; byte</p>
</li>
<li><p>小轉大OK，大轉小error<br>  <img src="/../images/2024/03/18/java_casting.png" alt="Java Casting"></p>
</li>
<li><p>大轉小可以強制轉換，但可能失真</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">n2</span> <span class="operator">=</span> (<span class="type">byte</span>)n1; <span class="comment">// 不一樣 (2進位高位被截斷)</span></span><br></pre></td></tr></table></figure></li>
<li><p>字串轉數字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;1234&quot;</span>)</span><br><span class="line"><span class="type">long</span> <span class="variable">n2</span> <span class="operator">=</span> Long.parseLong(<span class="string">&quot;1234&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>數字轉字串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> String.valueOf(<span class="number">1234</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> String.valueOf(<span class="number">1.234</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="標準輸入"><a href="#標準輸入" class="headerlink" title="標準輸入"></a>標準輸入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> s.nextInt();</span><br><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> s.next();</span><br></pre></td></tr></table></figure>

<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>Java 的陣列跟 C 不一樣，不是以連續的記憶體表達陣列，而是以一種 object 的形式實作，因此多維的陣列係由前一層指向後一層，所以不同層的 Array 長度可以不一樣 !!!</p>
<p><img src="/../images/2024/03/18/java_array.png" alt="Java Array"></p>
<p>Array 的宣告與初始化方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] x = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">x = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line">x.length <span class="comment">// x的長度</span></span><br></pre></td></tr></table></figure>


<h2 id="Class-and-Object"><a href="#Class-and-Object" class="headerlink" title="Class and Object"></a>Class and Object</h2><ul>
<li>Object 產生時一定要呼叫的方法，稱為 Constructor (建構子)</li>
<li>Objec 消滅需要呼叫的方法，稱為 Destructor (解構子)</li>
<li>表達 Object 內部狀態的變數，稱為 Object Variable (物件變數成員)</li>
<li>Object 可以接收的訊息，稱為 Object Method (物件方法成員)</li>
<li>上述兩個可總稱為 Object Member</li>
<li>屬於 Class 的變數，稱為Class Variable (類別變數)</li>
<li>屬於 Class 的方法，稱為 Class Method (類別方法)</li>
<li>上述兩個可總稱為 Class Member</li>
<li>和其他 Class 間的繼承關係</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> speed; <span class="comment">// Object Variable</span></span><br><span class="line">    <span class="keyword">private</span> String direction; <span class="comment">// Object Variable, direction is a reference to String Object</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">numVehicle</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// Class Variable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vehicle</span><span class="params">()</span> &#123; <span class="comment">// Constructor, called when new a Object</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="number">0</span>,<span class="string">&quot;north&quot;</span>); <span class="comment">// call another constructor to do initialization</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vehicle</span><span class="params">(<span class="type">int</span> s, String dir)</span> &#123; <span class="comment">// Another Constructor. Use overloading to define two constructors</span></span><br><span class="line">        <span class="type">float</span> speed; <span class="comment">// define a local variable</span></span><br><span class="line">        speed = s; <span class="comment">// the speed here refers to the above local variable</span></span><br><span class="line">        <span class="built_in">this</span>.speed = s; <span class="comment">// If we want to set object variable, use this.speed to refer object variable speed</span></span><br><span class="line">        direction = dir; <span class="comment">// dir is a reference to object, not the object itself</span></span><br><span class="line">        numVehicle++;   <span class="comment">// increase the Vehicle number</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123; <span class="comment">// Destructor, called when the object is garbage collected by JVM</span></span><br><span class="line">        System.out.println(<span class="string">&quot;finalize has been called&quot;</span>);</span><br><span class="line">        numVehicle--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setSpeed</span><span class="params">(<span class="type">int</span> newSpeed)</span> &#123; <span class="comment">// Object Method</span></span><br><span class="line">        <span class="built_in">this</span>.speed = newSpeed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setDir</span><span class="params">(String dir)</span> &#123; <span class="comment">// Object Method</span></span><br><span class="line">        <span class="built_in">this</span>.direction = dir;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getSpeed</span><span class="params">()</span> &#123; <span class="comment">// Object Method</span></span><br><span class="line">        <span class="keyword">return</span> speed;</span><br><span class="line">    &#125;</span><br><span class="line">    String <span class="title function_">getDir</span><span class="params">()</span> &#123; <span class="comment">// Object Method</span></span><br><span class="line">        <span class="keyword">return</span> direction;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">totalVehicle</span><span class="params">()</span> &#123; <span class="comment">// Class Method</span></span><br><span class="line">        <span class="keyword">return</span> numVehicle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.geeksforgeeks.org/differences-jdk-jre-jvm/">https://www.geeksforgeeks.org/differences-jdk-jre-jvm/</a><br><a href="https://programming.im.ncnu.edu.tw/J_index.html">https://programming.im.ncnu.edu.tw/J_index.html</a></p>
]]></content>
      <categories>
        <category>Java Learning</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB概念介紹 + PyMongo基本CRUD操作教學</title>
    <url>/posts/pymongo/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="/../images/2023/05/05/cover.png" alt="cover image"></p>
<p>因為課堂專案的關係需要用到MongoDB所以小學了一下，發現MongoDB真的是很香，撇開資料庫易用性，光是MongoDB Atlas提供每位使用者免費10GB的雲端資料庫空間(免填信用卡)，就很值得你辦個帳號來玩一下了。這篇文章會簡單介紹一下MongoDB，以及如何用python PyMongo完成資料庫的CRUD操作。</p>
<span id="more"></span>

<h1 id="MongoDB-Atlas"><a href="#MongoDB-Atlas" class="headerlink" title="MongoDB Atlas"></a>MongoDB Atlas</h1><p>MongoDB Atlas是MongoDB的雲端資料庫平台服務，顧名思義你可以把你的資料存在雲端裡面，如果你是用drivers(ex: python, nodejs…)連線進去的話，基本上就是安裝個套件就搞定了，不用額外去下載或是設定一些雜七雜八的東西真的很方便，另外也因為是雲端服務，因此在團隊成員要連線進來也很容易，拿來run一個課堂專案是綽綽有餘了。</p>
<p>因為文章重點會放在MongoDB的觀念與操作，這裡就提供一篇教學讓大家自己看: </p>
<ul>
<li><a href="https://www.tpisoftware.com/tpu/articleDetails/2758" title="{rel=&#39;nofollow&#39;}">如何快速地架好自己的MongoDB - MongoDB Atlas介紹</a></li>
</ul>
<p>其實就是跟著指示做，都挺直覺的，雲端供應商的部分我也是選GCP，因為有台灣的region，這邊唯一要注意的是可連線IP的部分，要把IP地址加入名單中才能成功與資料庫建立連線，有個小撇步是只要在名單中加入<code>0.0.0.0</code>，就可以無視當前IP位址隨便連了~</p>
<h1 id="MongoDb-Introduction"><a href="#MongoDb-Introduction" class="headerlink" title="MongoDb Introduction"></a>MongoDb Introduction</h1><h2 id="Datebase-architecture"><a href="#Datebase-architecture" class="headerlink" title="Datebase architecture"></a>Datebase architecture</h2><p>MongoDB屬於<strong>General Purpose Document Database</strong>(文件資料庫)，先來了解一下幾個關鍵字:</p>
<blockquote>
<p><strong>Document</strong>: Basic unit of data<br><strong>Collection</strong>: A grouping of documents<br><strong>Database</strong>: A container for collections</p>
</blockquote>
<h2 id="Document-Model"><a href="#Document-Model" class="headerlink" title="Document Model"></a>Document Model</h2><p>document是MongoDB的基本資料單位，每個document都以BSON格式儲存(類似JSON格式，但多了一些特殊的資料型態)，與關連式資料庫不同，MongoDB有polymorphic documents的特性，沒有寫死的schema，使用時不需要事先定義欄位、資料型態，相反的你想怎麼存就怎麼存，同個collection裡的document可以長的完全不一樣，**BUT!!!**，有彈性不代表就可以亂存，還是要視實際的使用情境來設計schema才不會害到自己喔。</p>
<h2 id="Data-Modeling"><a href="#Data-Modeling" class="headerlink" title="Data Modeling"></a>Data Modeling</h2><p>延續前面提到的schema，究竟該如何設計一個好的schema，MongoDB有提供兩個非常明確的原則</p>
<blockquote>
<p>Thinking about the application rather than thinking about how it’s stored.<br>Data accessed together should be stored todether.</p>
</blockquote>
<p>第一點是在說我們在設計資料庫schema時應該focus在「我們的application如何取用資料」，而不是「如何把資料存好」。<br>第二點則是與MongoDB的架構有關，因為資料都是以document為單位，因此把會一起使用到的資料都存在同一個document裡面，通常會比存在兩個分別的document裡面來的方便取用。</p>
<h2 id="Relationship-types"><a href="#Relationship-types" class="headerlink" title="Relationship types"></a>Relationship types</h2><p>照上面這麼說的話，那簡單，全部塞進同個document就對了嗎? 其實也不對，因為每個documnet其實有16MB的size limit，所以我們還是要視情況來建立我們的關聯規則，以下介紹3種關聯規則以及MongoDB的建議的儲存方法。</p>
<ol>
<li>one to one<br>顧名思義就是一個對一個，以學生資料來說，每位學生都有自己獨特且唯一學號，這時候我們就沒必要把學號另外存在別的document，直接存在一起就好。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#x27;_id&#x27;: ObjectID(...),  # MongoDB預設的_id格式，沒有設定_id的話會自動assign</span><br><span class="line">  &#x27;Name&#x27;: &#x27;Jack&#x27;,</span><br><span class="line">  &#x27;Mobile&#x27;: &#x27;0800-000000&#x27;,</span><br><span class="line">  &#x27;ID&#x27;: &#x27;A0001&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>one to many<br>現在假設我們還需要存每位學生的家長資料，畢竟每個人的家長資料肯定是不重複的嘛，所以我們還是想存在同一個document裡，這時候我們可以使用<strong>Embedding</strong>的技巧，簡單來說就是巢狀結構加下去就對了XD。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#x27;_id&#x27;: ObjectID(...),</span><br><span class="line">  &#x27;Name&#x27;: &#x27;Jack&#x27;,</span><br><span class="line">  &#x27;Mobile&#x27;: &#x27;0800-000000&#x27;,</span><br><span class="line">  &#x27;ID&#x27;: &#x27;A0001&#x27;,</span><br><span class="line">  &#x27;Parents&#x27;: &#123;</span><br><span class="line">    &#x27;Dad&#x27;: &#123;&#x27;Name&#x27;: &#x27;Bob&#x27;, &#x27;Mobile&#x27;: &#x27;0800-000001&#x27;&#125;,</span><br><span class="line">    &#x27;Mom&#x27;: &#123;&#x27;Name&#x27;: &#x27;Amy&#x27;, &#x27;Mobile&#x27;: &#x27;0800-000002&#x27;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>many to many<br>繼續前面例子，每個學生每學期都會修很多課，並且同一堂課會有很多學生一起修，這時候我們如果用Embedding的話雖然很方便，但有點太浪費資料庫空間了，會出現很多重複的資料，這時我們可以視情況使用<strong>Referencing</strong>的技巧，基本上跟Embedding很像，改成存用來join的key。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#x27;_id&#x27;: ObjectID(...),</span><br><span class="line">  &#x27;Name&#x27;: &#x27;Jack&#x27;,</span><br><span class="line">  &#x27;Mobile&#x27;: &#x27;0800-000000&#x27;,</span><br><span class="line">  &#x27;ID&#x27;: &#x27;A0001&#x27;,</span><br><span class="line">    &#x27;Parents&#x27;: &#123;</span><br><span class="line">    &#x27;Dad&#x27;: &#123;&#x27;Name&#x27;: &#x27;Bob&#x27;, &#x27;Mobile&#x27;: &#x27;0800-000001&#x27;&#125;,</span><br><span class="line">    &#x27;Mom&#x27;: &#123;&#x27;Name&#x27;: &#x27;Amy&#x27;, &#x27;Mobile&#x27;: &#x27;0800-000002&#x27;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x27;courses&#x27;: [ObjectID(...), ObjectID(...), ...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>要注意的是Embedding跟Referencing的使用時機是看情況決定!不是one to many就一定要用Embedding，也不是many to many就一定要用Referencing，還要考慮<strong>資料規模</strong>，如果one to many，但連出去的資料非常龐大，那一樣要改用Referencing才存得下。</p>
<h1 id="CRUD-in-PyMongo"><a href="#CRUD-in-PyMongo" class="headerlink" title="CRUD in PyMongo"></a>CRUD in PyMongo</h1><p>以防有人不知道CRUD是什麼，CRUD對應到database的4個基本操作Create、Read、Update、Delete，要在MongoDB操作CRUD有很多方法，除了使用MogoDB自己的CLI外，官方也提供豐富的<a href="https://www.mongodb.com/docs/drivers/" title="{rel=&#39;nofollow&#39;}">libraries</a>，以python來說就有兩個libraries，PyMongo負責處理同步連線、Motor負責處理非同步連線，接下來會介紹如何使用PyMongo來操作CRUD。</p>
<h2 id="Beforehand"><a href="#Beforehand" class="headerlink" title="Beforehand"></a>Beforehand</h2><p>第一步當然是要先安裝套件:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">! pip install pymongo</span><br></pre></td></tr></table></figure>

<p>接著我們import套件並建立連線:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line">client = MongoClient(CONNECTION_STRING)</span><br></pre></td></tr></table></figure>
<p>其中，<code>CONNECTION_STRING</code>的格式長這樣，記得要換成自己的帳號、密碼:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongodb+srv://&lt;user_name&gt;:&lt;password&gt;@thrifty.0xdedx2.mongodb.net/?retryWrites=true&amp;w=majority</span><br></pre></td></tr></table></figure>
<p>這串東西好長喔記不起來怎麼辦? 進入mongodb atlas後，可以在 Connect → Drivers → python 裡找到<br><img src="/../images/2023/05/05/mongodb_atlas_connect.png" alt="mongodb atlas connect"><br><img src="/../images/2023/05/05/mongodb_atlas_connection_string.png" alt="mongodb atlas connection string"></p>
<p>我們可以直接透過client物件來建立或取用database，可以使用key-value的方式或呼叫object的方式，舉例來說我想要create一個名叫test_database的database，那我可以用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">database = client.test_database <span class="comment"># or</span></span><br><span class="line">database = client[<span class="string">&#x27;test_database&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>同理，我們可以透過db物件來建立或取用collection:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">collection = database.test_collection <span class="comment"># or</span></span><br><span class="line">collection = database[<span class="string">&#x27;test_collection&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>好了，事前工作準備完成!</p>
<h2 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h2><p>在PyMongo中，我們可以使用<code>insert_one</code>&#x2F;<code>insert_many</code>來插入新的document:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 要插入的資料</span></span><br><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line">b = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line">c = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;female&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">collection.insert_one(a)       <span class="comment"># 插入一個檔案</span></span><br><span class="line">collection.insert_many([b, c]) <span class="comment"># 插入多個檔案</span></span><br></pre></td></tr></table></figure>

<h2 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h2><p>在PyMongo中，我們可以使用<code>find_one</code>或<code>find</code>來尋找一個或多個的document:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># find_one會回傳符合條件的第一筆資料(沒放條件的話就是collection的第一筆doc)</span></span><br><span class="line">collection.find_one()</span><br><span class="line"></span><br><span class="line"><span class="comment"># find會回傳所有符合條件的資料，並將其包裝為一個類似iterator的物件(沒放條件的話就是collection裡所有doc)</span></span><br><span class="line">docs = collection.find()</span><br><span class="line"><span class="comment"># 我們可以將該物件放入for迴圈中查看結果</span></span><br><span class="line"><span class="keyword">for</span> doc <span class="keyword">in</span> docs:</span><br><span class="line">  <span class="built_in">print</span>(doc)</span><br></pre></td></tr></table></figure>

<p>我們可以在function中加入條件，來查找符合條件的資料，因為操作都差不多，所以接下來只用<code>find_one</code>做示範。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">collection.find_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;a&#x27;</span>&#125;)</span><br><span class="line">collection.find_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;) <span class="comment"># 可以放多個條件</span></span><br></pre></td></tr></table></figure>
<p>上面的代碼會幫我們找到name等於a的資料，但其實這是一個簡化的寫法，MongoDB在進行條件篩選時通常會透過<strong>Comparison Operators</strong>的幫忙，實際上完整的寫法長這樣:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">collection.find_one(&#123;<span class="string">&#x27;name&#x27;</span>: &#123;<span class="string">&#x27;$eq&#x27;</span>: <span class="string">&#x27;a&#x27;</span>&#125;, <span class="string">&#x27;gender&#x27;</span>: &#123;<span class="string">&#x27;$eq&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>這裡的<code>$eq</code>就是equal to的意思，因為是最基本的操作所以可以直接不寫，另外還有很多用於條件判斷的operator，舉例來說:</p>
<blockquote>
<p><code>$gt</code> : greater to<br><code>$lt</code> : lower to<br><code>$gte</code> : greater or equal to<br><code>$lte</code> : lower or equal to<br><code>$ne</code> : not equal to</p>
</blockquote>
<p>除了<strong>Comparison Operators</strong>外，在處理多個條件時，我們通常需要使用<strong>Logical Operators</strong>來幫助我們做多條件的判斷，上面例子同樣因為是基本操作所以可以直接寫，實際上也可以這樣寫:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">collection.find_one(&#123;<span class="string">&#x27;$and&#x27;</span>: [&#123;<span class="string">&#x27;name&#x27;</span>: &#123;<span class="string">&#x27;$eq&#x27;</span>: <span class="string">&#x27;a&#x27;</span>&#125;&#125;, &#123;<span class="string">&#x27;gender&#x27;</span>: &#123;<span class="string">&#x27;$eq&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;&#125;]&#125;)</span><br></pre></td></tr></table></figure>
<p>基本上跟一般程式語言的用法很像，常見的有:</p>
<blockquote>
<p><code>$or</code> : or<br><code>$not</code> : not</p>
</blockquote>
<p>上面只介紹了部分的query operators，想了解更多query operators可以參考<a href="https://www.mongodb.com/docs/manual/reference/operator/query/" title="{rel=&#39;nofollow&#39;}">這裡</a>。</p>
<h2 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h2><p>PyMongo中用來更新document的function有三大類，分別是</p>
<ol>
<li><code>replace_one</code></li>
<li><code>update_one</code>&#x2F;<code>update_many</code></li>
</ol>
<p>差別在於replace會把整個documnet都取代為新的，update則只會去更新document中被指定的部分。兩者在使用上都由三個部分組成，分別是filter、replacement&#x2F;update和options，其中filter是篩選的條件，寫法跟前面find一樣，replacement&#x2F;update是要更新的document&#x2F;部分document，options則是更新時可以設定的選項。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># template</span></span><br><span class="line">collection.replace_one(<span class="built_in">filter</span>, replacement, options) <span class="comment"># 取代符合條件的資料的第一筆資料</span></span><br><span class="line">collection.update_one(<span class="built_in">filter</span>, update, options)       <span class="comment"># 更新符合條件的第一筆資料</span></span><br><span class="line">collection.update_many(<span class="built_in">filter</span>, update, options)      <span class="comment"># 更新符合條件的所有資料</span></span><br></pre></td></tr></table></figure>
<p>要特別留意的是，在update的部分一定要搭配使用<strong>Update Operators</strong>，否則會執行失敗!常用的operators有:</p>
<blockquote>
<p><code>$set</code> : set to new value<br><code>$push</code>: appends value to an array<br><code>$inc</code> : increased by value</p>
</blockquote>
<p>最後options部分，這邊只提最常被使用到的<code>upsert</code>(update+insert)，預設為<code>False</code>，如果將<code>upsert</code>設為<code>True</code>的話，那就算filter部分沒有找到符合的document，也會順便幫我們執行insert的動作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 尋找name為d的document並取代為新documnet，因為沒有這個document而且upsert=True，所以會直接insert</span></span><br><span class="line">collection.replace_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;d&#x27;</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;arr&#x27;</span>: []&#125;, upsert=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 將name重新命名</span></span><br><span class="line">collection.update_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;d&#x27;</span>&#125;, &#123;<span class="string">&#x27;$set&#x27;</span>: &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;e&#x27;</span>&#125;&#125;)</span><br><span class="line"><span class="comment"># 把item推入array當中</span></span><br><span class="line">collection.update_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;e&#x27;</span>&#125;, &#123;<span class="string">&#x27;$push&#x27;</span>: &#123;<span class="string">&#x27;arr&#x27;</span>: <span class="string">&#x27;item&#x27;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h2><p>PyMongo中用來刪除document的function是<code>delete_one</code>與<code>delete_many</code>，用法跟find基本一樣~</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">collection.delete_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;a&#x27;</span>&#125;)  <span class="comment"># 刪除符合條件的第一筆資料</span></span><br><span class="line">collection.delete_many(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;a&#x27;</span>&#125;) <span class="comment"># 刪除符合條件的所有資料</span></span><br></pre></td></tr></table></figure>


<h2 id="bulk-write"><a href="#bulk-write" class="headerlink" title="bulk_write"></a>bulk_write</h2><p>前面的操作都一次針對一個條件進行動作，假如我們想要快速地執行多個不同動作該怎麼辦呢? 這時我們可以將原先的CRUD指令包裝成Object，並透過<code>bulk_write</code>來進行批次操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> InsertOne, DeleteMany, ReplaceOne, UpdateOne</span><br><span class="line">result = colection.bulk_write([</span><br><span class="line">    DeleteMany(&#123;&#125;),</span><br><span class="line">    InsertOne(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;),</span><br><span class="line">    InsertOne(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;),</span><br><span class="line">    InsertOne(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;female&#x27;</span>&#125;),</span><br><span class="line">    ReplaceOne(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;d&#x27;</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;arr&#x27;</span>: []&#125;, upsert=<span class="literal">True</span>),</span><br><span class="line">    UpdateOne(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;d&#x27;</span>&#125;, &#123;<span class="string">&#x27;$set&#x27;</span>: &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;e&#x27;</span>&#125;&#125;),</span><br><span class="line">    UpdateOne(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;e&#x27;</span>&#125;, &#123;<span class="string">&#x27;$push&#x27;</span>: &#123;<span class="string">&#x27;arr&#x27;</span>: <span class="string">&#x27;item&#x27;</span>&#125;&#125;)</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>MongoDB在網路上的教學資源真的很豐富，官方也有提供<a href="https://learn.mongodb.com/" title="{rel=&#39;nofollow&#39;}">免費課程</a>，想要上手真的不是一件難事，我都邊寫邊懷疑自己寫這篇到底有多大價值，因為網路上其他地方大概也都找的到類似的內容，不過抱持著當做筆記說不定哪天旺季會想回來看的精神，還是乖乖把他寫完了XDDD</p>
]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>PyMongo</tag>
      </tags>
  </entry>
  <entry>
    <title>系統架構筆記 - 垂直擴展、水平擴展</title>
    <url>/posts/scaling/</url>
    <content><![CDATA[<p><img src="/../images/2024/01/17/scaling.png" alt="scaling"></p>
<p>這篇文章會介紹垂直擴展以及水平擴展，並以資料庫的水平擴展為延伸，介紹讀寫分離與資料庫切分 (Sharding)。</p>
<span id="more"></span>

<h1 id="垂直擴展"><a href="#垂直擴展" class="headerlink" title="垂直擴展"></a>垂直擴展</h1><p>這台機器不行那我就換一台更好的。<br>其實就是升級硬體，好處就是簡單直接，能用垂擴展解決那就優先考慮垂直擴展吧。但垂直擴展是有極限的，而且越好的機器越貴，這時就可以考慮水平擴展。</p>
<h1 id="水平擴展"><a href="#水平擴展" class="headerlink" title="水平擴展"></a>水平擴展</h1><p>一台機器不行那我就多用幾台。<br>要實現伺服器的水平擴展比較容易，不外乎就是多開幾台機器，然後做好 load balance，這裡重點介紹<strong>資料庫</strong>的水平擴展，大致上可以分為兩個策略：</p>
<h2 id="讀寫分離"><a href="#讀寫分離" class="headerlink" title="讀寫分離"></a>讀寫分離</h2><p>在原本的資料庫 (主節點) 外添加幾個從資料庫 (從節點) ，向主節點寫入資料，讀取時則優先自從節點讀取。讀寫分離會遇到幾個問題： </p>
<ol>
<li><strong>最終一致性問題</strong><br>  由於從節點的數據是自主節點同步過來，因此中間勢必存在一時間差，可能導致從節點的數據不是最即時的數據，因此從節點的數據僅滿足最終一致性。</li>
<li><strong>單個主節點</strong><br>  由於主節點仍然只有一個，如果遇到需要大量寫入的作業仍然會出現堵塞，這時候可能要考慮多個主節點的架構，不過就跟前一點一樣會遇到資料同步的問題，還需要考慮同時有多個寫入情況下的 race condition。</li>
</ol>
<h2 id="資料庫切分-Partitioning-x2F-Sharding"><a href="#資料庫切分-Partitioning-x2F-Sharding" class="headerlink" title="資料庫切分 (Partitioning &#x2F; Sharding)"></a>資料庫切分 (Partitioning &#x2F; Sharding)</h2><p>將一個資料庫 (大資料表) 分割為多個小資料表，並將其儲存在不同節點上，又可以分為<strong>垂直切分</strong>與<strong>水平切分</strong>：<br><img src="/../images/2024/01/17/sharding.png" alt="sharding"></p>
<h3 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h3><p>按照欄位來進行切分，通常可以按照業務功能來做切割，如電商平台中的買家資訊與賣家資訊就可以分開儲存。</p>
<h3 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h3><p>按照列來進行切分，主要有兩種切分方法：</p>
<ol>
<li><strong>按一定範圍切分</strong><br>舉例來說 ID &lt;&#x3D; 10000 為第一個表，接著每 10000 筆資料為一個表，這個做法的好處是<strong>容易新增表</strong>，壞處是<strong>較差的附載平衡</strong>，因為新資料與舊資料的活躍度可能有很大的差異。</li>
<li><strong>使用哈希表切分</strong><br>將 ID 放入一個 Hash Function 中，如 <code>10 % 3 = 1</code>，根據 Hash 結果找到對應的表，好處是有<strong>較佳的附載平衡</strong>，缺點是<strong>不容易新增表</strong>，新增一個表通常涉及到<strong>修改 Hash Function</strong> 以及原先表的<strong>數據遷移</strong>。</li>
</ol>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><p><a href="https://www.digitalocean.com/community/tutorials/understanding-database-sharding">Understanding Database Sharding</a><br><a href="https://blog.csdn.net/Dongguabai/article/details/83578092">高并发（水平扩展，垂直扩展）</a><br><a href="https://www.twblogs.net/a/5c99f60fbd9eee434fc6c4d5">數據庫的向上擴展和橫向擴展（即水平擴展：讀寫分離、垂直切分、水平切分）</a></p>
]]></content>
      <categories>
        <category>system design</category>
      </categories>
      <tags>
        <tag>scaling</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie (字典樹) - Design Add and Search Words Data Structure</title>
    <url>/posts/trie-2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>寫完上一篇<a href="/posts/trie/">Implement Trie (字典樹)</a>後，沒過兩天LeetCode每日一題又出現Trie的題目了(笑)，題目是<a href="https://leetcode.com/problems/design-add-and-search-words-data-structure/">211. Design Add and Search Words Data Structure</a>，簡單來說就是字典樹加上一點正規表達(regular expression)的概念，舉例來說trie裡有<code>bad</code>，那搜尋<code>b.d</code>的話也要回傳<code>true</code>，詳細題目一樣自己到LeetCode去看囉。</p>
<span id="more"></span>

<h1 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h1><p>如果不考慮正規表達的話，那其實就是最基本的Trie，還不了解trie的話可以參考前一篇文章！但現在多了這個特殊條件後，我們就需要去考慮所有可能，方法是寫一個dfs(Depth First Search)的輔助函式，遇到<code>.</code>的話就將當前節點下的所有子節點再帶入dfs，看最後有沒有符合的單字，只要有其中一個子節點符合的話會提前回傳<code>true</code>，都沒有的話就回傳<code>false</code>。</p>
<p>我們以下面的圖片來說明步驟，假設我們今天搜尋<code>b.t</code>：</p>
<ol>
<li>跟一般的trie一樣，我們會先確認root下有沒有b這個節點，有的話就走到這個節點上。</li>
<li>因為第二個字是<code>.</code>，表示<code>ba</code>跟<code>bo</code>都是我們可以走的路徑，因此我們兩條路都要去訪問，依字母順序我們先訪問<code>ba</code>。</li>
<li><code>ba</code>下面雖然有節點<code>bat</code>，但他不是單字的結尾，所以我們跳出這條路徑。</li>
<li>我們回到上一層，改走<code>bo</code>這條路徑。</li>
<li><code>bot</code>符合我們要找的答案，並且他也是單字的結尾，因此回傳<code>true</code>。</li>
</ol>
<p><img src="/../images/2023/03/20/trie.png" alt="trie"></p>
<h1 id="方法一-Pointers-C"><a href="#方法一-Pointers-C" class="headerlink" title="方法一: Pointers (C++)"></a>方法一: Pointers (C++)</h1><p>重點</p>
<ul>
<li>dfs除了要傳入節點<code>curr</code>，也要記錄目前走到第單字中的第幾個位置<code>start</code>。</li>
<li>遇到<code>.</code>的話就對所有可能路徑再做一次dfs。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    Node* children[<span class="number">26</span>];</span><br><span class="line">    <span class="type">bool</span> is_end = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node* root;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string word;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(Node* curr, <span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=start; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="comment">// 遇到 .</span></span><br><span class="line">            <span class="keyword">if</span> (word[i] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">// 用迴圈造訪所有可能路徑</span></span><br><span class="line">                <span class="keyword">for</span> (Node* next: curr-&gt;children)&#123;</span><br><span class="line">                    <span class="comment">// 路徑不可為空 &amp;&amp; 該路徑有符合答案者</span></span><br><span class="line">                    <span class="keyword">if</span> (next!=<span class="literal">nullptr</span> &amp;&amp; <span class="built_in">dfs</span>(next, i+<span class="number">1</span>))&#123;</span><br><span class="line">                        <span class="comment">// 提前回傳 true</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 全部路徑無答案，回傳 false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (curr-&gt;children[word[i]-<span class="string">&#x27;a&#x27;</span>] != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                curr = curr-&gt;children[word[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr-&gt;is_end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WordDictionary</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addWord</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Node* curr = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> w: word)&#123;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;children[w-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                curr-&gt;children[w-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;children[w-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        curr-&gt;is_end = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = word.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;word = word;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="方法二-Hash-Table-Python"><a href="#方法二-Hash-Table-Python" class="headerlink" title="方法二: Hash Table (Python)"></a>方法二: Hash Table (Python)</h1><p>重點</p>
<ul>
<li>注意要避開<code>#</code>因為他不是一個路徑，否則會報錯。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.root = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addWord</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        curr = self.root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> curr:</span><br><span class="line">                curr[w] = &#123;&#125;</span><br><span class="line">            curr = curr[w]</span><br><span class="line">        curr[<span class="string">&quot;#&quot;</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(word)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">curr, start</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n):</span><br><span class="line">                w = word[i]</span><br><span class="line">                <span class="comment"># 遇到 .</span></span><br><span class="line">                <span class="keyword">if</span> w == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                    <span class="comment"># 用迴圈造訪所有可能路徑</span></span><br><span class="line">                    <span class="keyword">for</span> c <span class="keyword">in</span> curr:</span><br><span class="line">                        <span class="comment"># 避開結尾標記 &amp;&amp; 該路徑有符合答案者</span></span><br><span class="line">                        <span class="keyword">if</span> c!=<span class="string">&quot;#&quot;</span> <span class="keyword">and</span> dfs(curr[c], i+<span class="number">1</span>):</span><br><span class="line">                            <span class="comment"># 提前回傳 true</span></span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    <span class="comment"># 全部路徑無答案，回傳 false</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">elif</span> w <span class="keyword">in</span> curr:</span><br><span class="line">                    curr = curr[w]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#&quot;</span> <span class="keyword">in</span> curr</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(self.root, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DSA</category>
      </categories>
      <tags>
        <tag>資料結構</tag>
        <tag>Trie</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Implement Trie (字典樹)</title>
    <url>/posts/trie/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天在寫LeetCode每日一題時遇到<a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/">208. Implement Trie (Prefix Tree)</a>，之前因為覺得Trie好像很難所以一直不願面對，但這題就是要跟Trie的直球對決了想躲也躲不掉XD，Anyway，看了一下發現Trie其實蠻好理解的，今天就來認識一下Trie，然後看看這一題可以怎麼寫吧！(Python, C++)</p>
<span id="more"></span>

<h1 id="Trie-介紹"><a href="#Trie-介紹" class="headerlink" title="Trie 介紹"></a>Trie 介紹</h1><p>Trie的中文可以叫做字典樹、字首樹或前綴樹，顧名思義是一種樹狀結構，常被用來檢索文本中的單詞或前綴(prefix)。</p>
<p>字典樹有幾個性質，這裡搭配下方圖片做介紹：</p>
<ol>
<li>每個節點代表一個字符，並且單字的結尾有標記，舉例來說單字”ten”會依序經過t、e、n三個節點，其中n是結尾(綠色)。</li>
<li>節點是可以被共用的，舉例來說”sun”及”sup”就共用了s、u兩個節點。</li>
<li>葉子節點一定是單字結尾，但非葉節點也可以是結尾，舉例來說”an”及”and”分別是兩個單字，其中n及d都是單字的結尾(綠色)。</li>
</ol>
<p><img src="/../images/2023/03/18/trie.png" alt="trie"><br>字典樹的優點是可以快速查找字符串，且可以按照字典序進行排序。但缺點是需要較大的空間來存儲，且插入和刪除操作相對較慢。</p>
<h1 id="實作-Trie"><a href="#實作-Trie" class="headerlink" title="實作 Trie"></a>實作 Trie</h1><p>實作的內容就是一開始提到的LeetCode 208，簡單來說就是要做出初始化、插入、尋找及尋找前綴4個功能，詳細題目可以自己到LeetCode去看。</p>
<p>值得一提的是，Trie 有兩種實作方法，第一個方法相當直覺，就是用指針連結各個節點來模擬出一個樹狀結構；第二個方法則是動態語言限定，我們可以直接用hash table來儲存字符，接下來分別用C++及Python來演示這兩種方法。</p>
<h2 id="方法一-Pointers-C"><a href="#方法一-Pointers-C" class="headerlink" title="方法一: Pointers (C++)"></a>方法一: Pointers (C++)</h2><p>重點</p>
<ul>
<li>英文字母只有26個，所以可以直接使用array，以index(<code>w-&#39;a&#39;</code>)來表示字符。</li>
<li>prefix的部分只要節點存在就OK，但search的部分還要檢查是不是結尾。</li>
<li>另外定義一個struct而不是直接new原本的class，是因為struct的結構比class簡單的多(沒有function)，可以提升執行效率。</li>
<li>使用靜態宣告(array)所以不用擔心memory leak。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">  Node* children[<span class="number">26</span>];</span><br><span class="line">  <span class="type">bool</span> is_word = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node* root;</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Node* curr = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> w: word) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;children[w-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                curr-&gt;children[w-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;children[w-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        curr-&gt;is_word = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Node* curr = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> w: word) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr == <span class="literal">NULL</span> || curr-&gt;children[w-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;children[w-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr-&gt;is_word;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        Node* curr = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> w: prefix) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;children[w-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;children[w-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="方法二-Hash-Table-Python"><a href="#方法二-Hash-Table-Python" class="headerlink" title="方法二: Hash Table (Python)"></a>方法二: Hash Table (Python)</h2><p>重點</p>
<ul>
<li>用特殊符號(#)來標記單字結尾。</li>
<li>因為動態語言中的資料型態是動態決定的，所以Hash Table內可以同時儲存不同資料型態(存下一層&#x2F;存結尾)。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._root = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        curr = self._root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> curr:</span><br><span class="line">                curr[w] = &#123;&#125;</span><br><span class="line">            curr = curr[w]</span><br><span class="line">        curr[<span class="string">&quot;#&quot;</span>] = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        curr = self._root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">in</span> curr:</span><br><span class="line">                curr = curr[w]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> curr.get(<span class="string">&quot;#&quot;</span>, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">startsWith</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        curr = self._root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">in</span> curr:</span><br><span class="line">                curr = curr[w]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h1 id="相關文章"><a href="#相關文章" class="headerlink" title="相關文章"></a>相關文章</h1><p><a href="/posts/trie-2/">Trie (字典樹) - Design Add and Search Words Data Structure</a></p>
<h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>Trie的基本觀念說實在還蠻簡單的，難應該是難在之後的應用，之後有機會看能不能更新一些進階的觀念，像是搜尋引擎之類的。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.youtube.com/watch?v=f48wGD-MuQw">https://www.youtube.com/watch?v=f48wGD-MuQw</a></p>
]]></content>
      <categories>
        <category>DSA</category>
      </categories>
      <tags>
        <tag>資料結構</tag>
        <tag>Trie</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Spectral Clustering - 算法解析與numpy程式實作</title>
    <url>/posts/spectral-clustering/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="/../images/2023/04/27/cluster_analysis.jpg" alt="Spectral Clustering"></p>
<p>在社群網絡中分析中，有時候會想要找出網絡當中的社群(community detection)，一個最直觀的想法是直接對網絡進行分群，那麼分群結果就是各個community了。<br>如果我們能夠計算各個節點之間的相似性，那麼我們當然可以直接套用傳統的分群方法，如cosine similiarity，但一來是相似度特徵可能很難取得，二來是這樣分群的話就沒有利用到網絡的結構了，這時我們可以改為使用基於圖論的分群方法。<br>今天這篇文章會帶大家簡單瞭解什麼是cut approach, balanced-cut approach以及其代表方法spectral clustering，並示範不依賴其他套件，僅使用numpy實作spectral clustering。</p>
<span id="more"></span>

<h1 id="大綱"><a href="#大綱" class="headerlink" title="大綱"></a>大綱</h1><ul>
<li><a href="#Mini-cut-Approach">Mini-cut approach</a></li>
<li><a href="#Balanced-cut-Approach">Balanced-cut approach</a></li>
<li><a href="#Spectral-Clustering">Spectral clustering</a></li>
</ul>
<h1 id="內文"><a href="#內文" class="headerlink" title="內文"></a>內文</h1><h2 id="Mini-cut-Approach"><a href="#Mini-cut-Approach" class="headerlink" title="Mini-cut Approach"></a>Mini-cut Approach</h2><p>Cut approach，顧名思義是將網絡給切開來形成多個網絡，屬於partitional clustering的一種，每個節點只會屬於一個community，並且community之間也不會overlapping，而Mini-cut Approach則是希望在切割網絡時能最小化切掉的edge數量。<br>聽起來很直觀，但這樣切會有一個問題，那就是有可能會切出一些非常小的community，導致分群不夠balance。</p>
<h2 id="Balanced-cut-Approach"><a href="#Balanced-cut-Approach" class="headerlink" title="Balanced-cut Approach"></a>Balanced-cut Approach</h2><p>為了解決Mini-cut Approach的缺點，Balanced-cut Approach在切割網絡時除了考量原本的edge，另外除以community的node數做加權調整，切割的目標從最小化edge數轉為最小化ratio cut，公式如下:<br><img src="/../images/2023/04/27/ratio_cut.png" alt="Ratio Cut formula"></p>
<p>公式解釋: 分成k群(k要自己決定)，每次取一個群<code>Pi</code>出來看，分子部分表示將<code>Pi</code>切開的話會切到的edge數，分母部分表示<code>Pi</code>內部的node數，將k個群的結果加總起來就會是整個網路的ratio cut分數。</p>
<h3 id="Matrixs"><a href="#Matrixs" class="headerlink" title="Matrixs"></a>Matrixs</h3><p>為了要計算Ratio Cut，我們先要來認識一下三種矩陣:</p>
<ol>
<li><p>Diagonal Degree Matrix 度數矩陣<br>Degree(度數)指的是一個node有多少個鄰居，將這些Degree轉換為對角矩陣(Diagonal Matrix)就得到Diagonal Degree Matrix。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D = np.array([</span><br><span class="line">  [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>
</li>
<li><p>Adjacency Matrix 鄰接矩陣<br>只要是對Graph有些概念的人應該都對Adjacency Matrix不太陌生，Adjacency Matrix描述了node之間的關係，下面例子假設node之間的關係都是雙向的，所以會是個對稱矩陣。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = np.array([</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br></pre></td></tr></table></figure>
</li>
<li><p>Laplacian Matrix 調和矩陣(拉普拉斯矩陣)<br>Laplacian Matrix 的算法就是直接將Diagonal Degree Matrix 減去 Adjacency Matrix，聽起來可能讓人滿頭問號，為什麼要這麼做? 這邊先賣個關子，繼續看下去就知道了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = np.array([</span><br><span class="line">  [ <span class="number">2</span>, -<span class="number">1</span>,  <span class="number">0</span>,  <span class="number">0</span>, -<span class="number">1</span>,  <span class="number">0</span>,  <span class="number">0</span>],</span><br><span class="line">  [-<span class="number">1</span>,  <span class="number">4</span>, -<span class="number">1</span>, -<span class="number">1</span>,  <span class="number">0</span>,  <span class="number">0</span>, -<span class="number">1</span>],</span><br><span class="line">  [ <span class="number">0</span>, -<span class="number">1</span>,  <span class="number">2</span>, -<span class="number">1</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>],</span><br><span class="line">  [ <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>,  <span class="number">3</span>,  <span class="number">0</span>, -<span class="number">1</span>,  <span class="number">0</span>],</span><br><span class="line">  [-<span class="number">1</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">2</span>, -<span class="number">1</span>,  <span class="number">0</span>],</span><br><span class="line">  [ <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>,  <span class="number">3</span>, -<span class="number">1</span>],</span><br><span class="line">  [ <span class="number">0</span>, -<span class="number">1</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>, -<span class="number">1</span>,  <span class="number">2</span>]])</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Calculation"><a href="#Calculation" class="headerlink" title="Calculation"></a>Calculation</h3><p>現在先假設我們已經知道分群的結果了，並將結果以0,1的形式表示為一個matrix，令這個結果為X，下面結果是我隨便分的，分3群，<code>X[i][j]==1</code>表示node<code>i</code>屬於cluster<code>j</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = np.array([</span><br><span class="line">  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br></pre></td></tr></table></figure>
<ol>
<li><p>Diagonal Degree Matrix 解釋<br>我們先將X的轉置矩陣與D做內積(<code>X.T.dot(D)</code>):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br></pre></td></tr></table></figure>
<p>觀察一下結果會發現，這個矩陣就只是是把Degree填到對應的cluster中而已。<br>接著我們再把上面結果與X做內積(<code>X.T.dot(D).dot(X)</code>):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>]])</span><br></pre></td></tr></table></figure>
<p>這個結果其實就表示<strong>每個cluster的degree總和</strong>。</p>
</li>
<li><p>Adjacency Matrix 解釋<br>接著我們直接將上面公式的D換成A(<code>X.T.dot(A).dot(X)</code>):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>
<p>會發現結果表示在<strong>cluster與cluster間互相連接的edge數</strong>。</p>
</li>
<li><p>Laplacian Matrix 解釋<br>如果我們將兩個結果相減的話，會發現每一行的第i個元素(對角)就是我們想要計算的cut數(分子部分)!!!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[ <span class="number">4</span>, -<span class="number">2</span>, -<span class="number">2</span>],  <span class="comment"># i=0, 4</span></span><br><span class="line">       [-<span class="number">2</span>,  <span class="number">3</span>, -<span class="number">1</span>],  <span class="comment"># i=1, 3</span></span><br><span class="line">       [-<span class="number">2</span>, -<span class="number">1</span>,  <span class="number">3</span>]]) <span class="comment"># i=2, 3</span></span><br></pre></td></tr></table></figure>
<p>接著我們另外計算每個cluster裡面共有多少個node，我們可以將X的轉置後與自己相乘(<code>X.T.dot(X)</code>):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>
<p>最後將對角的結果相除後加起來就是算平均就得到Ratio Cut的分數啦~~~<br>(我這邊直接矩陣相除，大家可以自己算。)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[ <span class="number">2.</span> , -inf, -inf],</span><br><span class="line">       [-inf,  <span class="number">1.</span> , -inf],</span><br><span class="line">       [-inf, -inf,  <span class="number">1.5</span>]])</span><br></pre></td></tr></table></figure></li>
</ol>
<p>根據上面矩陣運算的過程，我們能將公式重新整理為:<br><img src="/../images/2023/04/27/ratio_cut_2.png" alt="ratio cut formula extended"></p>
<p>在第三行的部分，我們另外對X進行標準化(同除以分母)變成了<code>X prime</code>。</p>
<h3 id="Minimize"><a href="#Minimize" class="headerlink" title="Minimize"></a>Minimize</h3><p>回到最一開始的問題，我們的目標是要最小化ratio cut的分數，方法就是透過上面的公式去求解<code>X prime</code>矩陣，難過的是，還記的X矩陣裡最一開始只能填入0跟1嗎，想要在這樣嚴格的限制下求出最佳解是個<strong>NP-hard</strong>的問題。<br>不過不要灰心，我們還是可以放寬條件，套用近似演算法，其中一種方法就是接下來要介紹的Spectral Clustering~~~</p>
<h2 id="Spectral-Clustering"><a href="#Spectral-Clustering" class="headerlink" title="Spectral Clustering"></a>Spectral Clustering</h2><p>Spectral Clustering 基於ratio cut，不過X矩陣中可以填入的值變成介於0~1之間，在放寬條件後，這個最小化問題的解可以被證明是求解Laplacian Matrix的前k小個特徵值的特徵向量。</p>
<ol>
<li><p>Eigenvalue &amp; Eigenvactors<br>我們可以用<code>np.linalg.eig</code>來替我們計算特徵值與特徵向量，並使用<code>np.argsort</code>來替我們找出最小的k個特徵向量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># calculate eigenvalue and eigenvector</span></span><br><span class="line">eig_value, eig_vector = np.linalg.eig(L)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get eigenvector with smallest eigenvalue</span></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">top_k = np.argsort(eig_value)[:k]</span><br><span class="line">top_k_vector = eig_vector[:, top_k]</span><br></pre></td></tr></table></figure>
<p>得到的結果如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[ <span class="number">0.37796447</span>, -<span class="number">0.45244521</span>, -<span class="number">0.41243936</span>],</span><br><span class="line">       [ <span class="number">0.37796447</span>,  <span class="number">0.17351892</span>, -<span class="number">0.08541899</span>],</span><br><span class="line">       [ <span class="number">0.37796447</span>,  <span class="number">0.54280925</span>, -<span class="number">0.41243936</span>],</span><br><span class="line">       [ <span class="number">0.37796447</span>,  <span class="number">0.32598548</span>, -<span class="number">0.08541899</span>],</span><br><span class="line">       [ <span class="number">0.37796447</span>, -<span class="number">0.58986844</span>, -<span class="number">0.08541899</span>],</span><br><span class="line">       [ <span class="number">0.37796447</span>, -<span class="number">0.09036404</span>,  <span class="number">0.37705765</span>],</span><br><span class="line">       [ <span class="number">0.37796447</span>,  <span class="number">0.09036404</span>,  <span class="number">0.70407803</span>]])</span><br></pre></td></tr></table></figure>
</li>
<li><p>K-means<br>由於得到的特徵值並無法直接拿來做解釋，因此Spectral Clustering另外使用了K-means來為這些特徵值做分群，因為最小的特徵值為0、特徵向量一定是常數，所以我們可以把它刪去，也就是說，如果我們想要分成k群，那我們至少需要使用k-1個特徵向量。<br>下面程式提供一個簡單的K-means範例，可以根據自己的需求另外設置停止條件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">k_means</span>(<span class="params">X, k, max_iters=<span class="number">10000</span></span>):</span><br><span class="line">    <span class="comment"># randomly initialize centroids</span></span><br><span class="line">    centroids = X[np.random.choice(<span class="built_in">len</span>(X), k, replace=<span class="literal">False</span>)]</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(max_iters):</span><br><span class="line">       <span class="comment"># calculate distances</span></span><br><span class="line">       distances = np.linalg.norm(X[:, np.newaxis] - centroids, axis=<span class="number">2</span>)</span><br><span class="line">       <span class="comment"># assign labels </span></span><br><span class="line">       labels = np.argmin(distances, axis=<span class="number">1</span>)</span><br><span class="line">       <span class="comment"># calculate new centroids</span></span><br><span class="line">       centroids = np.array([np.mean(X[labels == i], axis=<span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)])</span><br><span class="line">    <span class="keyword">return</span> labels</span><br><span class="line"></span><br><span class="line"><span class="comment"># remove first vector</span></span><br><span class="line">features = top_k_vector[:, <span class="number">1</span>:]</span><br><span class="line"><span class="comment"># do k-maens</span></span><br><span class="line">labels = k_means(features, k)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>這樣就得到分群結果啦~~~(注意: 實際執行數字的順序可能不一樣)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>], dtype=int64)</span><br></pre></td></tr></table></figure>

<h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>其實忽略到複雜的數學證明的話，Spectral Clustering的概念還挺直觀的，文章參考了台大資管系的陳建錦教授所使用的上課講義，經過本人吸收轉化撰寫而成。</p>
]]></content>
      <categories>
        <category>Social Network Analysis</category>
      </categories>
      <tags>
        <tag>Graph</tag>
        <tag>Spectral Clustering</tag>
      </tags>
  </entry>
</search>
