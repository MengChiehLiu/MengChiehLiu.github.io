<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello Hexo！用 Hexo 在 GitHub Pages 上架設個人部落格吧！(1)</title>
    <url>/posts/Hello-Hexo-1/</url>
    <content><![CDATA[<h1 id="Hexo-介紹"><a href="#Hexo-介紹" class="headerlink" title="Hexo 介紹"></a>Hexo 介紹</h1><p>Hexo 是一個基於 Node.js 的自動化部落格部署框架，有近 400 種網頁主題可供選擇，支援 Markdown 語言撰寫文章內容而且部署相當迅速，簡直是自己架設部落格的必備神器呀！什麼？你說之前沒用過 Node.js 怎麼辦？沒關係，因為我之前也沒用過 XD。事實上，只要掌握幾個基本的指令，就能夠架出漂漂亮亮、功能齊全的個人部落格囉！就讓我們一起看下去吧～<br>Hexo 官網：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a><br>Hexo GitHub：<a href="https://github.com/hexojs/hexo">https://github.com/hexojs/hexo</a></p>
<span id="more"></span>

<h1 id="前置作業"><a href="#前置作業" class="headerlink" title="前置作業"></a>前置作業</h1><ul>
<li><p>安裝 Node.js<br>官方載點：<a href="https://nodejs.org/zh-tw/download/">https://nodejs.org/zh-tw/download/</a></p>
<blockquote>
<p>進入網站後選擇 LTS 版本，然後選擇下載安裝程式，我自己是用 Windows 作業系統，直接點擊 Windows icon 就開始下載了，下載好後打開安裝程式一路確認到最後就安裝好啦～安裝完成後可以用 <code>npm --version</code> 來確認是否安裝成功。<br><img src="/../images/2023/03/14/nodejs.png" alt="Node.js"></p>
</blockquote>
</li>
<li><p>安裝 git<br>官方載點：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p>
<blockquote>
<p>選擇對應的作業系統直接下載就好～這裡一樣以 Windows 為例，選擇的是 Standalone Installer 下的 64-bit Git for Windows Setup，下載好後打開安裝程式一路確認到最後就安裝好啦～安裝完成後可以用 <code>git --version</code> 來確認是否安裝成功。<br><img src="/../images/2023/03/14/git.png" alt="git"></p>
</blockquote>
</li>
<li><p>註冊 GitHub 帳號<br>官網連結：<a href="https://github.com/">https://github.com/</a></p>
</li>
</ul>
<h1 id="安裝-Hexo"><a href="#安裝-Hexo" class="headerlink" title="安裝 Hexo"></a>安裝 Hexo</h1><ul>
<li><p>安裝 Hexo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化資料夾，並將當前路徑移動到該資料夾下 (blog 是資料夾名稱，可以改成自己喜歡的名字)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br></pre></td></tr></table></figure>
</li>
<li><p>下載 Hexo 所需套件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></li>
</ul>
<p>做完上面這些步驟後，我們就可以啟動伺服器來看看目前部落格的樣子囉。</p>
<ul>
<li>啟動伺服器<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server #or</span><br><span class="line">hexo s      </span><br></pre></td></tr></table></figure>
<blockquote>
<p>預設主題是 landscape，也可以使用其他主題，下一篇文章會教大家如何套用 Hexo 上的熱門主題 nexT！<br><img src="/../images/2023/03/14/landscape.png" alt="landscape"></p>
</blockquote>
</li>
</ul>
<h1 id="Hexo-架構"><a href="#Hexo-架構" class="headerlink" title="Hexo 架構"></a>Hexo 架構</h1><p>在開始加工我們的網站之前，先來認識一下 Hexo 的資料夾架構！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">|   ├── draft</span><br><span class="line">|   ├── page</span><br><span class="line">|   └── post</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">├── themes</span><br><span class="line">|   └── yourTheme</span><br><span class="line">|       └── _config.yml</span><br><span class="line">└── _config.yml</span><br></pre></td></tr></table></figure>

<ul>
<li>package.json<br>用來存放 node.js 的各種套件，一班情況下不太需要動到這個資料夾。</li>
<li>scaffolds<br>鷹架資料夾，裡面有三個檔案 draft、page 與 post，分別對應了我們能建立的三種佈局，Hexo 會依據這些佈局來生成新的頁面。</li>
<li>source<br>來源資料夾，用來存放文章、頁面以及圖片等內容，其中_drafts 用來存放草稿，_posts 用來存放已經發布的文章。</li>
<li>themes<br>主題資料夾，可以下載自己喜歡的主題放到裡面，在每個主題底下會有一個與主題設定檔，與主題有關的東西都在那裡進行設定。</li>
<li>_config.yml<br>網頁設定檔，與網頁有關的東西都在這裡進行設定。 (跟主題設定檔不一樣！)</li>
</ul>
<h1 id="Config-設置"><a href="#Config-設置" class="headerlink" title="Config 設置"></a>Config 設置</h1><p>進到_config.yml 檔案中，對 Site 部分進行修改，可以參考下面的設置：</p>
<blockquote>
<p>subtitle 跟 description 可寫可不寫<br>language 預設是英文，可以改成 zh-TW 顯示繁體中文<br>keyword 跟 Google 關鍵字搜尋有關，這裡先忽略不管他，未來有機會再來詳細介紹！<br><img src="/../images/2023/03/14/config_site.png" alt="config_site"></p>
</blockquote>
<h1 id="撰寫文章-x2F-新增頁面"><a href="#撰寫文章-x2F-新增頁面" class="headerlink" title="撰寫文章 &#x2F; 新增頁面"></a>撰寫文章 &#x2F; 新增頁面</h1><p>在 Hexo 當中共有三種佈局，分別是 draft、post 與 page，其中 draft 跟 page 屬於文章，page 則屬於頁面。</p>
<ul>
<li><p>post<br>所有 draft 都會被存放在_posts 資料夾當中，會出現在網頁上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># post 可以省略 </span><br><span class="line">hexo new post &quot;My Post&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>draft<br>draft 是草稿，會另外從放於_drafts 資料夾下，且不會出現在網頁上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new draft &quot;My Draft&quot;</span><br></pre></td></tr></table></figure>
<p>可以用指令將 draft 轉成 post，原理只是換個資料夾而已，其實也可以手動作，反過來手動把 post 丟到 draft 也行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo publish &quot;My Draft&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>page<br>page 是功能頁面，常見的有 about、tags、categories 等，下一篇文章就會介紹如何在 nexT 主題下建立對應的 page！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;My Page&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="生成靜態文件"><a href="#生成靜態文件" class="headerlink" title="生成靜態文件"></a>生成靜態文件</h1><p>每次修改 config 檔或是寫完文章後，記得不要忘記重新生成一次網頁的靜態文件，不然剛剛做的變動網頁上是不會呈現出來的喔！</p>
<ul>
<li><p>清空原本的靜態文件 &#x2F; 暫存<br>這個步驟相當重要！否則容易出現新加的東西更新不上去的情況。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clear #or</span><br><span class="line">hexo cl</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成靜態文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate #or</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure>
</li>
<li><p>做完記得打開 server 確認一下結果！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server #or</span><br><span class="line">hexo s </span><br></pre></td></tr></table></figure></li>
</ul>
<p>這三個指令<br>非常重要！！！<br>非常重要！！！<br>非常重要！！！<br>簡單來說有動到東西請執行一下就對了！</p>
<h1 id="部署至-GitHub-Pages"><a href="#部署至-GitHub-Pages" class="headerlink" title="部署至 GitHub Pages"></a>部署至 GitHub Pages</h1><ol>
<li><p>在 GitHub 中創建一個新的 repository (點右上角加號)<br><img src="/../images/2023/03/14/repository.png" alt="repository"></p>
</li>
<li><p>repository 名稱取為 <code>user_name.github.io</code>，然後直接 create repository<br><img src="/../images/2023/03/14/repository_create.png" alt="repository_create"></p>
</li>
<li><p>修改網頁_config.yml 中的 URL 設置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url: https://user_name.github.io/</span><br><span class="line">root: /</span><br></pre></td></tr></table></figure>
<blockquote>
<p>這裡的 url 是 GitHub Pages 的網址<br>root 設成 &#x2F;<br><img src="/../images/2023/03/14/config_url.png" alt="config_url"></p>
</blockquote>
</li>
<li><p>修改網頁_config.yml 中的 deploy 設置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/user_name/user_name.github.io.git</span><br></pre></td></tr></table></figure>
<blockquote>
<p>這裡選擇用 HTTPS 的方式連結，部署時直接輸入帳號密碼就行，也可以用 SSH，不過就要設置金鑰，比較麻煩一些<br><img src="/../images/2023/03/14/config_deploy.png" alt="config_deploy"></p>
</blockquote>
</li>
<li><p>修改完後記得重新生成一次靜態文件</p>
</li>
<li><p>開始部署</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo deploy #or</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
</li>
<li><p>打開 GitHub Pages 的網址就能看到我們剛剛部署上去的網頁啦！<br><img src="/../images/2023/03/14/gitpage.png" alt="Alt text"></p>
</li>
</ol>
<h1 id="預告"><a href="#預告" class="headerlink" title="預告"></a>預告</h1><p>下一篇文章我將會介紹如何套用 nexT 主題，除了講解外觀設定以外，也將帶著大家打造標籤頁及站內搜尋等功能！</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Hexo！套用 NexT 主題打造簡潔頁面！(2)</title>
    <url>/posts/Hello-Hexo-2/</url>
    <content><![CDATA[<h1 id="NexT-介紹"><a href="#NexT-介紹" class="headerlink" title="NexT 介紹"></a>NexT 介紹</h1><p>NexT 是一個相當受歡迎的 Hexo 主題，外觀簡潔、功能強大，且持續有在維護，今天會教大家如何套用 NexT 主題，並啟用標籤頁及站內搜尋等功能。<br>NexT 官網：<a href="https://theme-next.js.org/">https://theme-next.js.org/</a><br>NexT GitHub：<a href="https://github.com/next-theme/hexo-theme-next">https://github.com/next-theme/hexo-theme-next</a></p>
<span id="more"></span>

<h1 id="安裝-NexT"><a href="#安裝-NexT" class="headerlink" title="安裝 NexT"></a>安裝 NexT</h1><p>有兩個方法，第一個方法是透過 npm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-theme-next</span><br></pre></td></tr></table></figure>
<p>第二個方法是透過 git</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/next-theme/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p>我個人是喜歡第二種方法 (git)，因為資源為自動進到 themes 資料夾當中，如果使用第二種方法 (npm) 的話資源會跑到 node_modules 資料夾中，雖然在功能上不會有差異，但未來要對主題的 config 檔做調整時要找比較久。</p>
<h1 id="套用主題"><a href="#套用主題" class="headerlink" title="套用主題"></a>套用主題</h1><p>到 ** 網頁 ** 的 config 檔 (<code>/_config.yml</code>)，搜尋 <strong>theme</strong> 將主題設置成 next 就行了。<br><img src="/../images/2023/03/15/config_theme.png" alt="config_theme"></p>
<p>另外 Next 其實有提供 4 種版面可以做選擇，分別是：💟 <a href="https://theme-next.js.org/muse/">Muse</a> | 🔯 <a href="https://theme-next.js.org/mist/">Mist</a> | ♓️ <a href="https://theme-next.js.org/pisces/">Pisces</a> | ♊️ <a href="https://theme-next.js.org/">Gemini</a></p>
<p>大家可以點擊連結看看自己喜歡哪種版面，預設是使用 Muse，如果要做更改的話，到 ** 主題 ** 的 config 檔 (<code>themes/next/_config.yml</code>) 中搜尋 <strong>Schemes</strong>，將喜歡的佈局取消註解就可以了，另外下面的 <strong>darkmode</strong> 改成 true 的話則是可以讓網頁變成黑色模式。<br><img src="/../images/2023/03/15/next_schemes.png" alt="next_schemes"></p>
<p>NexT 也支援 canvas 背景動畫，我們可以在 ** 主題 **config 檔搜尋 <strong>canvas_ribbon</strong>，將下方的 enable 改為 true，部屬後網頁背景就會出現酷炫的彩色絲帶動畫了～</p>
<h1 id="添加頭像-avatar"><a href="#添加頭像-avatar" class="headerlink" title="添加頭像 avatar"></a>添加頭像 avatar</h1><ol>
<li>把準備好的圖片放入 <code>themes/next/source/images</code> 或 <code>source/images</code> 當中。</li>
<li>在 ** 主題 **config 檔搜尋 <strong>avatar</strong>，修改成自己準備的圖片路徑或者修改圖片名稱使其一致。<blockquote>
<p>rounded 改成 true 的話頭像會是圓形，rotated 改成 true 的話滑鼠移到頭像上時會有快速旋轉的動畫。<br><img src="/../images/2023/03/15/next_avatar.png" alt="next_avatar"></p>
</blockquote>
</li>
</ol>
<h1 id="更改網站圖示-favicon"><a href="#更改網站圖示-favicon" class="headerlink" title="更改網站圖示 favicon"></a>更改網站圖示 favicon</h1><p>我們可以把網站圖示換成自己的圖片，官方文件中建議可以使用 <a href="https://realfavicongenerator.net/">Favicon Generator</a> 來生成客製化的網站圖示。</p>
<ol>
<li>把準備好的圖片放入 <code>themes/next/source/images</code> 或 <code>source/images</code> 當中。</li>
<li>在 ** 主題 **config 檔搜尋 <strong>favicon</strong>，修改成自己準備的圖片路徑或者修改圖片名稱使其一致。<br><img src="/../images/2023/03/15/next_favicon.png" alt="next_favicon"></li>
</ol>
<h1 id="社群媒體連結-social-link"><a href="#社群媒體連結-social-link" class="headerlink" title="社群媒體連結 social link"></a>社群媒體連結 social link</h1><p>在 ** 主題 **config 檔搜尋 <strong>social</strong>，將自己的社群媒體連結填入並取消註解就可以了，下方的 social_icon 則可以設定是否顯示 icon 及 icon 外觀。<br><img src="/../images/2023/03/15/next_social.png" alt="next_social"></p>
<p>Hexo NexT 使用 <a href="https://fontawesome.com/icons">Font Awesome</a> 提供的 icons，因此我們可以為新的連結挑選適合的 icon，接下來我們來新增一個 Linkedin 連結看看 (包含 icon)。</p>
<ol>
<li>先到 Font Awesome 上搜尋 Linkedin，選擇自己喜歡的 icon，複製綠色的那段文字。<br><img src="/../images/2023/03/15/font_awesome_linkedin.png" alt="font_awesome_linkedin"></li>
<li>依 <code>標題：連結 || 綠色文字</code> 的格式在 social 下加入新的一行，舉例來說。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linkedin: https://www.linkedin.com/in/meng-chieh-liu-615952235/ || fa-brands fa-linkedin</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="啟用功能選單-Menu"><a href="#啟用功能選單-Menu" class="headerlink" title="啟用功能選單 Menu"></a>啟用功能選單 Menu</h1><p>在 ** 主題 **config 檔搜尋 <strong>menu</strong>，可以看到 NexT 預先幫我們建立好許多功能選單，其中 home 跟 archives 是預設就開啟的，我們可以取消註解來啟用其他功能選單，但目前那些頁面還是空的喔！所以我們的下一步就是要建立相應的分頁。<br><img src="/../images/2023/03/15/next_menu.png" alt="next_menu"></p>
<p>這邊介紹如何建立 tags&#x2F;categories 頁面：</p>
<ol>
<li><p>建立新頁面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;tags&quot;</span><br><span class="line">hexo new page &quot;categories&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>找到 <code>source/tags/index.md</code> 檔案，在檔案中加入 <code>type:&quot;tags&quot;</code>，注意這裡的 tags 要加 ** 雙引號 **！！！<br>(categories 比照辦理)<br><img src="/../images/2023/03/15/tags.png" alt="tags"></p>
</li>
<li><p>在 post 裡面加入 tags&#x2F;categories，重新部署後這些 tags&#x2F;categories 就會出現對應的頁面上啦～<br><img src="/../images/2023/03/15/post_tags.png" alt="post_tags"></p>
</li>
</ol>
<h1 id="站內搜尋功能-local-search"><a href="#站內搜尋功能-local-search" class="headerlink" title="站內搜尋功能 local search"></a>站內搜尋功能 local search</h1><ol>
<li><p>安裝 <code>hexo-generator-searchdb</code> 套件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 ** 主題 **config 檔搜尋 <strong>local_search</strong>，將 enable 調為 true。<br><img src="/../images/2023/03/15/next_local_search.png" alt="next_local_search"></p>
</li>
<li><p>在 ** 網頁 **config 檔加入下面設置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新部署後就能開始使用站內搜尋啦～<br><img src="/../images/2023/03/15/local_search.png" alt="local_search"></p>
</li>
</ol>
<h1 id="預告"><a href="#預告" class="headerlink" title="預告"></a>預告</h1><p>下一篇文章將會帶大家做 SEO，設定 keywords 與 sitemap 讓 Google 搜的到我們的部落格 &#x2F; 文章。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Hexo！簡單三步驟搞定 Google SEO 和 Bing SEO！(3)</title>
    <url>/posts/Hello-Hexo-3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="/../images/2023/04/11/google_bing.png" alt="google and bing logo"></p>
<p>好不容易架設好 Hexo 網站，下一個問題就是如何讓自己寫的文章被其他人看見，大家可以在 Google 搜尋中輸入 <code>site: 你的網站 url</code>，看看 Google 能不能找到你的網站，沒意外的話 Google 應該還找不到你的網站，換做是 Bing 也一樣，原因是這些搜尋引擎還不認識我們的網站，本篇文章會帶大家使用 Google Search Console 以及 Bing Webmaster 來進行 SEO。<br>(ps. 網路上已經有很多文章介紹 Hexo 的 Google SEO，但在 Bing 與 ChatGPT 合作後，搜尋量有了明顯的提升，因此這篇文章除了介紹 Google SEO 外，也會介紹 Bing SEO)</p>
<span id="more"></span>

<h1 id="Sitemap"><a href="#Sitemap" class="headerlink" title="Sitemap"></a>Sitemap</h1><p>Sitemap 就是網站的地圖，搜尋引擎會透過 Sitemap 來認識我們的網站架構，我們可以透過下面指令安裝 hexo 的 sitemap 套件，之後 hexo 每次 generate 都會自動替我們生成 sitemap。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap</span><br></pre></td></tr></table></figure>

<h1 id="Google-SEO"><a href="#Google-SEO" class="headerlink" title="Google SEO"></a>Google SEO</h1><p>我們要在 <a href="https://search.google.com/search-console/about">Google Search Console</a> 來設定 Google 的 SEO，</p>
<h2 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h2><p>我們首先要驗證我們的網頁，選擇 ** 網站前置字元 **，將你的網站 url 複製上去 (舉例:<code>https://MengChiehLiu.github.io/</code>)。<br><img src="/../images/2023/04/11/google_search_console.png" alt="google search console - resource type"></p>
<h2 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h2><p>我們使用建議的驗證方式，將 html 檔案下載下來，放到 <code>/source</code> 路徑下，我們要將檔案內容改成下面這樣:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 加上這段 --&gt;</span></span><br><span class="line">---</span><br><span class="line">layout: false</span><br><span class="line">---</span><br><span class="line"><span class="comment">&lt;!-- 原本的 --&gt;</span></span><br><span class="line">google-site-verification: googled0a70fa73d09cd65.html</span><br></pre></td></tr></table></figure>
<p>重新部署網頁後 (這很重要！) 就可以回到 Google Search Console 按下驗證。<br><img src="/../images/2023/04/11/google_search_console_2.png" alt="google search console - html verification"></p>
<h2 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h2><p>我們到 Sitemap 頁面中將加入 <code>sitemap.xml</code>，這樣 Google 搜尋引擎就會定期到我們的 sitemap 去看我們的部落格有沒有更新了。<br><img src="/../images/2023/04/11/google_search_console_3.png" alt="google search console - sitemap"></p>
<h1 id="Bing-SEO"><a href="#Bing-SEO" class="headerlink" title="Bing SEO"></a>Bing SEO</h1><p>我們要在 <a href="https://www.bing.com/webmasters/about">Bing Webmaster</a> 來設定 Bing 的 SEO，Bing 的 SEO 超級簡單，登入後直接從 Google Search Console 匯入網站資訊就好。<br><img src="/../images/2023/04/11/bing_webmaster.png" alt="bing webmaster"></p>
<h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>做完這些設定後，Google 和 Bing 會需要一些時間把我們的網站納入搜尋引擎當中，這個過程可能會需要 1~2 天。<br>上面這些設定只是讓搜尋引擎找的到我們的網站，屬於最基本的 SEO，其他如關鍵字以、網址長度也會影響到網站排名，但最重要的還是文章的品質，所以努力寫出好文章也是 SEO 的關鍵喔。</p>
<blockquote>
<p>關鍵字設定<br>可以直接將 <code>scaffolds/post.md</code> 改成下面格式，之後 new post 的時候會自動套用下面格式。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">    -</span><br><span class="line">    -</span><br><span class="line">categories: </span><br><span class="line">keywords:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>使用時注意關鍵字與關鍵字之間用逗號分開不留空格！例如:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">keywords: Hexo,SEO,Google,Bing,Google Search Console,Bing Webmaster</span><br></pre></td></tr></table></figure>


<blockquote>
<p>網址長度<br>hexo 預設使用 <code>年 / 月 / 日 / 檔案名稱</code> 來當作文章 url，我們可以修改 <code>/_config.yml</code> 中的 <code>permalink</code> 來讓 url 更加精簡，詳細規則可以參考 <a href="https://hexo.io/zh-tw/docs/permalinks.html">hexo 官方文檔</a>，我自己是改成下面這樣:</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span> <span class="comment"># default</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:title/</span> <span class="comment"># shorter version</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Hexo！功能全部開起來看起來就很厲害了吧？NexT 常見設定整理 (4)</title>
    <url>/posts/Hello-Hexo-4/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="/../images/2023/04/14/cover.png" alt="cover image"></p>
<p>Next 之所以受到歡迎，一大原因是因為 NexT 將很多常用的功能都整合進入主題當中，只要修改一下主題設定檔 (config)、下載一下插件 (plugins)，就能實現大部分的功能，今天就帶大家看一些常見的功能在 NexT 主題下要如何實現。</p>
<span id="more"></span>
<h1 id="大綱"><a href="#大綱" class="headerlink" title="大綱"></a>大綱</h1><ul>
<li>[留言板](# 留言板)</li>
<li>[版權聲明](# 版權聲明)</li>
<li>[閱讀進度](# 閱讀進度)</li>
<li>[回到頂部](# 回到頂部)</li>
<li>[訪客統計、文章閱讀次數](# 訪客統計、文章閱讀統計)</li>
<li>[文章字數、閱讀時間](# 文章字數、閱讀時間)</li>
</ul>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><h2 id="留言板"><a href="#留言板" class="headerlink" title="留言板"></a>留言板</h2><p>留言板是一個很奇妙的東西，雖然心裡想到底有誰會來留言，但沒有的話又好像少了些什麼，所以姑且還是放一下 XD。<br>NexT 支援多種留言版插件，網路上推薦使用的是 disqus 或 utterances (gitalk 因為權限要求過高所以沒什麼推薦了)，二選一的情況下，disqus 要另外去註冊一個帳號有點麻煩，反觀 utterances 可以直接連結 github repository 來儲存評論，且外觀比較簡潔，所以最後決定使用 utterances。</p>
<ol>
<li><p>到 <a href="https://github.com/apps/utterances" title="{rel=&#39;nofollow&#39;}">utterances app</a> 把 app 安裝到 github 上，將權限開給指定的專案 repository。(我是直接跟部落格使用同一個，當然你也可以另外開一個新的 repository。)</p>
</li>
<li><p>找到 <code>next/_config.yml</code> 中的 <code>utterances</code>，將 <code>enable</code> 改成 <code>true</code>，在 <code>repo</code> 填入剛剛開啟權限的 repository 名稱，舉例來說我是填 <code>MengChiehLiu/MengChiehLiu.github.io</code>，<code>theme</code> 參數可以設定不同留言板風格，大家可以自己試試看。</p>
</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">utterances:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">MengChiehLiu/MengChiehLiu.github.io</span></span><br><span class="line">  <span class="attr">issue_term:</span> <span class="string">pathname</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">github-light</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>最後如果你希望留言板只出現在文章頁面，而不要出現在其他 page (ex: 標籤頁、分類頁) 的話，那要到 page 下的 <code>index.md</code> 下修改標頭檔。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: </span><br><span class="line">date: </span><br><span class="line">type: </span><br><span class="line">&lt;!-- 加入下面這一行 --&gt;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="版權聲明"><a href="#版權聲明" class="headerlink" title="版權聲明"></a>版權聲明</h2><p>找到 <code>next/_config.yml</code> 中的 <code>creative_commons</code>，將 <code>post</code> 改成 <code>true</code> 就可以了，協議的版本可以參考 <a href="https://creativecommons.org/about/cclicenses/" title="{rel=&#39;nofollow&#39;}">About CC Licenses</a> 自己做挑選。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">size:</span> <span class="string">small</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">language:</span></span><br></pre></td></tr></table></figure>

<p>我自己覺得預設的內容就挺不錯的，不過也可以自訂內容，這邊提供一篇不錯的文章給有興趣的人:</p>
<ul>
<li><a href="https://guiblogs.com/hexo30-21/" title="{rel=&#39;nofollow&#39;}">Day 21：在 Hexo 增加作者版權聲明（使用 Next 佈景）</a></li>
</ul>
<h2 id="閱讀進度"><a href="#閱讀進度" class="headerlink" title="閱讀進度"></a>閱讀進度</h2><p>找到 <code>next/_config.yml</code> 中的 <code>reading_progress</code>，將 <code>enable</code> 改成 <code>true</code>，開啟後會在網頁頂部 &#x2F; 底部顯示閱讀進度條。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">reading_progress:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">start_at:</span> <span class="string">left</span>   <span class="comment"># left/right，從左或右開始 </span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">top</span>    <span class="comment"># top/bottom，顯示在網頁頂部或底部 </span></span><br><span class="line">  <span class="attr">reversed:</span> <span class="literal">false</span>  <span class="comment"># 開啟的話會從全滿開始扣 </span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;#37c6c0&quot;</span> <span class="comment"># 顏色 </span></span><br><span class="line">  <span class="attr">height:</span> <span class="string">3px</span>      <span class="comment"># 進度條寬度 </span></span><br></pre></td></tr></table></figure>


<h2 id="回到頂部"><a href="#回到頂部" class="headerlink" title="回到頂部"></a>回到頂部</h2><p>就是網頁往下滑右下角會出現的那個箭頭，按下去會回到網頁的頂部，找到 <code>next/_config.yml</code> 中的 <code>back2top</code>，將 <code>enable</code> 改成 <code>true</code>。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">back2top:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span>        <span class="comment"># 是否也顯示在側邊欄中 </span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">false</span>  <span class="comment"># 是否顯示百分比 </span></span><br></pre></td></tr></table></figure>


<h2 id="訪客統計、文章閱讀統計"><a href="#訪客統計、文章閱讀統計" class="headerlink" title="訪客統計、文章閱讀統計"></a>訪客統計、文章閱讀統計</h2><p><a href="https://busuanzi.ibruce.info/" title="{rel=&#39;nofollow&#39;}">不蒜子</a> 是一款極簡的前端計數工具，NexT 已經幫我們將不蒜子整合在主題當中，只要修改 <code>next/_config.yml</code> 中的 <code>busuanzi_count</code>，將 <code>enable</code> 改成 <code>true</code>，就可以啟用訪客統計、文章閱讀次數的功能。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span>  <span class="comment"># 訪客人數 </span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span>     <span class="comment"># 全站閱覽次數 </span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span>      <span class="comment"># 文章閱讀統計 </span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">far</span> <span class="string">fa-eye</span></span><br></pre></td></tr></table></figure>

<h2 id="文章字數、閱讀時間"><a href="#文章字數、閱讀時間" class="headerlink" title="文章字數、閱讀時間"></a>文章字數、閱讀時間</h2><ol>
<li><p>下載 <code>hexo-word-counter</code> 插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install hexo-word-counter</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo clean</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Hexo 的 config 檔中 (主目錄裡的) 加入下面設定</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span>             <span class="comment"># 文章字數 </span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span>                <span class="comment"># 文章時間 </span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">false</span>      <span class="comment"># 總文章字數 (顯示在網頁底部)</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">false</span>         <span class="comment"># 總文章時間 (顯示在網頁底部)</span></span><br><span class="line">  <span class="attr">exclude_codeblock:</span> <span class="literal">false</span>  <span class="comment"># 不考慮程式碼部分 </span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span>                  <span class="comment"># Words Per Minute</span></span><br><span class="line">  <span class="attr">suffix:</span> <span class="string">&quot;mins.&quot;</span>           <span class="comment"># 時間單位 </span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>wpm 官方文檔中給的建議是<br>Slow ≈ 200<br>Normal ≈ 275<br>Fast ≈ 350<br>如果主要是中文的話可以設 300，中英夾雜維持 275 就好。</p>
</blockquote>
</li>
<li><p>這個插件有被整合進 NexT 當中，在完成前一個步驟後，我們可以修改 theme config 來調整外觀顯示</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span>        <span class="comment"># 是否顯示文字部分 (文章)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span>   <span class="comment"># 是否獨立一行 </span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">false</span> <span class="comment"># 是否顯示文字部分 (網頁底部)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>不顯示文字的話就不會有 <code>文章字數：</code> 和 <code>所需閱讀時間 ≈</code>，只會有最前面的圖示。</p>
</blockquote>
</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>站內搜尋、主選單等功能我在 <a href="/posts/Hello-Hexo-2/">這篇文章</a> 中有介紹過了，有興趣的人可以去看看。</p>
<h1 id="預告"><a href="#預告" class="headerlink" title="預告"></a>預告</h1><p>下一篇文章會帶大家美化部落格！包括更換背景圖片、變更字體以及其他風格設定～</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>深入瞭解社會網絡分析中的介數中心性 (Betweenness Centrality) - 計算方法與 Python 程式實作</title>
    <url>/posts/betweenness-centrality/</url>
    <content><![CDATA[<h1 id="介紹"><a href="#介紹" class="headerlink" title="介紹"></a>介紹</h1><p><img src="/../images/2023/03/29/Betweenness_Centrality.png" alt="Betweenness Centrality"></p>
<p>介數中心性（Betweenness Centrality）是社會網絡分析中常用的一種指標，用於度量一個節點在整個網絡中扮演了多重要的角色，簡單來說，介數中心性指標評估了一個節點在網絡中擔任了多少條 ** 最短路徑 ** 的中介者角色。</p>
<p>更白話一點，介數中心性看的是一個節點有 ** 多常被其他人經過 **，舉例來說：某些公車站點連接了不同的公車路線，這些公車站點對於連接整個公車網絡起著重要的作用，如果這些公車站發生了任何問題，整個公車路線都會受到影響。這些公車站點就是具有高介數中心性的節點。</p>
<span id="more"></span>

<h1 id="計算方法"><a href="#計算方法" class="headerlink" title="計算方法"></a>計算方法</h1><h2 id="介數中心性"><a href="#介數中心性" class="headerlink" title="介數中心性"></a>介數中心性</h2><p><img src="/../images/2023/03/29/formula.png" alt="Betweenness Centrality Formula"></p>
<p>公式中，𝜎(sigma) 表示最短路徑的數量，分母的意思是從點 s 到點 w 的最短路徑的數量，分子的意思是從點 s 到點 w 的最短路徑中經過 v 點的數量，聽起來有點抽象，我們用下面這張圖來解釋：</p>
<blockquote>
<p><img src="/../images/2023/03/29/simple_network.png" alt="Simple Network"><br>從 s 點到 w 點的最短路徑總共有 4 條，分別是<br><code>s -&gt; 1 -&gt; v -&gt; w</code><br><code>s -&gt; 2 -&gt; v -&gt; w</code><br><code>s -&gt; 3 -&gt; v -&gt; w</code><br><code>s -&gt; 3 -&gt; 4 -&gt; w</code><br>所以分母就是 4，其中經過 v 的有三條所以分子就是 3，能算出在 s 到 w 的路徑中，v 的介數中心性就是 <code>3/4</code>。<br>但要注意的是網絡中的任一點都有可能是 s 或是 w，因此若要計算整個網絡當中 v 的中心性，我們要將網絡中的所有組合加總 (Σ) 才能得到最後的結果。</p>
</blockquote>
<h2 id="標準化"><a href="#標準化" class="headerlink" title="標準化"></a>標準化</h2><p>聰明的你可能會發現網絡中的節點越多，算出來的值也越大 (因為是加總)，因此，為了讓不同網絡之間能被拿來比較，我們要對其進行標準化。</p>
<p><img src="/../images/2023/03/29/normalization_formula.png" alt="Normalization Formula"></p>
<p>其中，分母是 Binomial Coefficient，指的是一個網絡的最大可能介數中心性 (網路中任選兩點、n-1 取 2)：<br><img src="/../images/2023/03/29/binomial_coefficient.png" alt="Binomial Coefficient"></p>
<p>(上面標準化公式的假設是網絡是沒有方向性的，如果有方向性的話就不用除 2 了。)</p>
<h1 id="Python-實作"><a href="#Python-實作" class="headerlink" title="Python 實作"></a>Python 實作</h1><p>網路上很多有關 Betweenness Centrality 的教學都是直接套 <code>networkx</code> 套件，但對於程式邏輯究竟如何實現卻是著墨很少，因此接下來要以 ** 不用套件 ** 的方式來實現 unweighted graph 中 Betweenness Centrality 的計算！</p>
<p>在開始實作前，我們要先把 unweighted graph 轉換成以下格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">graph = &#123;</span><br><span class="line">    <span class="number">0</span> : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="comment"># 節點 : [他的鄰居]</span></span><br><span class="line">    <span class="number">1</span> : [<span class="number">0</span>, <span class="number">4</span>],</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Pseudo-Code"><a href="#Pseudo-Code" class="headerlink" title="Pseudo Code"></a>Pseudo Code</h2><p>來看看 Pseudo Code，這個算法可以計算出 graph 中各個點的 Betweenness Centrality:<br><img src="/../images/2023/03/29/pseudo_code.webp" alt="Pseudo Code for Betweenness Centrality"></p>
<h2 id="程式邏輯"><a href="#程式邏輯" class="headerlink" title="程式邏輯"></a>程式邏輯</h2><p>看了霧煞煞？沒關係，來解釋一下變數的意涵：</p>
<blockquote>
<p>s: 起點<br>v: 中介點<br>w: 終點<br>S: stack，後進先出的佇列，用來儲存已經遍歷過的節點<br>P: path，s 到 w 的最短路徑中，所經過的鄰居 v<br>σ: sigma，s 到其他點的最短路徑的數量<br>d: distance，s 到其他點的最短距離<br>Q: queue，先進先出的佇列，用來實現 BFS<br>δ: delta，介數中心性 (單一個節點 s 的結果)<br>C: centrality，介數中心性 (sum of delta)</p>
</blockquote>
<p>程式邏輯其實很簡單，先初始化 graph 的共用的變數 (<code>C</code>)，接著就是對每個節點 (<code>for s in graph:</code>) 做下面三個步驟：</p>
<ol>
<li>初始化變量<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = [] <span class="comment"># stack</span></span><br><span class="line">P = &#123;node: [] <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125; <span class="comment"># path</span></span><br><span class="line">sigma = &#123;node: <span class="number">0</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125; <span class="comment"># 初始化為 - 1，因為原點是 0</span></span><br><span class="line">sigma [s] = <span class="number">1</span> </span><br><span class="line">d = &#123;node: -<span class="number">1</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125; <span class="comment"># distance</span></span><br><span class="line">d [s] = <span class="number">0</span></span><br><span class="line">Q = deque ([s]) <span class="comment"># queue</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>這部分就是根據各個變量的性質去初始化而已，唯一需要注意的是距離 (<code>d</code>) 一開始要初始化為 - 1，因為原點會是 0。</li>
</ul>
<ol start="2">
<li>計算最短路徑 (BFS)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> Q:</span><br><span class="line">    v = Q.popleft ()</span><br><span class="line">    S.append (v)</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> graph [v]: <span class="comment"># for neighbor in neighbors</span></span><br><span class="line">        <span class="keyword">if</span> d [w] &lt; <span class="number">0</span>: <span class="comment"># 如果遇到新的節點才去更新他的距離 </span></span><br><span class="line">            Q.append (w)</span><br><span class="line">            d [w] = d [v] + <span class="number">1</span></span><br><span class="line">        <span class="comment"># -----------------------------------------------       </span></span><br><span class="line">        <span class="keyword">if</span> d [w] == d [v] + <span class="number">1</span>: <span class="comment"># 判斷 v 是否在 s 到 w 的最短路徑中 </span></span><br><span class="line">            sigma [w] += sigma [v] <span class="comment"># 透過 v 去更新 w 的最短路徑數 </span></span><br><span class="line">            P [w].append (v)</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>在這段程式中，我們可以把他切成兩半，前半段是基本的 BFS 演算法，比較不一樣的地方在於我們將 queue 彈出的節點再存入 stack 中，紀錄所有遍歷過的點；後半段則是從 w 的鄰居中，去尋找鄰居 v 是否位於最短路徑當中 (透過判斷最短距離是否相差 1)，如果是的話那就透過 v 去更新更新 w 的 sigma，並且將 v 記錄至 w 的 <code>path</code> 中。</li>
</ul>
<ol start="3">
<li>計算 Betweenness Centrality<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delta = &#123;node: <span class="number">0</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125;</span><br><span class="line"><span class="comment"># -----------------------------------------------   </span></span><br><span class="line"><span class="keyword">while</span> S:</span><br><span class="line">    w = S.pop () <span class="comment"># 從遍歷過的節點中 pop 一個 </span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> P [w]:</span><br><span class="line">        delta [v] += (sigma [v]/sigma [w]) * (<span class="number">1</span> + delta [w])</span><br><span class="line">    <span class="keyword">if</span> w != s:</span><br><span class="line">        C [w] += delta [w]</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>delta 其實也是初始化變量的一部分啦，只是 Pseudo Code 放在這部分所以寫在這邊。</li>
<li>我們將節點從 stack 中取出來，去更新這些點的 Betweenness Centrality，之所以用 stack 有兩個原因，第一個原因是我們只需要考慮能到達的節點，第二個原因是我們希望由終點往起點去更新。  </li>
<li>接著我們將每個 w 的 path 中的 v 取出，去更新這些 v，<code>sigma [v]/sigma [w]</code> 表示經過 v 的最短路徑數 &#x2F; 經過 w 的最短路徑數，這邊比較讓人 confused 的點應該是，根據前面提到的 Betweenness Centrality 公式，不是只有 <code>sigma [v]/sigma [w]</code> 嗎？為什麼要乘以 <code>1+delta [w]</code> 呢？原因是目前的介數中心性只考慮了 v 之於 w 的影響，我們要對其進行修正以納入 w 後面的節點的影響，我們一樣拿前面用過的例子來解釋：</li>
</ul>
<blockquote>
<p><img src="/../images/2023/03/29/simple_network_2.png" alt="simple network 2"><br>我們把原本的 v 當成新的 w，把點 1 當成新的 v，從 s 到 w 的最短路徑有三條，分別是<br><code>s -&gt; v -&gt; w</code><br><code>s -&gt; 2 -&gt; w</code><br><code>s -&gt; 3 -&gt; w</code><br>其中，經過 v 的只有一條，所以算出來 Betweenness Centrality 就是 <code>sigma [v]/sigma [w] = 1/3</code>，但是！！！v 不只在 <code>s -&gt; w</code> 的最短的路徑上，他也位於 <code>s -&gt; w&#39;</code> 的最短路徑中，這部分也要考慮進去，前面提到從 <code>s -&gt; w&#39;</code> 共有 4 條最短路徑，經過現在的 v 的只有 1 條，因此這部分是 <code>sigma [v]/sigma [w&#39;] = 1/4</code>，而這個值其實會等於 <code>1/3 * 3/4</code>，其中 <code>3/4</code> 是我們前面算得的 <code>delta [w]</code>，因此把 <code>s -&gt; w</code> 與 <code>s -&gt; w&#39;</code> 的結果加起來，就會是：<br> <code>(sigma [v]/sigma [w]) + (sigma [v]/sigma [w&#39;])</code><br>&#x3D;<code>(sigma [v]/sigma [w]) + (sigma [v]/sigma [w])*delta [w]</code><br>&#x3D;<code>(sigma [v]/sigma [w]) * (1+delta [w])</code></p>
</blockquote>
<ul>
<li>最後，針對非起點 s 的節點，我們將其更新到最終結果中。</li>
</ul>
<p>標準化的部分雖然不在 Pseudo Code 中，但一般來說會順便做，方法如同公式的部分提到的，除以 <code>((n-1)*(n-2))/2</code> 就好。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> graph:</span><br><span class="line">    C [node] /= ((n-<span class="number">1</span>)*(n-<span class="number">2</span>))/<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="簡化版架構"><a href="#簡化版架構" class="headerlink" title="簡化版架構"></a>簡化版架構</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">betweenness_centrality</span>(<span class="params">graph</span>):</span><br><span class="line">    C = &#123;node: <span class="number">0</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> graph:</span><br><span class="line">        <span class="number">1.</span> 初始化變量 </span><br><span class="line">        <span class="number">2.</span> 計算最短路徑 (BFS)</span><br><span class="line">        <span class="number">3.</span> 計算 centrality</span><br><span class="line">    </span><br><span class="line">    do Normalization</span><br><span class="line">    <span class="keyword">return</span> C</span><br></pre></td></tr></table></figure>

<h2 id="完整程式碼"><a href="#完整程式碼" class="headerlink" title="完整程式碼"></a>完整程式碼</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">betweenness_centrality</span>(<span class="params">graph</span>):</span><br><span class="line"></span><br><span class="line">    C = &#123;node: <span class="number">0</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125; <span class="comment"># centrality</span></span><br><span class="line">    n = <span class="built_in">len</span>(C)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍歷每個節點 </span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> graph:</span><br><span class="line">        <span class="comment"># 1. 初始化變量 </span></span><br><span class="line">        S = [] <span class="comment"># stack</span></span><br><span class="line">        P = &#123;node: [] <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125; <span class="comment"># path</span></span><br><span class="line">        sigma = &#123;node: <span class="number">0</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125; <span class="comment"># 初始化為 - 1，因為原點是 0</span></span><br><span class="line">        sigma [s] = <span class="number">1</span> </span><br><span class="line">        d = &#123;node: -<span class="number">1</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125; <span class="comment"># distance</span></span><br><span class="line">        d [s] = <span class="number">0</span></span><br><span class="line">        Q = deque ([s]) <span class="comment"># queue</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2. 計算最短路徑 (BFS)</span></span><br><span class="line">        <span class="keyword">while</span> Q:</span><br><span class="line">            v = Q.popleft ()</span><br><span class="line">            S.append (v)</span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> graph [v]: <span class="comment"># for neighbor in neighbors</span></span><br><span class="line">                <span class="keyword">if</span> d [w] &lt; <span class="number">0</span>: <span class="comment"># 如果遇到新的節點才去更新他的距離 </span></span><br><span class="line">                    Q.append (w)</span><br><span class="line">                    d [w] = d [v] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> d [w] == d [v] + <span class="number">1</span>: <span class="comment"># 判斷 v 是否在 s 到 w 的最短路徑中 </span></span><br><span class="line">                    sigma [w] += sigma [v] <span class="comment"># 透過 v 去更新 w 的最短路徑數 </span></span><br><span class="line">                    P [w].append (v)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 計算 centrality</span></span><br><span class="line">        delta = &#123;node: <span class="number">0</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125;</span><br><span class="line">        <span class="keyword">while</span> S:</span><br><span class="line">            w = S.pop () <span class="comment"># 從遍歷過的節點中 pop 一個 </span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> P [w]:</span><br><span class="line">                delta [v] += (sigma [v]/sigma [w]) * (<span class="number">1</span> + delta [w])</span><br><span class="line">            <span class="keyword">if</span> w != s:</span><br><span class="line">                C [w] += delta [w]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Normalization</span></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> graph:</span><br><span class="line">        C [node] /= ((n-<span class="number">1</span>)*(n-<span class="number">2</span>))/<span class="number">2</span> <span class="comment"># 將每個節點除以最大可能值 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C</span><br></pre></td></tr></table></figure>



<h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>如果真的遇到要計算 Betweenness Centrality 的情況，當然還是直接用 <code>networkx</code> 套件裡的 <code>betweenness_centrality</code> 就好了啦，寫這篇單純是因為網路上都找不到有人說明算法的邏輯，所以希望寫這篇能幫助到其他想了解算法的人。<br>要注意上面的算法建立在所有 edge 的權重都是一樣的情況下，也就是點與點之間不是 1 就是 0 的 binary 關係，那如果每條 edge 有不同的權重呢？方法其實也不太意外，就是把程式中計算最短路徑的部分換掉就好了，根據實際情況可以選擇 Dijkstra 或是 Bellman–Ford 等。</p>
]]></content>
      <categories>
        <category>Social Network Analysis</category>
      </categories>
      <tags>
        <tag>(test)Betweenness Centrality</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Hexo！NexT 主題太單調？跟著這些美化步驟為部落格加入個人風格！(5)</title>
    <url>/posts/Hello-Hexo-5/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="/../images/2023/04/17/cover.png" alt="cover"></p>
<p>Hexo Next 雖然已經將許多常見的設定整合到主題當中，但大家都採用一樣的設定的話其實挺無聊的，所以今天要在 Hexo Next 的基礎上帶大家來美化自己的部落格，為部落格加入 ** 個人風格 **，如果還不知道 Hexo 或者 NexT 是什麼可以參考我之前寫的 <a href="/categories/Hexo/">Hello Hexo！</a> 系列文章。 </p>
<span id="more"></span>

<h1 id="大綱"><a href="#大綱" class="headerlink" title="大綱"></a>大綱</h1><ul>
<li>[套用背景圖片](# 套用背景圖片)</li>
<li>[調整區塊透明度](# 調整區塊透明度)</li>
<li>[設置區塊圓角](# 設置區塊圓角)</li>
<li>[文章區塊版面寬度](# 文章區塊版面寬度)</li>
<li>[程式碼區塊主題](# 程式碼區塊主題)</li>
<li>[變更文字樣式](# 變更文字樣式)</li>
<li>[變更字體類型](# 變更字體類型)</li>
<li>[圖片放大檢視](# 圖片放大檢視)</li>
</ul>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><h2 id="套用背景圖片"><a href="#套用背景圖片" class="headerlink" title="套用背景圖片"></a>套用背景圖片</h2><ol>
<li>準備一張圖片放到 <code>themes/next/source/images/</code> 路徑中。</li>
<li>到 <code>themes/next/_config.yml</code> 中，找到 <code>custom_file_path</code>，將 <code>style</code> 的註解取消掉。<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.njk</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.njk</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.njk</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.njk</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.njk</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.njk</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.njk</span></span><br><span class="line">  <span class="comment">#variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure></li>
<li>在 <code>source</code> 內新增 <code>_data</code> 資料夾 (** 注意是 blog 的，不是 next 裡面的！**)，接著在裡面新增一個 <code>styles.styl</code> 文件。</li>
<li>在 <code>styles.styl</code> 中加入:<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>:<span class="built_in">url</span>(/images/background.jpg);  <span class="comment">// 背景圖片位置 </span></span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-attachment</span>: fixed;            <span class="comment">// 是否滾動，fixed 固定 </span></span><br><span class="line">  <span class="attribute">background-size</span>: cover;                  <span class="comment">// 填滿畫面 </span></span><br><span class="line">  <span class="attribute">background-position</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="調整區塊透明度"><a href="#調整區塊透明度" class="headerlink" title="調整區塊透明度"></a>調整區塊透明度</h2><p>套用背景圖片後，你可能會發現你的圖片大部分都被區塊擋住了！為了讓大家看到你美美的圖片，所以我們要來調整一下區跨的透明度，網路上很多調整透明度的方法都沒有用我試過了，最後在 <a href="https://hui-shao.cn/next-transparent-background/" title="{rel=&#39;nofollow&#39;}">這篇文章</a> 中找到讓我滿意的效果，這邊直接講結論，在 <code>styles.styl</code> 加入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:root &#123;</span><br><span class="line">  --content-bg-color:#ffffffe6;  // 白色半透明 </span><br><span class="line">  --content-bg-color:#000000e6;  // 黑色半透明，兩者擇一 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>補充：上面的設定是直接將區塊換成指定顏色，如果有開啟深色模式可以用黑色半透明，如果沒有的話可以用白色半透明，但切記不要混者用，否則文字會看不清楚。</p>
</blockquote>
<h2 id="設置區塊圓角"><a href="#設置區塊圓角" class="headerlink" title="設置區塊圓角"></a>設置區塊圓角</h2><ol>
<li><p>到 <code>themes/next/_config.yml</code> 中，找到 <code>custom_file_path</code>，將 <code>variable</code> 的註解也取消掉。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.njk</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.njk</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.njk</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.njk</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.njk</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.njk</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.njk</span></span><br><span class="line">  <span class="attr">variable:</span> <span class="string">source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>source</code> 內新增 <code>_data</code> 資料夾 (** 注意是 blog 的，不是 next 裡面的！**)，接著在裡面新增一個 <code>variables.styl</code> 文件。</p>
</li>
<li><p>在 <code>variables.styl</code> 中加入:</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="variable">$border</span>-radius-inner     = <span class="number">30px</span> <span class="number">30px</span> <span class="number">30px</span> <span class="number">30px</span>;  <span class="comment">// (內角) 左上 右上 右下 左下 </span></span><br><span class="line"><span class="variable">$border</span>-radius           = <span class="number">30px</span>;                 <span class="comment">// (外角) 只填一個數字表示 4 個角 </span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="文章區塊版面寬度"><a href="#文章區塊版面寬度" class="headerlink" title="文章區塊版面寬度"></a>文章區塊版面寬度</h2><p>我們先來看一下預設的寬度 (指的是網頁版，手機或平板都是用響應式網頁):</p>
<ul>
<li>Muse &#x2F; Mist<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="variable">$content</span>-desktop         = <span class="number">700px</span>   <span class="comment">//when screen width &lt; 1200px</span></span><br><span class="line"><span class="variable">$content</span>-desktop-large   = <span class="number">800px</span>   <span class="comment">//when screen width &gt;= 1200px</span></span><br><span class="line"><span class="variable">$content</span>-desktop-largest = <span class="number">900px</span>   <span class="comment">//when screen width &gt;= 1600px</span></span><br></pre></td></tr></table></figure></li>
<li>Pisces &#x2F; Gemini<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="variable">$content</span>-desktop         = <span class="string">&#x27;calc (100% - % s)&#x27;</span> % <span class="built_in">unit</span>(<span class="variable">$content</span>-desktop-<span class="attribute">padding</span> / <span class="number">2</span>, <span class="string">&#x27;px&#x27;</span>)</span><br><span class="line"><span class="variable">$content</span>-desktop-large   = <span class="number">1160px</span></span><br><span class="line"><span class="variable">$content</span>-desktop-largest = <span class="number">73%</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>可以看到不同主題的寬度定義方式不太一樣，如果要更改的話，我們可以到 <code>variables.styl</code> 中把預設的寬度覆蓋掉，舉例來說我使用 Gemini，下面是我採用的設定:</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="variable">$content</span>-desktop         = <span class="number">90%</span>  <span class="comment">// 可以用百分比 </span></span><br><span class="line"><span class="variable">$content</span>-desktop-large   = <span class="number">80%</span>  <span class="comment">// 也可用絕對數值 ex: 1000px</span></span><br></pre></td></tr></table></figure>


<h2 id="程式碼區塊主題"><a href="#程式碼區塊主題" class="headerlink" title="程式碼區塊主題"></a>程式碼區塊主題</h2><p>Hexo 提供了 <code>highlight.js</code> 以及 <code>prism.js</code> 兩種程式碼區塊主題 engine，可以參考 <a href="https://theme-next.js.org/highlight/" title="{rel=&#39;nofollow&#39;}">NexT Highlight Theme Preview</a> 來做挑選，以下已我自己套用 <code>highlight.js</code> 中的 <code>night-owl</code> 主題為例。</p>
<ol>
<li><p>到 <code>_config.yml</code> 中 (不是 next 裡的)，找到 <code>highlight</code>，將 <code>enable</code> 改成 true。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span>   <span class="comment"># 是否顯示行數 </span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span>  <span class="comment"># 是否自動偵測語言 (建議不要開，聽說很吃效能)</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hljs:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">prismjs:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span>       <span class="comment"># 如果是用 prismjs 的話那就是這裡改 true，不要同時開兩個 </span></span><br><span class="line">  <span class="attr">preprocess:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>到 <code>themes/next/_config.yml</code> 中，找到 <code>codeblock</code>，根據是否開啟深色模式來填入主題名稱。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="attr">theme:</span>                      <span class="comment"># highlight.js 改這 </span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">night-owl</span>          <span class="comment"># (範例) 淺色模式下套用 night-owl </span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">stackoverflow-dark</span></span><br><span class="line">  <span class="attr">prism:</span>                      <span class="comment"># prism.js 改這 </span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">prism</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">prism-dark</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span>             <span class="comment"># 是否顯示複製按鈕 </span></span><br><span class="line">    <span class="attr">style:</span>                    <span class="comment"># 風格 (Available values: default | flat | mac)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="變更文字樣式"><a href="#變更文字樣式" class="headerlink" title="變更文字樣式"></a>變更文字樣式</h2><p>這部分主要是分享我在網路上找到的，覺得很不錯的設定，以下修改都是加在 <code>source/_data/styles.styl</code> 中。</p>
<ol>
<li><p>短網址樣式</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">code</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#c7254e</span>; <span class="comment">// 文字顏色 </span></span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#f9f2f4</span>; <span class="comment">// 底色 </span></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>內文連結樣式</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> a&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0593d3</span>;</span><br><span class="line">  <span class="selector-pseudo">&amp;:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fc6423</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: none;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#fc6423</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改選中文字底色</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* webkit, opera, IE9 */</span></span><br><span class="line"><span class="selector-pseudo">::selection</span> &#123; </span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#00c4b6</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f7f7f7</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* firefox */</span></span><br><span class="line">::-moz-selection &#123; </span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#00c4b6</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f7f7f7</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改頁腳配色</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 頁腳統計文字顏色 </span><br><span class="line">.footer&#123;</span><br><span class="line">  color: #F0D784</span><br><span class="line">&#125;</span><br><span class="line">// 修改頁腳備案鏈接顏色 </span><br><span class="line">.footer a&#123;</span><br><span class="line">  color: #F0D784</span><br><span class="line">&#125;</span><br><span class="line">// 修改頁腳統計人數的顏色 </span><br><span class="line">.footer .with-love&#123;</span><br><span class="line">  color: #F0D784</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="變更字體類型"><a href="#變更字體類型" class="headerlink" title="變更字體類型"></a>變更字體類型</h2><p>NexT 可以直接使用 <a href="https://fonts.google.com/" title="{rel=&#39;nofollow&#39;}">Google Fonts</a> 提供的字體，但如果你使用的是繁體中文的話，你會發現其實也就只有兩種可以選而已 XDDD，NexT 預設是使用 ** 微軟正黑體 **，另外一種是 ** 唐宋思源體 **，我們今天就來試者把字體換成唐宋思源體看看吧！</p>
<ol>
<li>到 <code>themes/next/_config.yml</code> 中，找到 <code>font</code> 將 <code>enable</code> 改成 <code>true</code>，接著更改 <code>global</code> 的設定 (後面的不用改)。<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>              <span class="comment"># 設成 true</span></span><br><span class="line">  <span class="attr">host:</span> </span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span>          <span class="comment"># 設成 true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Noto</span> <span class="string">Serif</span> <span class="string">TC</span>   <span class="comment"># 唐宋思源體 (TC: Traditional Chinese)</span></span><br><span class="line">    <span class="attr">size:</span>                   <span class="comment"># 字體大小，默認為 1（16px）</span></span><br></pre></td></tr></table></figure></li>
<li>這邊特別說明 <code>host</code> 部分，在台灣基本上是不用設，但因為預設的 host 是 Google 的 api，所以大陸地區的用戶在看我們的網站時可能會遇到一些穩定性上的問題？如果你部落格的 target 是整個大中華地區的話可以另外設個 host，這邊提供 <a href="https://github.com/cdnjs/cdnjs" title="{rel=&#39;nofollow&#39;}">cdnjs</a> 的鏡像 api 給有需要的人:<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">host:</span> <span class="string">https://fonts.loli.net</span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>補充：你可能會想問「如果我想要用的字體 Google Fonts 沒有提供怎麼辦？」，其實也是有辦法使用本地的字體喔，不過這部分稍微麻煩一丟丟，所以之後另外寫一篇文章介紹！</p>
</blockquote>
<h2 id="圖片放大檢視"><a href="#圖片放大檢視" class="headerlink" title="圖片放大檢視"></a>圖片放大檢視</h2><p>NexT 目前提供兩種片放大檢視的工具，分別是 <a href="https://fancyapps.com/fancybox/" title="{rel=&#39;nofollow&#39;}">FancyBox</a> 以及 <a href="https://medium-zoom.francoischalifour.com/" title="{rel=&#39;nofollow&#39;}">Medium Zoom</a>，可以看一下自己喜歡哪種。</p>
<p>到 <code>themes/next/_config.yml</code> 中找到 <code>fancybox</code>&#x2F;<code>mediumzoom</code>，將其改為 <code>true</code>，注意不要同時開啟兩個功能！！！</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">fancybox:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">mediumzoom:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>補充: FancyBox 的功能比較多且可以顯示註解，不過有 <a href="https://github.com/ppoffice/hexo-theme-icarus/issues/868" title="{rel=&#39;nofollow&#39;}">issue</a> 表示 FancyBox 對於行動裝置似乎不是很友好？不知道改了沒，Medium Zoom 就跟 Medium 放大圖片的功能一樣，介面比較簡潔。</p>
</blockquote>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><p>文章內容大多是網路上的資料整理而來，再加上自己的採坑經驗，如果有遺漏來源的話再麻煩告知補上！</p>
<ul>
<li><a href="https://zenreal.github.io/posts/44730/" title="{rel=&#39;nofollow&#39;}">最新 Hexo NexT v7.4.1 主題優化</a></li>
<li><a href="https://hui-shao.cn/next-transparent-background/" title="{rel=&#39;nofollow&#39;}">Hexo + NexT8 主题配置透明背景过程踩坑小记</a></li>
<li>[Next 主题字体配置](<a href="https://spartazhc.github.io/2020/06/03/Next%">https://spartazhc.github.io/2020/06/03/Next%</a> E4% B8% BB% E9% A2%98% E5% AD%97% E4% BD%93% E9%85%8D% E7% BD% AE&#x2F; “{rel&#x3D;’nofollow’}”)</li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>資料結構筆記 - 布隆過濾器 Bloom Filter</title>
    <url>/posts/bloom-filter/</url>
    <content><![CDATA[<p><img src="/../images/2024/01/10/bloom-filter-new.png" alt="bloom-filter"></p>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><ul>
<li>用途：用來快速判斷元素是否存在於一個集合中</li>
<li>優點：快速、節省空間</li>
<li>缺點：可能有 false positive (不存在但判定為存在)</li>
<li>應用: <ul>
<li>Check Duplicate: name、email 等是否已被使用</li>
<li>Filters: 過濾惡意請求 (ex: <a href="https://www.explainthis.io/zh-hant/swe/cache-mechanism">Cache penetration</a>)、垃圾郵件等</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>對元素使用 k 個 Hash Functions，將其映射到長度為 m 的 Array 中，寫入時將映射到的 k 個位置標示為 1，檢查時如果映射到的 k 個位置都命中，表示該元素 ** 可能存在 **。</p>
<ol>
<li><p>由預期的 <strong>False positive rate (p)</strong> 以及存入的 ** 資料筆數 (n)** 來求出 <strong>Array Size (m)</strong> 以及 <strong>Hash Functions 數 (k)</strong></p>
<ul>
<li><strong>False positive rate</strong><br>  <img src="/../images/2024/01/10/false-positive-probability.png" alt="false-positive-probability"></li>
<li><strong>Array size</strong><br>  <img src="/../images/2024/01/10/array-size.png" alt="array-size"></li>
<li><strong>Number of hash functions</strong><br>  <img src="/../images/2024/01/10/number-of-hash-functions.png" alt="number-of-hash-functions"></li>
</ul>
</li>
<li><p>選擇 Hash function<br>可以使用 <strong>Non-Cryptographic Hash</strong> (非密碼雜湊函數)，雖然有 collision 的可能，但足夠好了，而且比較快。<br>例如: MurmurHash、FarmHash、SpookyHash</p>
</li>
</ol>
<h1 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h1><p>** 非原創！** 基本上是下面參考文章中的程式碼，寫的很不錯所以只有小小修改一下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python 3 program to build Bloom Filter </span></span><br><span class="line"><span class="comment"># Install mmh3 and bitarray 3rd party module first </span></span><br><span class="line"><span class="comment"># pip install mmh3 </span></span><br><span class="line"><span class="comment"># pip install bitarray </span></span><br><span class="line"><span class="keyword">import</span> math </span><br><span class="line"><span class="keyword">import</span> mmh3 </span><br><span class="line"><span class="keyword">from</span> bitarray <span class="keyword">import</span> bitarray </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BloomFilter</span>(<span class="title class_ inherited__">object</span>): </span><br><span class="line"></span><br><span class="line">	<span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">	Class for Bloom filter, using murmur3 hash function </span></span><br><span class="line"><span class="string">	&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, items_count, fp_prob</span>): </span><br><span class="line">		<span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">		items_count : int </span></span><br><span class="line"><span class="string">			Number of items expected to be stored in bloom filter </span></span><br><span class="line"><span class="string">		fp_prob : float </span></span><br><span class="line"><span class="string">			False Positive probability in decimal </span></span><br><span class="line"><span class="string">		&#x27;&#x27;&#x27;</span></span><br><span class="line">		<span class="comment"># False possible probability in decimal </span></span><br><span class="line">		self.fp_prob = fp_prob </span><br><span class="line"></span><br><span class="line">		<span class="comment"># Size of bit array to use </span></span><br><span class="line">		self.size = self.get_size (items_count, fp_prob) </span><br><span class="line"></span><br><span class="line">		<span class="comment"># number of hash functions to use </span></span><br><span class="line">		self.hash_count = self.get_hash_count (self.size, items_count) </span><br><span class="line"></span><br><span class="line">		<span class="comment"># Bit array of given size, default all 0 </span></span><br><span class="line">		self.bit_array = bitarray (self.size) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, item</span>): </span><br><span class="line">		<span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">		Add an item in the filter </span></span><br><span class="line"><span class="string">		&#x27;&#x27;&#x27;</span></span><br><span class="line">		digests = [] </span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.hash_count): </span><br><span class="line"></span><br><span class="line">			<span class="comment"># create digest for given item. </span></span><br><span class="line">			<span class="comment"># i work as seed to mmh3.hash () function </span></span><br><span class="line">			<span class="comment"># With different seed, digest created is different </span></span><br><span class="line">			digest = mmh3.<span class="built_in">hash</span>(item, i) % self.size </span><br><span class="line">			digests.append (digest) </span><br><span class="line"></span><br><span class="line">			<span class="comment"># set the bit True in bit_array </span></span><br><span class="line">			self.bit_array [digest] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">self, item</span>): </span><br><span class="line">		<span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">		Check for existence of an item in filter </span></span><br><span class="line"><span class="string">		&#x27;&#x27;&#x27;</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.hash_count): </span><br><span class="line">			digest = mmh3.<span class="built_in">hash</span>(item, i) % self.size </span><br><span class="line">			<span class="keyword">if</span> self.bit_array [digest] == <span class="literal">False</span>: </span><br><span class="line"></span><br><span class="line">				<span class="comment"># if any of bit is False then,its not present </span></span><br><span class="line">				<span class="comment"># in filter </span></span><br><span class="line">				<span class="comment"># else there is probability that it exist </span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">	@staticmethod</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">get_size</span>(<span class="params">n, p</span>): </span><br><span class="line">		<span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">		Return the size of bit array (m) to used using </span></span><br><span class="line"><span class="string">		following formula </span></span><br><span class="line"><span class="string">		m = -(n * lg (p)) / (lg (2)^2) </span></span><br><span class="line"><span class="string">		n : int </span></span><br><span class="line"><span class="string">			number of items expected to be stored in filter </span></span><br><span class="line"><span class="string">		p : float </span></span><br><span class="line"><span class="string">			False Positive probability in decimal </span></span><br><span class="line"><span class="string">		&#x27;&#x27;&#x27;</span></span><br><span class="line">		m = -(n * math.log (p))/(math.log (<span class="number">2</span>)**<span class="number">2</span>) </span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">int</span>(m) </span><br><span class="line"></span><br><span class="line"><span class="meta">	@staticmethod</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">get_hash_count</span>(<span class="params">m, n</span>): </span><br><span class="line">		<span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">		Return the hash function (k) to be used using </span></span><br><span class="line"><span class="string">		following formula </span></span><br><span class="line"><span class="string">		k = (m/n) * lg (2) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		m : int </span></span><br><span class="line"><span class="string">			size of bit array </span></span><br><span class="line"><span class="string">		n : int </span></span><br><span class="line"><span class="string">			number of items expected to be stored in filter </span></span><br><span class="line"><span class="string">		&#x27;&#x27;&#x27;</span></span><br><span class="line">		k = (m/n) * math.log (<span class="number">2</span>) </span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">int</span>(k)</span><br></pre></td></tr></table></figure>

<p>看一下成果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">100000</span> <span class="comment"># Number of items to add </span></span><br><span class="line">p = <span class="number">0.05</span> <span class="comment"># False positive probability </span></span><br><span class="line">  </span><br><span class="line">bloomf = BloomFilter (n,p) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Array size: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(bloomf.size)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of hash functions: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(bloomf.hash_count)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;False positive probability: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(bloomf.fp_prob)) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Add items</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">	bloomf.add (<span class="built_in">str</span>(i))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check false positive rate on Test data</span></span><br><span class="line">fp = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n, <span class="number">2</span>*n):</span><br><span class="line">	<span class="keyword">if</span> bloomf.check (<span class="built_in">str</span>(i)):</span><br><span class="line">		fp += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;False positive rate on test data: &#123;:.4f&#125;&quot;</span>.<span class="built_in">format</span>(fp/n)) </span><br></pre></td></tr></table></figure>

<p>可以看到實際的 FP Rate 與我們設定的非常接近。<br><img src="/../images/2024/01/10/filter-result.png" alt="filter-result"></p>
<h1 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h1><p><a href="https://www.geeksforgeeks.org/bloom-filters-introduction-and-python-implementation/">Bloom Filters – Introduction and Implementation</a></p>
]]></content>
      <categories>
        <category>DSA</category>
      </categories>
      <tags>
        <tag>Bloom Filter</tag>
      </tags>
  </entry>
  <entry>
    <title>系統架構筆記 - 常見的五種部署策略</title>
    <url>/posts/deployment-strategies/</url>
    <content><![CDATA[<p><img src="/../images/2024/01/16/strategies.png" alt="strategies"></p>
<p>這篇文章簡單紀錄了常見的五種部署策略: Big Bang Deployment、Rolling Deployment (滾動部署)、Blue-Green Deployment (藍綠部署)、Canary Deployment (金絲雀部署) 與 Shadow Deployment (影子部署)。</p>
<span id="more"></span>

<h1 id="Big-Bang-Deployment"><a href="#Big-Bang-Deployment" class="headerlink" title="Big Bang Deployment"></a>Big Bang Deployment</h1><p>名字聽起來很 Dramatic 的部署策略，將舊版本完全下線後部署新版本。</p>
<ul>
<li>優點: <ul>
<li>easy、一次性完成</li>
</ul>
</li>
<li>缺點: <ul>
<li>有 downtime，一般生產環境下不會使用</li>
</ul>
</li>
</ul>
<h1 id="Rolling-Deployment-滾動部署"><a href="#Rolling-Deployment-滾動部署" class="headerlink" title="Rolling Deployment (滾動部署)"></a>Rolling Deployment (滾動部署)</h1><p><img src="/../images/2024/01/16/rolling.png" alt="rolling"></p>
<p>將舊版本逐步 (one by one) 更新為新版本，在這個過程中，舊版本和新版本會共存一段時間。</p>
<ul>
<li>優點: <ul>
<li>no downtime</li>
</ul>
</li>
<li>缺點: <ul>
<li>新舊版本間沒有隔離，可能需要處理版本之間的相容性與數據一致性</li>
<li>rollback 也是逐步滾回去，複雜且耗時</li>
</ul>
</li>
</ul>
<h1 id="Blue-Green-Deployment-藍綠部署"><a href="#Blue-Green-Deployment-藍綠部署" class="headerlink" title="Blue-Green Deployment (藍綠部署)"></a>Blue-Green Deployment (藍綠部署)</h1><p><img src="/../images/2024/01/16/blue-green.png" alt="blue-green"></p>
<p>同時維護兩個平行的環境，一個為主要環境 (Blue)，另一個為即將上線的新版本 (Green)，於測試環境測試完新版本後，直接將兩個環境的流量做切換。</p>
<ul>
<li>優點: <ul>
<li>no downtime</li>
<li>直接切換流量即可完成版本切換，rollback 也是</li>
</ul>
</li>
<li>缺點: <ul>
<li>要同時維護兩個環境，成本高</li>
</ul>
</li>
</ul>
<h1 id="Canary-Deployment-金絲雀部署"><a href="#Canary-Deployment-金絲雀部署" class="headerlink" title="Canary Deployment (金絲雀部署)"></a>Canary Deployment (金絲雀部署)</h1><p><img src="/../images/2024/01/16/canary.png" alt="canary"></p>
<p>將新版本釋出給少量用戶做測試，測試沒問題後才將剩下的部署為新版本。</p>
<ul>
<li>優點: <ul>
<li>no downtime</li>
<li>能於生產環境中評估新版本效能，降低新版本風險</li>
<li>rollback 較容易</li>
</ul>
</li>
<li>缺點: <ul>
<li>部署時間較長</li>
<li>某些問題無法靠少量用戶就發現</li>
</ul>
</li>
<li>與 Rolling Deployment 的差異<ul>
<li>Canary Deployment 是階段式的過程，先部署少部分，確定沒問題才擴大部署</li>
<li>Rolling Deployment 則連續的過程，一次對整個系統做升級，只是過程上是逐步部署</li>
</ul>
</li>
</ul>
<h1 id="Shadow-Deployment-影子部署"><a href="#Shadow-Deployment-影子部署" class="headerlink" title="Shadow Deployment (影子部署)"></a>Shadow Deployment (影子部署)</h1><p>同時維護兩個平行的環境，新版本在幕後運行 (in the shadow)，使用者的 request 會被複製一份到新版本用於測試</p>
<ul>
<li>優點:<ul>
<li>不會對使用者造成實際影響，同時能測試新版本效能</li>
</ul>
</li>
<li>缺點<ul>
<li>實作上比較困難</li>
<li>成本高</li>
</ul>
</li>
</ul>
<h2 id="其他-Feature-Toggle"><a href="#其他-Feature-Toggle" class="headerlink" title="其他: Feature Toggle"></a>其他: Feature Toggle</h2><p><img src="/../images/2024/01/16/feature-toggle.png" alt="feature-toggle"></p>
<p>封面的圖片裡還有提到一個 Feature Toggle，概念是在程式中設計一個開關來控制新功能的狀態，可以針對特定用戶開啟，用來觀察新功能的效能、反饋如何，通常是用來做 A&#x2F;B Test，本質上跟前面提到的幾個部署方法有點差異。</p>
]]></content>
      <categories>
        <category>(test)System Design</category>
      </categories>
      <tags>
        <tag>Deployment</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 自學筆記 01 - Basics</title>
    <url>/posts/java-learning-01/</url>
    <content><![CDATA[<h2 id="JVM-JRE-amp-JDK"><a href="#JVM-JRE-amp-JDK" class="headerlink" title="JVM, JRE &amp; JDK"></a>JVM, JRE &amp; JDK</h2><p><img src="/../images/2024/03/18/JVM_JRE_JDK.png" alt="JVM, JRE &amp; JDK"></p>
<h3 id="Java-vs-C"><a href="#Java-vs-C" class="headerlink" title="Java vs C"></a>Java vs C</h3><p>當開發 C 或 C++ 程式時，通常會先將原始碼透過編譯器轉換成目標機器可以理解的 Object Code。這個 Object Code 是特定於目標機器架構的，因此在不同的硬體平台上可能會產生不同的機器碼。因此，當將程式移植到不同的機器或架構時，通常需要重新編譯原始碼以生成適用於該特定平台的新 Object Code。</p>
<span id="more"></span>

<h3 id="JVM-Java-Virtual-Machine"><a href="#JVM-Java-Virtual-Machine" class="headerlink" title="JVM (Java Virtual Machine)"></a>JVM (Java Virtual Machine)</h3><p>Java 通過 JVM 來解決跨平台的問題，程式在編譯時是先翻譯成 JVM 的 Byte code，執行時才由 JVM 轉換為機器碼，由於不是直接編譯成機械碼，這表示只要新的平台有安裝 JVM，就不用重新編譯一遍了。<br>某方面來說 JVM 算是一種 interpreter，負責執行 Byte code。<br><img src="/../images/2024/03/18/JVM.png" alt="JVM"></p>
<h3 id="JRE-Java-Runtime-Environment"><a href="#JRE-Java-Runtime-Environment" class="headerlink" title="JRE (Java Runtime Environment)"></a>JRE (Java Runtime Environment)</h3><p>JRE 包含了執行 Java 程式所需的所有檔案和庫，包括 JVM、Class Libraries、Java API 等，也就是說單單是執行而不需要開發的話安裝 JRE 就夠了。</p>
<h3 id="JDK-Java-Development-Kit"><a href="#JDK-Java-Development-Kit" class="headerlink" title="JDK (Java Development Kit)"></a>JDK (Java Development Kit)</h3><p>JDK 是一個完整的 Java 開發套件，包括了 JRE、編譯器 (javac) 以及開發所需要的各種工具和庫。</p>
<h2 id="Hello-Java"><a href="#Hello-Java" class="headerlink" title="Hello Java"></a>Hello Java</h2><ul>
<li><p>Hello.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> <span class="comment">//Class 的名稱要跟檔名一模一樣 </span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span></span><br><span class="line">   &#123;</span><br><span class="line">      System.out.println (<span class="string">&quot;Hello Java&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>compile</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">javac Hello.java</span></span><br></pre></td></tr></table></figure></li>
<li><p>run</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java Hello</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Data-Type"><a href="#Data-Type" class="headerlink" title="Data Type"></a>Data Type</h2><p><img src="/../images/2024/03/18/java_data_type.png" alt="Java Data Type"></p>
<h3 id="資料型態轉換"><a href="#資料型態轉換" class="headerlink" title="資料型態轉換"></a>資料型態轉換</h3><ul>
<li><p>浮點數大於整數<br>  double &gt; float &gt; long &gt; int &gt; short &gt; byte</p>
</li>
<li><p>小轉大 OK，大轉小 error<br>  <img src="/../images/2024/03/18/java_casting.png" alt="Java Casting"></p>
</li>
<li><p>大轉小可以強制轉換，但可能失真</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">n2</span> <span class="operator">=</span> (<span class="type">byte</span>) n1; <span class="comment">// 不一樣 (2 進位高位被截斷)</span></span><br></pre></td></tr></table></figure></li>
<li><p>字串轉數字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> Integer.parseInt (<span class="string">&quot;1234&quot;</span>)</span><br><span class="line"><span class="type">long</span> <span class="variable">n2</span> <span class="operator">=</span> Long.parseLong (<span class="string">&quot;1234&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>數字轉字串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> String.valueOf (<span class="number">1234</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> String.valueOf (<span class="number">1.234</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="標準輸入"><a href="#標準輸入" class="headerlink" title="標準輸入"></a>標準輸入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> s.nextInt ();</span><br><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> s.next ();</span><br></pre></td></tr></table></figure>

<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>Java 的陣列跟 C 不一樣，不是以連續的記憶體表達陣列，而是以一種 object 的形式實作，因此多維的陣列係由前一層指向後一層，所以不同層的 Array 長度可以不一樣！！！</p>
<p><img src="/../images/2024/03/18/java_array.png" alt="Java Array"></p>
<p>Array 的宣告與初始化方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] x = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">x = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line">x.length <span class="comment">//x 的長度 </span></span><br></pre></td></tr></table></figure>


<h2 id="Class-and-Object"><a href="#Class-and-Object" class="headerlink" title="Class and Object"></a>Class and Object</h2><ul>
<li>Object 產生時一定要呼叫的方法，稱為 Constructor (建構子)</li>
<li>Objec 消滅需要呼叫的方法，稱為 Destructor (解構子)</li>
<li>表達 Object 內部狀態的變數，稱為 Object Variable (物件變數成員)</li>
<li>Object 可以接收的訊息，稱為 Object Method (物件方法成員)</li>
<li>上述兩個可總稱為 Object Member</li>
<li>屬於 Class 的變數，稱為 Class Variable (類別變數)</li>
<li>屬於 Class 的方法，稱為 Class Method (類別方法)</li>
<li>上述兩個可總稱為 Class Member</li>
<li>和其他 Class 間的繼承關係</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> speed; <span class="comment">// Object Variable</span></span><br><span class="line">    <span class="keyword">private</span> String direction; <span class="comment">// Object Variable, direction is a reference to String Object</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">numVehicle</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// Class Variable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vehicle</span><span class="params">()</span> &#123; <span class="comment">// Constructor, called when new a Object</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="number">0</span>,<span class="string">&quot;north&quot;</span>); <span class="comment">//call another constructor to do initialization</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vehicle</span><span class="params">(<span class="type">int</span> s, String dir)</span> &#123; <span class="comment">// Another Constructor. Use overloading to define two constructors</span></span><br><span class="line">        <span class="type">float</span> speed; <span class="comment">//define a local variable</span></span><br><span class="line">        speed = s; <span class="comment">//the speed here refers to the above local variable</span></span><br><span class="line">        <span class="built_in">this</span>.speed = s; <span class="comment">// If we want to set object variable, use this.speed to refer object variable speed</span></span><br><span class="line">        direction = dir; <span class="comment">//dir is a reference to object, not the object itself</span></span><br><span class="line">        numVehicle++;   <span class="comment">//increase the Vehicle number</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123; <span class="comment">// Destructor, called when the object is garbage collected by JVM</span></span><br><span class="line">        System.out.println (<span class="string">&quot;finalize has been called&quot;</span>);</span><br><span class="line">        numVehicle--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setSpeed</span><span class="params">(<span class="type">int</span> newSpeed)</span> &#123; <span class="comment">// Object Method</span></span><br><span class="line">        <span class="built_in">this</span>.speed = newSpeed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setDir</span><span class="params">(String dir)</span> &#123; <span class="comment">// Object Method</span></span><br><span class="line">        <span class="built_in">this</span>.direction = dir;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getSpeed</span><span class="params">()</span> &#123; <span class="comment">// Object Method</span></span><br><span class="line">        <span class="keyword">return</span> speed;</span><br><span class="line">    &#125;</span><br><span class="line">    String <span class="title function_">getDir</span><span class="params">()</span> &#123; <span class="comment">// Object Method</span></span><br><span class="line">        <span class="keyword">return</span> direction;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">totalVehicle</span><span class="params">()</span> &#123; <span class="comment">// Class Method</span></span><br><span class="line">        <span class="keyword">return</span> numVehicle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.geeksforgeeks.org/differences-jdk-jre-jvm/">https://www.geeksforgeeks.org/differences-jdk-jre-jvm/</a><br><a href="https://programming.im.ncnu.edu.tw/J_index.html">https://programming.im.ncnu.edu.tw/J_index.html</a></p>
]]></content>
      <categories>
        <category>Java Learning</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 自學筆記 02 - OOP</title>
    <url>/posts/java-learning-02/</url>
    <content><![CDATA[<p><img src="/../images/2024/03/18/java_oop.png" alt="Java OOP"></p>
<p>Java 是一個物件導向的程式語言，重點在於如何定義物件之間的互動，Object Oriented Programming (OOP) 的三大特性分別是: <strong>Encapsulation (封裝)<strong>、</strong>Inheritance (繼承)</strong> 與 <strong>Polymorphism (多型)</strong> 。</p>
<span id="more"></span>

<h2 id="Encapsulation-封裝"><a href="#Encapsulation-封裝" class="headerlink" title="Encapsulation (封裝)"></a>Encapsulation (封裝)</h2><p>所謂封裝 (Encapsulation)，是指 class A 的設計者可以指定其他的 class 能否存取 A 的某個 member。</p>
<h3 id="Access-Modifier"><a href="#Access-Modifier" class="headerlink" title="Access Modifier"></a>Access Modifier</h3><p>類別中每個 member 的權限都是分開控制的，存取範圍的大小是 public &gt; protected &gt; package &gt; private。</p>
<ul>
<li><strong>private</strong>: 只有 A 自己才可以存取，使用 keyword <strong>private</strong></li>
<li><strong>package (default)</strong>: 只有和 A 同一個 package 的 class 才可以存取，沒有相對應的 keyword </li>
<li><strong>protected</strong>: 只有同一個 package 或是 A 的子類別才可以存取，使用 keyword <strong>protected</strong></li>
<li><strong>public</strong>: 所有的 class 都可以存取，使用 keyword <strong>public</strong></li>
</ul>
<h3 id="Package"><a href="#Package" class="headerlink" title="Package"></a>Package</h3><p>對應到資料夾名稱，不同層的資料夾視為不同封包:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> math;</span><br><span class="line"><span class="keyword">package</span> math.geometry;</span><br></pre></td></tr></table></figure>
<p>要使用封包內的類別:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math.BasicMath;</span><br><span class="line"><span class="keyword">import</span> math.geometry.*;</span><br></pre></td></tr></table></figure>

<h2 id="Inheritance-繼承"><a href="#Inheritance-繼承" class="headerlink" title="Inheritance (繼承)"></a>Inheritance (繼承)</h2><p>Java 使用關鍵字 extends 來表達繼承，若 class 宣告時沒有指定 extends，則 Java 會自動 extends <strong>java.lang.Object</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">moveMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Unspecified&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">moveMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Fly&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Override-覆寫"><a href="#Override-覆寫" class="headerlink" title="Override (覆寫)"></a>Override (覆寫)</h3><p>子類別重新定義它所能看到的父類別中的 method (如 public、protected，如果子類別和父類別在同一個 package 裡，則沒有修飾字的 method 也可以)，稱為 override。</p>
<ul>
<li>如果子類別看不到父類別的方法 (如父類別的 private 方法，或子父類別不在同一個 package 而子類別定義了父類別內的 package method)，則就算定義了同樣的 method 也不是 override</li>
<li>重複定義 static method 也不算 override</li>
<li>子類別不可縮小父類別方法的存取範圍</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C1</span> <span class="keyword">extends</span> <span class="title class_">C2</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123; <span class="comment">// Compile Error，不得縮小存取範圍 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="final-修飾字"><a href="#final-修飾字" class="headerlink" title="final 修飾字"></a>final 修飾字</h3><p>final 除可用來修飾變數外，也可放在 class 和 object method 前面:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FinalClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">finalMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>final 放在 class 前面表示 class 不可被繼承，放在 object method 表示不可被 Override。</p>
<h2 id="Polymorphism-多形"><a href="#Polymorphism-多形" class="headerlink" title="Polymorphism (多形)"></a>Polymorphism (多形)</h2><h3 id="UpCasting-向上轉型"><a href="#UpCasting-向上轉型" class="headerlink" title="UpCasting (向上轉型)"></a>UpCasting (向上轉型)</h3><p>子類別可以向上相容於父類別，舉例來說，Bird 是一種 Animal，所以可以順利向上轉型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal a;</span><br><span class="line">Bird b;</span><br><span class="line">a = b; <span class="comment">//upcasting, Bird is a kind of Animal</span></span><br></pre></td></tr></table></figure>
<h3 id="DownCasting-向下轉型"><a href="#DownCasting-向下轉型" class="headerlink" title="DownCasting (向下轉型)"></a>DownCasting (向下轉型)</h3><p>相反的，父類別並不能像下相容子類別，因為 Animal 並不一定都是 Bird，如果要向下轉型必須要強制 casting。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>(); <span class="comment">//upcasting</span></span><br><span class="line">Bird b;</span><br><span class="line">b = (Bird) a; <span class="comment">//downcasting, compile correct</span></span><br><span class="line"><span class="keyword">if</span> (a <span class="keyword">instanceof</span> Bird) &#123; <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>InheritanceExample.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritanceExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] argv)</span> &#123;</span><br><span class="line">        Animal a1, a2, a3, a4;</span><br><span class="line">        Bird b;</span><br><span class="line">        Dog d;</span><br><span class="line">        Fish f;</span><br><span class="line">        a2 = a1 = <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        b = <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">        d = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        f = <span class="keyword">new</span> <span class="title class_">Fish</span>();</span><br><span class="line">        System.out.println (a1.moveMethod ());</span><br><span class="line">        System.out.println (b.moveMethod ());</span><br><span class="line">        System.out.println (d.moveMethod ());</span><br><span class="line">        System.out.println (f.moveMethod ());</span><br><span class="line">        a1 = b; <span class="comment">// Correct, we call this upcasting</span></span><br><span class="line">        b = a1; <span class="comment">// Compile Error, type not compatible</span></span><br><span class="line">        b = (Bird) a1; <span class="comment">//downcasting, Compile Correct</span></span><br><span class="line">        a2 = b; <span class="comment">// Correct,we call this upcasting</span></span><br><span class="line">        d = a2; <span class="comment">// Compile Error, type not compatible</span></span><br><span class="line">        d = (Dog) a2; <span class="comment">// Compile Correct, but runtime error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="instanceof-關鍵字"><a href="#instanceof-關鍵字" class="headerlink" title="instanceof 關鍵字"></a>instanceof 關鍵字</h2><p>用來判斷某 reference 所指到的物件與類別是否相容 (including upcasting):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object ref;</span><br><span class="line">ref = <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line"><span class="keyword">if</span> (ref <span class="keyword">instanceof</span> Animal) &#123; <span class="comment">//correct</span></span><br><span class="line">    System.out.println (<span class="string">&quot;ref is currently pointing to an Animal Object.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Virtual-Function-虛擬函數"><a href="#Virtual-Function-虛擬函數" class="headerlink" title="Virtual Function (虛擬函數)"></a>Virtual Function (虛擬函數)</h3><p>當父類別 reference 到子類別的 object，ex: <code>Animal a = new Bird ()</code>，如果子類別 override 父類別的 method，java 會呼叫子類別的方法，也就是 Virtual Function，(如果是呼叫父類別的方法就是 Non-Virtual Function)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritanceExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] argv)</span> &#123;</span><br><span class="line">        Animal a1;</span><br><span class="line">        a1 = <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        System.out.println (a1.moveMethod ()); <span class="comment">//print out &quot;Unspecified&quot;</span></span><br><span class="line">        a1 = <span class="keyword">new</span> <span class="title class_">Bird</span>(); <span class="comment">//polymorphism</span></span><br><span class="line">        System.out.println (a1.moveMethod ()); <span class="comment">//print out &quot;Fly&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意 override 的範圍，只有被 override 的 method 才會呼叫 virtual function，舉例來說，static method 、private method 不能被 override，所以也不會有 virtual function。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">moveMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Unspecified&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] argv)</span> &#123;</span><br><span class="line">        Animal a1;</span><br><span class="line">        a1 = <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">        System.out.println (a1.moveMethod ()); <span class="comment">//print out &quot;Unspecified&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">//this is not override because Bird can&#x27;t see Animal&#x27;s moveMethod</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">moveMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Fly&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://programming.im.ncnu.edu.tw/J_index.html">https://programming.im.ncnu.edu.tw/J_index.html</a></p>
]]></content>
      <categories>
        <category>Java Learning</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 自學筆記 03 - Interface &amp; Abstract</title>
    <url>/posts/java-learning-03/</url>
    <content><![CDATA[<p><img src="/../images/2024/03/19/java_interface_abstract.png" alt="Interface &amp; Abstract"></p>
<p>OOP 除了有 Encapsulation、Inheritance 與 Polymorphism 三大要素外，<strong>Interface</strong> 與 <strong>Abstract</strong> 也是 OOP 中的重要概念。 </p>
<span id="more"></span>

<h2 id="Interface-介面"><a href="#Interface-介面" class="headerlink" title="Interface (介面)"></a>Interface (介面)</h2><p>因為 java 的 class 不能多重繼承，所以發展出 Interface:</p>
<h3 id="宣告-interface"><a href="#宣告-interface" class="headerlink" title="宣告 interface"></a>宣告 interface</h3><p>interface 裡的變數都是 <strong>piblic</strong>、<strong>static</strong> 以及 <strong>final</strong> 的<br>interface 裡的方法則是 <strong>public</strong> 以及 <strong>abstract</strong> 的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Listener</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14149</span>; <span class="comment">// 同 public static final</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span>; <span class="comment">// 同 public abstract</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnalbe</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PERIOD</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>; <span class="comment">// 注意這裡只有 ()，沒有 &#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AnotherRun</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PERIOD</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">run</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Interface-的繼承"><a href="#Interface-的繼承" class="headerlink" title="Interface 的繼承"></a>Interface 的繼承</h3><p>Interface 可以多重繼承</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ActionListener</span> <span class="keyword">extends</span> <span class="title class_">Listener</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MultiInterface</span> <span class="keyword">extends</span> <span class="title class_">Listener</span>, Runnalbe &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Class-實作-Interface"><a href="#Class-實作-Interface" class="headerlink" title="Class 實作 Interface"></a>Class 實作 Interface</h3><p>** 相同變數名稱 **: 用 interfaceA.var 以及 interfaceB.var 區分<br>** 相同函數名稱 **: 實作一次就好</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">Listener</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">Listener</span>, Runnable &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">implements</span> <span class="title class_">MultiInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>, AnotherRun &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">run</span><span class="params">(<span class="type">int</span> period)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Abstarct-抽象"><a href="#Abstarct-抽象" class="headerlink" title="Abstarct (抽象)"></a>Abstarct (抽象)</h2><p>只有參數宣告，沒有實作的方法，稱為 abstract method。</p>
<ul>
<li>** 具有 abstract method 的 class 必須宣告為 abstract class。**</li>
<li>繼承 abstract class 的子類別必須 <strong>override 所有父類別的 abstract method</strong>，否則子類別也必須宣告為 abstract class。</li>
<li>實作 Interface A 的 Class 必須 ** 實作 A 裡的所有 method**，否則必須宣告自己為 abstract class。</li>
<li>** 不能直接 new abstract class**，只能 new 其非 abstract class 的子類別。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractExample</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">abstract</span> <span class="title function_">abstractMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractExample</span><span class="params">()</span> &#123;</span><br><span class="line">        x = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span> &#123; <span class="comment">//must override this method, or SubClass be declared as abstract class</span></span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] argv)</span> &#123;</span><br><span class="line">        <span class="type">AbstractExample</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubClass</span>(); <span class="comment">//correct</span></span><br><span class="line">        a.abstractMethod (); <span class="comment">//virtual function, call SubClass&#x27;s abstractMethod</span></span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">AbstractExample</span>(); <span class="comment">// Compile error, you can&#x27;t new abstract class</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://programming.im.ncnu.edu.tw/J_index.html">https://programming.im.ncnu.edu.tw/J_index.html</a></p>
]]></content>
      <categories>
        <category>Java Learning</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB 概念介紹 + PyMongo 基本 CRUD 操作教學</title>
    <url>/posts/pymongo/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="/../images/2023/05/05/cover.png" alt="cover image"></p>
<p>因為課堂專案的關係需要用到 MongoDB 所以小學了一下，發現 MongoDB 真的是很香，撇開資料庫易用性，光是 MongoDB Atlas 提供每位使用者免費 10GB 的雲端資料庫空間 (免填信用卡)，就很值得你辦個帳號來玩一下了。這篇文章會簡單介紹一下 MongoDB，以及如何用 python PyMongo 完成資料庫的 CRUD 操作。</p>
<span id="more"></span>

<h1 id="MongoDB-Atlas"><a href="#MongoDB-Atlas" class="headerlink" title="MongoDB Atlas"></a>MongoDB Atlas</h1><p>MongoDB Atlas 是 MongoDB 的雲端資料庫平台服務，顧名思義你可以把你的資料存在雲端裡面，如果你是用 drivers (ex: python, nodejs…) 連線進去的話，基本上就是安裝個套件就搞定了，不用額外去下載或是設定一些雜七雜八的東西真的很方便，另外也因為是雲端服務，因此在團隊成員要連線進來也很容易，拿來 run 一個課堂專案是綽綽有餘了。</p>
<p>因為文章重點會放在 MongoDB 的觀念與操作，這裡就提供一篇教學讓大家自己看: </p>
<ul>
<li><a href="https://www.tpisoftware.com/tpu/articleDetails/2758" title="{rel=&#39;nofollow&#39;}">如何快速地架好自己的 MongoDB - MongoDB Atlas 介紹</a></li>
</ul>
<p>其實就是跟著指示做，都挺直覺的，雲端供應商的部分我也是選 GCP，因為有台灣的 region，這邊唯一要注意的是可連線 IP 的部分，要把 IP 地址加入名單中才能成功與資料庫建立連線，有個小撇步是只要在名單中加入 <code>0.0.0.0</code>，就可以無視當前 IP 位址隨便連了～</p>
<h1 id="MongoDb-Introduction"><a href="#MongoDb-Introduction" class="headerlink" title="MongoDb Introduction"></a>MongoDb Introduction</h1><h2 id="Datebase-architecture"><a href="#Datebase-architecture" class="headerlink" title="Datebase architecture"></a>Datebase architecture</h2><p>MongoDB 屬於 <strong>General Purpose Document Database</strong>(文件資料庫)，先來了解一下幾個關鍵字:</p>
<blockquote>
<p><strong>Document</strong>: Basic unit of data<br><strong>Collection</strong>: A grouping of documents<br><strong>Database</strong>: A container for collections</p>
</blockquote>
<h2 id="Document-Model"><a href="#Document-Model" class="headerlink" title="Document Model"></a>Document Model</h2><p>document 是 MongoDB 的基本資料單位，每個 document 都以 BSON 格式儲存 (類似 JSON 格式，但多了一些特殊的資料型態)，與關連式資料庫不同，MongoDB 有 polymorphic documents 的特性，沒有寫死的 schema，使用時不需要事先定義欄位、資料型態，相反的你想怎麼存就怎麼存，同個 collection 裡的 document 可以長的完全不一樣，**BUT!!!**，有彈性不代表就可以亂存，還是要視實際的使用情境來設計 schema 才不會害到自己喔。</p>
<h2 id="Data-Modeling"><a href="#Data-Modeling" class="headerlink" title="Data Modeling"></a>Data Modeling</h2><p>延續前面提到的 schema，究竟該如何設計一個好的 schema，MongoDB 有提供兩個非常明確的原則</p>
<blockquote>
<p>Thinking about the application rather than thinking about how it’s stored.<br>Data accessed together should be stored todether.</p>
</blockquote>
<p>第一點是在說我們在設計資料庫 schema 時應該 focus 在「我們的 application 如何取用資料」，而不是「如何把資料存好」。<br>第二點則是與 MongoDB 的架構有關，因為資料都是以 document 為單位，因此把會一起使用到的資料都存在同一個 document 裡面，通常會比存在兩個分別的 document 裡面來的方便取用。</p>
<h2 id="Relationship-types"><a href="#Relationship-types" class="headerlink" title="Relationship types"></a>Relationship types</h2><p>照上面這麼說的話，那簡單，全部塞進同個 document 就對了嗎？其實也不對，因為每個 documnet 其實有 16MB 的 size limit，所以我們還是要視情況來建立我們的關聯規則，以下介紹 3 種關聯規則以及 MongoDB 的建議的儲存方法。</p>
<ol>
<li>one to one<br>顧名思義就是一個對一個，以學生資料來說，每位學生都有自己獨特且唯一學號，這時候我們就沒必要把學號另外存在別的 document，直接存在一起就好。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#x27;_id&#x27;: ObjectID (...),  # MongoDB 預設的_id 格式，沒有設定_id 的話會自動 assign</span><br><span class="line">  &#x27;Name&#x27;: &#x27;Jack&#x27;,</span><br><span class="line">  &#x27;Mobile&#x27;: &#x27;0800-000000&#x27;,</span><br><span class="line">  &#x27;ID&#x27;: &#x27;A0001&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>one to many<br>現在假設我們還需要存每位學生的家長資料，畢竟每個人的家長資料肯定是不重複的嘛，所以我們還是想存在同一個 document 裡，這時候我們可以使用 <strong>Embedding</strong> 的技巧，簡單來說就是巢狀結構加下去就對了 XD。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#x27;_id&#x27;: ObjectID (...),</span><br><span class="line">  &#x27;Name&#x27;: &#x27;Jack&#x27;,</span><br><span class="line">  &#x27;Mobile&#x27;: &#x27;0800-000000&#x27;,</span><br><span class="line">  &#x27;ID&#x27;: &#x27;A0001&#x27;,</span><br><span class="line">  &#x27;Parents&#x27;: &#123;</span><br><span class="line">    &#x27;Dad&#x27;: &#123;&#x27;Name&#x27;: &#x27;Bob&#x27;, &#x27;Mobile&#x27;: &#x27;0800-000001&#x27;&#125;,</span><br><span class="line">    &#x27;Mom&#x27;: &#123;&#x27;Name&#x27;: &#x27;Amy&#x27;, &#x27;Mobile&#x27;: &#x27;0800-000002&#x27;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>many to many<br>繼續前面例子，每個學生每學期都會修很多課，並且同一堂課會有很多學生一起修，這時候我們如果用 Embedding 的話雖然很方便，但有點太浪費資料庫空間了，會出現很多重複的資料，這時我們可以視情況使用 <strong>Referencing</strong> 的技巧，基本上跟 Embedding 很像，改成存用來 join 的 key。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#x27;_id&#x27;: ObjectID (...),</span><br><span class="line">  &#x27;Name&#x27;: &#x27;Jack&#x27;,</span><br><span class="line">  &#x27;Mobile&#x27;: &#x27;0800-000000&#x27;,</span><br><span class="line">  &#x27;ID&#x27;: &#x27;A0001&#x27;,</span><br><span class="line">    &#x27;Parents&#x27;: &#123;</span><br><span class="line">    &#x27;Dad&#x27;: &#123;&#x27;Name&#x27;: &#x27;Bob&#x27;, &#x27;Mobile&#x27;: &#x27;0800-000001&#x27;&#125;,</span><br><span class="line">    &#x27;Mom&#x27;: &#123;&#x27;Name&#x27;: &#x27;Amy&#x27;, &#x27;Mobile&#x27;: &#x27;0800-000002&#x27;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x27;courses&#x27;: [ObjectID (...), ObjectID (...), ...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>要注意的是 Embedding 跟 Referencing 的使用時機是看情況決定！不是 one to many 就一定要用 Embedding，也不是 many to many 就一定要用 Referencing，還要考慮 ** 資料規模 **，如果 one to many，但連出去的資料非常龐大，那一樣要改用 Referencing 才存得下。</p>
<h1 id="CRUD-in-PyMongo"><a href="#CRUD-in-PyMongo" class="headerlink" title="CRUD in PyMongo"></a>CRUD in PyMongo</h1><p>以防有人不知道 CRUD 是什麼，CRUD 對應到 database 的 4 個基本操作 Create、Read、Update、Delete，要在 MongoDB 操作 CRUD 有很多方法，除了使用 MogoDB 自己的 CLI 外，官方也提供豐富的 <a href="https://www.mongodb.com/docs/drivers/" title="{rel=&#39;nofollow&#39;}">libraries</a>，以 python 來說就有兩個 libraries，PyMongo 負責處理同步連線、Motor 負責處理非同步連線，接下來會介紹如何使用 PyMongo 來操作 CRUD。</p>
<h2 id="Beforehand"><a href="#Beforehand" class="headerlink" title="Beforehand"></a>Beforehand</h2><p>第一步當然是要先安裝套件:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">! pip install pymongo</span><br></pre></td></tr></table></figure>

<p>接著我們 import 套件並建立連線:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line">client = MongoClient (CONNECTION_STRING)</span><br></pre></td></tr></table></figure>
<p>其中，<code>CONNECTION_STRING</code> 的格式長這樣，記得要換成自己的帳號、密碼:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongodb+srv://&lt;user_name&gt;:&lt;password&gt;@thrifty.0xdedx2.mongodb.net/?retryWrites=true&amp;w=majority</span><br></pre></td></tr></table></figure>
<p>這串東西好長喔記不起來怎麼辦？進入 mongodb atlas 後，可以在 Connect → Drivers → python 裡找到<br><img src="/../images/2023/05/05/mongodb_atlas_connect.png" alt="mongodb atlas connect"><br><img src="/../images/2023/05/05/mongodb_atlas_connection_string.png" alt="mongodb atlas connection string"></p>
<p>我們可以直接透過 client 物件來建立或取用 database，可以使用 key-value 的方式或呼叫 object 的方式，舉例來說我想要 create 一個名叫 test_database 的 database，那我可以用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">database = client.test_database <span class="comment"># or</span></span><br><span class="line">database = client [<span class="string">&#x27;test_database&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>同理，我們可以透過 db 物件來建立或取用 collection:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">collection = database.test_collection <span class="comment"># or</span></span><br><span class="line">collection = database [<span class="string">&#x27;test_collection&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>好了，事前工作準備完成！</p>
<h2 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h2><p>在 PyMongo 中，我們可以使用 <code>insert_one</code>&#x2F;<code>insert_many</code> 來插入新的 document:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 要插入的資料 </span></span><br><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line">b = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line">c = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;female&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">collection.insert_one (a)       <span class="comment"># 插入一個檔案 </span></span><br><span class="line">collection.insert_many ([b, c]) <span class="comment"># 插入多個檔案 </span></span><br></pre></td></tr></table></figure>

<h2 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h2><p>在 PyMongo 中，我們可以使用 <code>find_one</code> 或 <code>find</code> 來尋找一個或多個的 document:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># find_one 會回傳符合條件的第一筆資料 (沒放條件的話就是 collection 的第一筆 doc)</span></span><br><span class="line">collection.find_one ()</span><br><span class="line"></span><br><span class="line"><span class="comment"># find 會回傳所有符合條件的資料，並將其包裝為一個類似 iterator 的物件 (沒放條件的話就是 collection 裡所有 doc)</span></span><br><span class="line">docs = collection.find ()</span><br><span class="line"><span class="comment"># 我們可以將該物件放入 for 迴圈中查看結果 </span></span><br><span class="line"><span class="keyword">for</span> doc <span class="keyword">in</span> docs:</span><br><span class="line">  <span class="built_in">print</span>(doc)</span><br></pre></td></tr></table></figure>

<p>我們可以在 function 中加入條件，來查找符合條件的資料，因為操作都差不多，所以接下來只用 <code>find_one</code> 做示範。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">collection.find_one (&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;a&#x27;</span>&#125;)</span><br><span class="line">collection.find_one (&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;) <span class="comment"># 可以放多個條件 </span></span><br></pre></td></tr></table></figure>
<p>上面的代碼會幫我們找到 name 等於 a 的資料，但其實這是一個簡化的寫法，MongoDB 在進行條件篩選時通常會透過 <strong>Comparison Operators</strong> 的幫忙，實際上完整的寫法長這樣:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">collection.find_one (&#123;<span class="string">&#x27;name&#x27;</span>: &#123;<span class="string">&#x27;$eq&#x27;</span>: <span class="string">&#x27;a&#x27;</span>&#125;, <span class="string">&#x27;gender&#x27;</span>: &#123;<span class="string">&#x27;$eq&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>這裡的 <code>$eq</code> 就是 equal to 的意思，因為是最基本的操作所以可以直接不寫，另外還有很多用於條件判斷的 operator，舉例來說:</p>
<blockquote>
<p><code>$gt</code> : greater to<br><code>$lt</code> : lower to<br><code>$gte</code> : greater or equal to<br><code>$lte</code> : lower or equal to<br><code>$ne</code> : not equal to</p>
</blockquote>
<p>除了 <strong>Comparison Operators</strong> 外，在處理多個條件時，我們通常需要使用 <strong>Logical Operators</strong> 來幫助我們做多條件的判斷，上面例子同樣因為是基本操作所以可以直接寫，實際上也可以這樣寫:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">collection.find_one (&#123;<span class="string">&#x27;$and&#x27;</span>: [&#123;<span class="string">&#x27;name&#x27;</span>: &#123;<span class="string">&#x27;$eq&#x27;</span>: <span class="string">&#x27;a&#x27;</span>&#125;&#125;, &#123;<span class="string">&#x27;gender&#x27;</span>: &#123;<span class="string">&#x27;$eq&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;&#125;]&#125;)</span><br></pre></td></tr></table></figure>
<p>基本上跟一般程式語言的用法很像，常見的有:</p>
<blockquote>
<p><code>$or</code> : or<br><code>$not</code> : not</p>
</blockquote>
<p>上面只介紹了部分的 query operators，想了解更多 query operators 可以參考 <a href="https://www.mongodb.com/docs/manual/reference/operator/query/" title="{rel=&#39;nofollow&#39;}">這裡</a>。</p>
<h2 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h2><p>PyMongo 中用來更新 document 的 function 有三大類，分別是</p>
<ol>
<li><code>replace_one</code></li>
<li><code>update_one</code>&#x2F;<code>update_many</code></li>
</ol>
<p>差別在於 replace 會把整個 documnet 都取代為新的，update 則只會去更新 document 中被指定的部分。兩者在使用上都由三個部分組成，分別是 filter、replacement&#x2F;update 和 options，其中 filter 是篩選的條件，寫法跟前面 find 一樣，replacement&#x2F;update 是要更新的 document &#x2F; 部分 document，options 則是更新時可以設定的選項。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># template</span></span><br><span class="line">collection.replace_one (<span class="built_in">filter</span>, replacement, options) <span class="comment"># 取代符合條件的資料的第一筆資料 </span></span><br><span class="line">collection.update_one (<span class="built_in">filter</span>, update, options)       <span class="comment"># 更新符合條件的第一筆資料 </span></span><br><span class="line">collection.update_many (<span class="built_in">filter</span>, update, options)      <span class="comment"># 更新符合條件的所有資料 </span></span><br></pre></td></tr></table></figure>
<p>要特別留意的是，在 update 的部分一定要搭配使用 <strong>Update Operators</strong>，否則會執行失敗！常用的 operators 有:</p>
<blockquote>
<p><code>$set</code> : set to new value<br><code>$push</code>: appends value to an array<br><code>$inc</code> : increased by value</p>
</blockquote>
<p>最後 options 部分，這邊只提最常被使用到的 <code>upsert</code>(update+insert)，預設為 <code>False</code>，如果將 <code>upsert</code> 設為 <code>True</code> 的話，那就算 filter 部分沒有找到符合的 document，也會順便幫我們執行 insert 的動作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 尋找 name 為 d 的 document 並取代為新 documnet，因為沒有這個 document 而且 upsert=True，所以會直接 insert</span></span><br><span class="line">collection.replace_one (&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;d&#x27;</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;arr&#x27;</span>: []&#125;, upsert=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 將 name 重新命名 </span></span><br><span class="line">collection.update_one (&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;d&#x27;</span>&#125;, &#123;<span class="string">&#x27;$set&#x27;</span>: &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;e&#x27;</span>&#125;&#125;)</span><br><span class="line"><span class="comment"># 把 item 推入 array 當中 </span></span><br><span class="line">collection.update_one (&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;e&#x27;</span>&#125;, &#123;<span class="string">&#x27;$push&#x27;</span>: &#123;<span class="string">&#x27;arr&#x27;</span>: <span class="string">&#x27;item&#x27;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h2><p>PyMongo 中用來刪除 document 的 function 是 <code>delete_one</code> 與 <code>delete_many</code>，用法跟 find 基本一樣～</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">collection.delete_one (&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;a&#x27;</span>&#125;)  <span class="comment"># 刪除符合條件的第一筆資料 </span></span><br><span class="line">collection.delete_many (&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;a&#x27;</span>&#125;) <span class="comment"># 刪除符合條件的所有資料 </span></span><br></pre></td></tr></table></figure>


<h2 id="bulk-write"><a href="#bulk-write" class="headerlink" title="bulk_write"></a>bulk_write</h2><p>前面的操作都一次針對一個條件進行動作，假如我們想要快速地執行多個不同動作該怎麼辦呢？這時我們可以將原先的 CRUD 指令包裝成 Object，並透過 <code>bulk_write</code> 來進行批次操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> InsertOne, DeleteMany, ReplaceOne, UpdateOne</span><br><span class="line">result = colection.bulk_write ([</span><br><span class="line">    DeleteMany (&#123;&#125;),</span><br><span class="line">    InsertOne (&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;),</span><br><span class="line">    InsertOne (&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;),</span><br><span class="line">    InsertOne (&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;female&#x27;</span>&#125;),</span><br><span class="line">    ReplaceOne (&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;d&#x27;</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;arr&#x27;</span>: []&#125;, upsert=<span class="literal">True</span>),</span><br><span class="line">    UpdateOne (&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;d&#x27;</span>&#125;, &#123;<span class="string">&#x27;$set&#x27;</span>: &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;e&#x27;</span>&#125;&#125;),</span><br><span class="line">    UpdateOne (&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;e&#x27;</span>&#125;, &#123;<span class="string">&#x27;$push&#x27;</span>: &#123;<span class="string">&#x27;arr&#x27;</span>: <span class="string">&#x27;item&#x27;</span>&#125;&#125;)</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>MongoDB 在網路上的教學資源真的很豐富，官方也有提供 <a href="https://learn.mongodb.com/" title="{rel=&#39;nofollow&#39;}">免費課程</a>，想要上手真的不是一件難事，我都邊寫邊懷疑自己寫這篇到底有多大價值，因為網路上其他地方大概也都找的到類似的內容，不過抱持著當做筆記說不定哪天旺季會想回來看的精神，還是乖乖把他寫完了 XDDD</p>
]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>PyMongo</tag>
      </tags>
  </entry>
  <entry>
    <title>系統架構筆記 - 垂直擴展、水平擴展</title>
    <url>/posts/scaling/</url>
    <content><![CDATA[<p><img src="/../images/2024/01/17/scaling.png" alt="scaling"></p>
<p>這篇文章會介紹垂直擴展以及水平擴展，並以資料庫的水平擴展為延伸，介紹讀寫分離與資料庫切分 (Sharding)。</p>
<span id="more"></span>

<h1 id="垂直擴展"><a href="#垂直擴展" class="headerlink" title="垂直擴展"></a>垂直擴展</h1><p>這台機器不行那我就換一台更好的。<br>其實就是升級硬體，好處就是簡單直接，能用垂擴展解決那就優先考慮垂直擴展吧。但垂直擴展是有極限的，而且越好的機器越貴，這時就可以考慮水平擴展。</p>
<h1 id="水平擴展"><a href="#水平擴展" class="headerlink" title="水平擴展"></a>水平擴展</h1><p>一台機器不行那我就多用幾台。<br>要實現伺服器的水平擴展比較容易，不外乎就是多開幾台機器，然後做好 load balance，這裡重點介紹 ** 資料庫 ** 的水平擴展，大致上可以分為兩個策略：</p>
<h2 id="讀寫分離"><a href="#讀寫分離" class="headerlink" title="讀寫分離"></a>讀寫分離</h2><p>在原本的資料庫 (主節點) 外添加幾個從資料庫 (從節點) ，向主節點寫入資料，讀取時則優先自從節點讀取。讀寫分離會遇到幾個問題： </p>
<ol>
<li>** 最終一致性問題 **<br>  由於從節點的數據是自主節點同步過來，因此中間勢必存在一時間差，可能導致從節點的數據不是最即時的數據，因此從節點的數據僅滿足最終一致性。</li>
<li>** 單個主節點 **<br>  由於主節點仍然只有一個，如果遇到需要大量寫入的作業仍然會出現堵塞，這時候可能要考慮多個主節點的架構，不過就跟前一點一樣會遇到資料同步的問題，還需要考慮同時有多個寫入情況下的 race condition。</li>
</ol>
<h2 id="資料庫切分-Partitioning-x2F-Sharding"><a href="#資料庫切分-Partitioning-x2F-Sharding" class="headerlink" title="資料庫切分 (Partitioning &#x2F; Sharding)"></a>資料庫切分 (Partitioning &#x2F; Sharding)</h2><p>將一個資料庫 (大資料表) 分割為多個小資料表，並將其儲存在不同節點上，又可以分為 ** 垂直切分 ** 與 ** 水平切分 **：<br><img src="/../images/2024/01/17/sharding.png" alt="sharding"></p>
<h3 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h3><p>按照欄位來進行切分，通常可以按照業務功能來做切割，如電商平台中的買家資訊與賣家資訊就可以分開儲存。</p>
<h3 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h3><p>按照列來進行切分，主要有兩種切分方法：</p>
<ol>
<li>** 按一定範圍切分 **<br>舉例來說 ID &lt;&#x3D; 10000 為第一個表，接著每 10000 筆資料為一個表，這個做法的好處是 ** 容易新增表 **，壞處是 ** 較差的附載平衡 **，因為新資料與舊資料的活躍度可能有很大的差異。</li>
<li>** 使用哈希表切分 **<br>將 ID 放入一個 Hash Function 中，如 <code>10 % 3 = 1</code>，根據 Hash 結果找到對應的表，好處是有 ** 較佳的附載平衡 **，缺點是 ** 不容易新增表 <strong>，新增一個表通常涉及到 ** 修改 Hash Function</strong> 以及原先表的 ** 數據遷移 **。</li>
</ol>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><p><a href="https://www.digitalocean.com/community/tutorials/understanding-database-sharding">Understanding Database Sharding</a><br><a href="https://blog.csdn.net/Dongguabai/article/details/83578092">高并发（水平扩展，垂直扩展）</a><br><a href="https://www.twblogs.net/a/5c99f60fbd9eee434fc6c4d5">數據庫的向上擴展和橫向擴展（即水平擴展：讀寫分離、垂直切分、水平切分）</a></p>
]]></content>
      <categories>
        <category>(test)System Design</category>
      </categories>
      <tags>
        <tag>(test)Scaling</tag>
      </tags>
  </entry>
  <entry>
    <title>Spectral Clustering - 算法解析與 numpy 程式實作</title>
    <url>/posts/spectral-clustering/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="/../images/2023/04/27/cluster_analysis.jpg" alt="Spectral Clustering"></p>
<p>在社群網絡中分析中，有時候會想要找出網絡當中的社群 (community detection)，一個最直觀的想法是直接對網絡進行分群，那麼分群結果就是各個 community 了。<br>如果我們能夠計算各個節點之間的相似性，那麼我們當然可以直接套用傳統的分群方法，如 cosine similiarity，但一來是相似度特徵可能很難取得，二來是這樣分群的話就沒有利用到網絡的結構了，這時我們可以改為使用基於圖論的分群方法。<br>今天這篇文章會帶大家簡單瞭解什麼是 cut approach, balanced-cut approach 以及其代表方法 spectral clustering，並示範不依賴其他套件，僅使用 numpy 實作 spectral clustering。</p>
<span id="more"></span>

<h1 id="大綱"><a href="#大綱" class="headerlink" title="大綱"></a>大綱</h1><ul>
<li><a href="#Mini-cut-Approach">Mini-cut approach</a></li>
<li><a href="#Balanced-cut-Approach">Balanced-cut approach</a></li>
<li><a href="#Spectral-Clustering">Spectral clustering</a></li>
</ul>
<h1 id="內文"><a href="#內文" class="headerlink" title="內文"></a>內文</h1><h2 id="Mini-cut-Approach"><a href="#Mini-cut-Approach" class="headerlink" title="Mini-cut Approach"></a>Mini-cut Approach</h2><p>Cut approach，顧名思義是將網絡給切開來形成多個網絡，屬於 partitional clustering 的一種，每個節點只會屬於一個 community，並且 community 之間也不會 overlapping，而 Mini-cut Approach 則是希望在切割網絡時能最小化切掉的 edge 數量。<br>聽起來很直觀，但這樣切會有一個問題，那就是有可能會切出一些非常小的 community，導致分群不夠 balance。</p>
<h2 id="Balanced-cut-Approach"><a href="#Balanced-cut-Approach" class="headerlink" title="Balanced-cut Approach"></a>Balanced-cut Approach</h2><p>為了解決 Mini-cut Approach 的缺點，Balanced-cut Approach 在切割網絡時除了考量原本的 edge，另外除以 community 的 node 數做加權調整，切割的目標從最小化 edge 數轉為最小化 ratio cut，公式如下:<br><img src="/../images/2023/04/27/ratio_cut.png" alt="Ratio Cut formula"></p>
<p>公式解釋：分成 k 群 (k 要自己決定)，每次取一個群 <code>Pi</code> 出來看，分子部分表示將 <code>Pi</code> 切開的話會切到的 edge 數，分母部分表示 <code>Pi</code> 內部的 node 數，將 k 個群的結果加總起來就會是整個網路的 ratio cut 分數。</p>
<h3 id="Matrixs"><a href="#Matrixs" class="headerlink" title="Matrixs"></a>Matrixs</h3><p>為了要計算 Ratio Cut，我們先要來認識一下三種矩陣:</p>
<ol>
<li><p>Diagonal Degree Matrix 度數矩陣<br>Degree (度數) 指的是一個 node 有多少個鄰居，將這些 Degree 轉換為對角矩陣 (Diagonal Matrix) 就得到 Diagonal Degree Matrix。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D = np.array ([</span><br><span class="line">  [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>
</li>
<li><p>Adjacency Matrix 鄰接矩陣<br>只要是對 Graph 有些概念的人應該都對 Adjacency Matrix 不太陌生，Adjacency Matrix 描述了 node 之間的關係，下面例子假設 node 之間的關係都是雙向的，所以會是個對稱矩陣。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = np.array ([</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br></pre></td></tr></table></figure>
</li>
<li><p>Laplacian Matrix 調和矩陣 (拉普拉斯矩陣)<br>Laplacian Matrix 的算法就是直接將 Diagonal Degree Matrix 減去 Adjacency Matrix，聽起來可能讓人滿頭問號，為什麼要這麼做？這邊先賣個關子，繼續看下去就知道了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = np.array ([</span><br><span class="line">  [ <span class="number">2</span>, -<span class="number">1</span>,  <span class="number">0</span>,  <span class="number">0</span>, -<span class="number">1</span>,  <span class="number">0</span>,  <span class="number">0</span>],</span><br><span class="line">  [-<span class="number">1</span>,  <span class="number">4</span>, -<span class="number">1</span>, -<span class="number">1</span>,  <span class="number">0</span>,  <span class="number">0</span>, -<span class="number">1</span>],</span><br><span class="line">  [ <span class="number">0</span>, -<span class="number">1</span>,  <span class="number">2</span>, -<span class="number">1</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>],</span><br><span class="line">  [ <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>,  <span class="number">3</span>,  <span class="number">0</span>, -<span class="number">1</span>,  <span class="number">0</span>],</span><br><span class="line">  [-<span class="number">1</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">2</span>, -<span class="number">1</span>,  <span class="number">0</span>],</span><br><span class="line">  [ <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>,  <span class="number">3</span>, -<span class="number">1</span>],</span><br><span class="line">  [ <span class="number">0</span>, -<span class="number">1</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>, -<span class="number">1</span>,  <span class="number">2</span>]])</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Calculation"><a href="#Calculation" class="headerlink" title="Calculation"></a>Calculation</h3><p>現在先假設我們已經知道分群的結果了，並將結果以 0,1 的形式表示為一個 matrix，令這個結果為 X，下面結果是我隨便分的，分 3 群，<code>X [i][j]==1</code> 表示 node<code>i</code> 屬於 cluster<code>j</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = np.array ([</span><br><span class="line">  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br></pre></td></tr></table></figure>
<ol>
<li><p>Diagonal Degree Matrix 解釋<br>我們先將 X 的轉置矩陣與 D 做內積 (<code>X.T.dot (D)</code>):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array ([[<span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br></pre></td></tr></table></figure>
<p>觀察一下結果會發現，這個矩陣就只是是把 Degree 填到對應的 cluster 中而已。<br>接著我們再把上面結果與 X 做內積 (<code>X.T.dot (D).dot (X)</code>):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array ([[<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>]])</span><br></pre></td></tr></table></figure>
<p>這個結果其實就表示 ** 每個 cluster 的 degree 總和 **。</p>
</li>
<li><p>Adjacency Matrix 解釋<br>接著我們直接將上面公式的 D 換成 A (<code>X.T.dot (A).dot (X)</code>):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array ([[<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>
<p>會發現結果表示在 **cluster 與 cluster 間互相連接的 edge 數 **。</p>
</li>
<li><p>Laplacian Matrix 解釋<br>如果我們將兩個結果相減的話，會發現每一行的第 i 個元素 (對角) 就是我們想要計算的 cut 數 (分子部分)!!!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array ([[ <span class="number">4</span>, -<span class="number">2</span>, -<span class="number">2</span>],  <span class="comment"># i=0, 4</span></span><br><span class="line">       [-<span class="number">2</span>,  <span class="number">3</span>, -<span class="number">1</span>],  <span class="comment"># i=1, 3</span></span><br><span class="line">       [-<span class="number">2</span>, -<span class="number">1</span>,  <span class="number">3</span>]]) <span class="comment"># i=2, 3</span></span><br></pre></td></tr></table></figure>
<p>接著我們另外計算每個 cluster 裡面共有多少個 node，我們可以將 X 的轉置後與自己相乘 (<code>X.T.dot (X)</code>):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array ([[<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>
<p>最後將對角的結果相除後加起來就是算平均就得到 Ratio Cut 的分數啦～～～<br>(我這邊直接矩陣相除，大家可以自己算。)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array ([[ <span class="number">2.</span> , -inf, -inf],</span><br><span class="line">       [-inf,  <span class="number">1.</span> , -inf],</span><br><span class="line">       [-inf, -inf,  <span class="number">1.5</span>]])</span><br></pre></td></tr></table></figure></li>
</ol>
<p>根據上面矩陣運算的過程，我們能將公式重新整理為:<br><img src="/../images/2023/04/27/ratio_cut_2.png" alt="ratio cut formula extended"></p>
<p>在第三行的部分，我們另外對 X 進行標準化 (同除以分母) 變成了 <code>X prime</code>。</p>
<h3 id="Minimize"><a href="#Minimize" class="headerlink" title="Minimize"></a>Minimize</h3><p>回到最一開始的問題，我們的目標是要最小化 ratio cut 的分數，方法就是透過上面的公式去求解 <code>X prime</code> 矩陣，難過的是，還記的 X 矩陣裡最一開始只能填入 0 跟 1 嗎，想要在這樣嚴格的限制下求出最佳解是個 <strong>NP-hard</strong> 的問題。<br>不過不要灰心，我們還是可以放寬條件，套用近似演算法，其中一種方法就是接下來要介紹的 Spectral Clustering~~~</p>
<h2 id="Spectral-Clustering"><a href="#Spectral-Clustering" class="headerlink" title="Spectral Clustering"></a>Spectral Clustering</h2><p>Spectral Clustering 基於 ratio cut，不過 X 矩陣中可以填入的值變成介於 0~1 之間，在放寬條件後，這個最小化問題的解可以被證明是求解 Laplacian Matrix 的前 k 小個特徵值的特徵向量。</p>
<ol>
<li><p>Eigenvalue &amp; Eigenvactors<br>我們可以用 <code>np.linalg.eig</code> 來替我們計算特徵值與特徵向量，並使用 <code>np.argsort</code> 來替我們找出最小的 k 個特徵向量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># calculate eigenvalue and eigenvector</span></span><br><span class="line">eig_value, eig_vector = np.linalg.eig (L)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get eigenvector with smallest eigenvalue</span></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">top_k = np.argsort (eig_value)[:k]</span><br><span class="line">top_k_vector = eig_vector [:, top_k]</span><br></pre></td></tr></table></figure>
<p>得到的結果如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array ([[ <span class="number">0.37796447</span>, -<span class="number">0.45244521</span>, -<span class="number">0.41243936</span>],</span><br><span class="line">       [ <span class="number">0.37796447</span>,  <span class="number">0.17351892</span>, -<span class="number">0.08541899</span>],</span><br><span class="line">       [ <span class="number">0.37796447</span>,  <span class="number">0.54280925</span>, -<span class="number">0.41243936</span>],</span><br><span class="line">       [ <span class="number">0.37796447</span>,  <span class="number">0.32598548</span>, -<span class="number">0.08541899</span>],</span><br><span class="line">       [ <span class="number">0.37796447</span>, -<span class="number">0.58986844</span>, -<span class="number">0.08541899</span>],</span><br><span class="line">       [ <span class="number">0.37796447</span>, -<span class="number">0.09036404</span>,  <span class="number">0.37705765</span>],</span><br><span class="line">       [ <span class="number">0.37796447</span>,  <span class="number">0.09036404</span>,  <span class="number">0.70407803</span>]])</span><br></pre></td></tr></table></figure>
</li>
<li><p>K-means<br>由於得到的特徵值並無法直接拿來做解釋，因此 Spectral Clustering 另外使用了 K-means 來為這些特徵值做分群，因為最小的特徵值為 0、特徵向量一定是常數，所以我們可以把它刪去，也就是說，如果我們想要分成 k 群，那我們至少需要使用 k-1 個特徵向量。<br>下面程式提供一個簡單的 K-means 範例，可以根據自己的需求另外設置停止條件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">k_means</span>(<span class="params">X, k, max_iters=<span class="number">10000</span></span>):</span><br><span class="line">    <span class="comment"># randomly initialize centroids</span></span><br><span class="line">    centroids = X [np.random.choice (<span class="built_in">len</span>(X), k, replace=<span class="literal">False</span>)]</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(max_iters):</span><br><span class="line">       <span class="comment"># calculate distances</span></span><br><span class="line">       distances = np.linalg.norm (X [:, np.newaxis] - centroids, axis=<span class="number">2</span>)</span><br><span class="line">       <span class="comment"># assign labels </span></span><br><span class="line">       labels = np.argmin (distances, axis=<span class="number">1</span>)</span><br><span class="line">       <span class="comment"># calculate new centroids</span></span><br><span class="line">       centroids = np.array ([np.mean (X [labels == i], axis=<span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)])</span><br><span class="line">    <span class="keyword">return</span> labels</span><br><span class="line"></span><br><span class="line"><span class="comment"># remove first vector</span></span><br><span class="line">features = top_k_vector [:, <span class="number">1</span>:]</span><br><span class="line"><span class="comment"># do k-maens</span></span><br><span class="line">labels = k_means (features, k)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>這樣就得到分群結果啦～～～(注意：實際執行數字的順序可能不一樣)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array ([<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>], dtype=int64)</span><br></pre></td></tr></table></figure>

<h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>其實忽略到複雜的數學證明的話，Spectral Clustering 的概念還挺直觀的，文章參考了台大資管系的陳建錦教授所使用的上課講義，經過本人吸收轉化撰寫而成。</p>
]]></content>
      <categories>
        <category>Social Network Analysis</category>
      </categories>
      <tags>
        <tag>Graph</tag>
        <tag>Spectral Clustering</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie (字典樹) - Design Add and Search Words Data Structure</title>
    <url>/posts/trie-2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>寫完上一篇 <a href="/posts/trie/">Implement Trie (字典樹)</a> 後，沒過兩天 LeetCode 每日一題又出現 Trie 的題目了 (笑)，題目是 <a href="https://leetcode.com/problems/design-add-and-search-words-data-structure/">211. Design Add and Search Words Data Structure</a>，簡單來說就是字典樹加上一點正規表達 (regular expression) 的概念，舉例來說 trie 裡有 <code>bad</code>，那搜尋 <code>b.d</code> 的話也要回傳 <code>true</code>，詳細題目一樣自己到 LeetCode 去看囉。</p>
<span id="more"></span>

<h1 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h1><p>如果不考慮正規表達的話，那其實就是最基本的 Trie，還不了解 trie 的話可以參考前一篇文章！但現在多了這個特殊條件後，我們就需要去考慮所有可能，方法是寫一個 dfs (Depth First Search) 的輔助函式，遇到 <code>.</code> 的話就將當前節點下的所有子節點再帶入 dfs，看最後有沒有符合的單字，只要有其中一個子節點符合的話會提前回傳 <code>true</code>，都沒有的話就回傳 <code>false</code>。</p>
<p>我們以下面的圖片來說明步驟，假設我們今天搜尋 <code>b.t</code>：</p>
<ol>
<li>跟一般的 trie 一樣，我們會先確認 root 下有沒有 b 這個節點，有的話就走到這個節點上。</li>
<li>因為第二個字是 <code>.</code>，表示 <code>ba</code> 跟 <code>bo</code> 都是我們可以走的路徑，因此我們兩條路都要去訪問，依字母順序我們先訪問 <code>ba</code>。</li>
<li><code>ba</code> 下面雖然有節點 <code>bat</code>，但他不是單字的結尾，所以我們跳出這條路徑。</li>
<li>我們回到上一層，改走 <code>bo</code> 這條路徑。</li>
<li><code>bot</code> 符合我們要找的答案，並且他也是單字的結尾，因此回傳 <code>true</code>。</li>
</ol>
<p><img src="/../images/2023/03/20/trie.png" alt="trie"></p>
<h1 id="方法一-Pointers-C"><a href="#方法一-Pointers-C" class="headerlink" title="方法一: Pointers (C++)"></a>方法一: Pointers (C++)</h1><p>重點</p>
<ul>
<li>dfs 除了要傳入節點 <code>curr</code>，也要記錄目前走到第單字中的第幾個位置 <code>start</code>。</li>
<li>遇到 <code>.</code> 的話就對所有可能路徑再做一次 dfs。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    Node* children [<span class="number">26</span>];</span><br><span class="line">    <span class="type">bool</span> is_end = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node* root;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string word;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(Node* curr, <span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=start; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="comment">// 遇到 .</span></span><br><span class="line">            <span class="keyword">if</span> (word [i] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">// 用迴圈造訪所有可能路徑 </span></span><br><span class="line">                <span class="keyword">for</span> (Node* next: curr-&gt;children)&#123;</span><br><span class="line">                    <span class="comment">// 路徑不可為空 &amp;&amp; 該路徑有符合答案者 </span></span><br><span class="line">                    <span class="keyword">if</span> (next!=<span class="literal">nullptr</span> &amp;&amp; <span class="built_in">dfs</span>(next, i+<span class="number">1</span>))&#123;</span><br><span class="line">                        <span class="comment">// 提前回傳 true</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 全部路徑無答案，回傳 false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (curr-&gt;children [word [i]-<span class="string">&#x27;a&#x27;</span>] != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                curr = curr-&gt;children [word [i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr-&gt;is_end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WordDictionary</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addWord</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Node* curr = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> w: word)&#123;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;children [w-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                curr-&gt;children [w-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;children [w-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        curr-&gt;is_end = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = word.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;word = word;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="方法二-Hash-Table-Python"><a href="#方法二-Hash-Table-Python" class="headerlink" title="方法二: Hash Table (Python)"></a>方法二: Hash Table (Python)</h1><p>重點</p>
<ul>
<li>注意要避開 <code>#</code> 因為他不是一個路徑，否則會報錯。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.root = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addWord</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        curr = self.root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> curr:</span><br><span class="line">                curr [w] = &#123;&#125;</span><br><span class="line">            curr = curr [w]</span><br><span class="line">        curr [<span class="string">&quot;#&quot;</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(word)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">curr, start</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n):</span><br><span class="line">                w = word [i]</span><br><span class="line">                <span class="comment"># 遇到 .</span></span><br><span class="line">                <span class="keyword">if</span> w == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                    <span class="comment"># 用迴圈造訪所有可能路徑 </span></span><br><span class="line">                    <span class="keyword">for</span> c <span class="keyword">in</span> curr:</span><br><span class="line">                        <span class="comment"># 避開結尾標記 &amp;&amp; 該路徑有符合答案者 </span></span><br><span class="line">                        <span class="keyword">if</span> c!=<span class="string">&quot;#&quot;</span> <span class="keyword">and</span> dfs (curr [c], i+<span class="number">1</span>):</span><br><span class="line">                            <span class="comment"># 提前回傳 true</span></span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    <span class="comment"># 全部路徑無答案，回傳 false</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">elif</span> w <span class="keyword">in</span> curr:</span><br><span class="line">                    curr = curr [w]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#&quot;</span> <span class="keyword">in</span> curr</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs (self.root, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DSA</category>
      </categories>
      <tags>
        <tag>Trie</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Implement Trie (字典樹)</title>
    <url>/posts/trie/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天在寫 LeetCode 每日一題時遇到 <a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/">208. Implement Trie (Prefix Tree)</a>，之前因為覺得 Trie 好像很難所以一直不願面對，但這題就是要跟 Trie 的直球對決了想躲也躲不掉 XD，Anyway，看了一下發現 Trie 其實蠻好理解的，今天就來認識一下 Trie，然後看看這一題可以怎麼寫吧！(Python, C++)</p>
<span id="more"></span>

<h1 id="Trie-介紹"><a href="#Trie-介紹" class="headerlink" title="Trie 介紹"></a>Trie 介紹</h1><p>Trie 的中文可以叫做字典樹、字首樹或前綴樹，顧名思義是一種樹狀結構，常被用來檢索文本中的單詞或前綴 (prefix)。</p>
<p>字典樹有幾個性質，這裡搭配下方圖片做介紹：</p>
<ol>
<li>每個節點代表一個字符，並且單字的結尾有標記，舉例來說單字 “ten” 會依序經過 t、e、n 三個節點，其中 n 是結尾 (綠色)。</li>
<li>節點是可以被共用的，舉例來說 “sun” 及 “sup” 就共用了 s、u 兩個節點。</li>
<li>葉子節點一定是單字結尾，但非葉節點也可以是結尾，舉例來說 “an” 及 “and” 分別是兩個單字，其中 n 及 d 都是單字的結尾 (綠色)。</li>
</ol>
<p><img src="/../images/2023/03/18/trie.png" alt="trie"><br>字典樹的優點是可以快速查找字符串，且可以按照字典序進行排序。但缺點是需要較大的空間來存儲，且插入和刪除操作相對較慢。</p>
<h1 id="實作-Trie"><a href="#實作-Trie" class="headerlink" title="實作 Trie"></a>實作 Trie</h1><p>實作的內容就是一開始提到的 LeetCode 208，簡單來說就是要做出初始化、插入、尋找及尋找前綴 4 個功能，詳細題目可以自己到 LeetCode 去看。</p>
<p>值得一提的是，Trie 有兩種實作方法，第一個方法相當直覺，就是用指針連結各個節點來模擬出一個樹狀結構；第二個方法則是動態語言限定，我們可以直接用 hash table 來儲存字符，接下來分別用 C++ 及 Python 來演示這兩種方法。</p>
<h2 id="方法一-Pointers-C"><a href="#方法一-Pointers-C" class="headerlink" title="方法一: Pointers (C++)"></a>方法一: Pointers (C++)</h2><p>重點</p>
<ul>
<li>英文字母只有 26 個，所以可以直接使用 array，以 index (<code>w-&#39;a&#39;</code>) 來表示字符。</li>
<li>prefix 的部分只要節點存在就 OK，但 search 的部分還要檢查是不是結尾。</li>
<li>另外定義一個 struct 而不是直接 new 原本的 class，是因為 struct 的結構比 class 簡單的多 (沒有 function)，可以提升執行效率。</li>
<li>使用靜態宣告 (array) 所以不用擔心 memory leak。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">  Node* children [<span class="number">26</span>];</span><br><span class="line">  <span class="type">bool</span> is_word = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node* root;</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Node* curr = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> w: word) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;children [w-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                curr-&gt;children [w-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;children [w-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        curr-&gt;is_word = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Node* curr = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> w: word) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr == <span class="literal">NULL</span> || curr-&gt;children [w-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;children [w-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr-&gt;is_word;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        Node* curr = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> w: prefix) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;children [w-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;children [w-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="方法二-Hash-Table-Python"><a href="#方法二-Hash-Table-Python" class="headerlink" title="方法二: Hash Table (Python)"></a>方法二: Hash Table (Python)</h2><p>重點</p>
<ul>
<li>用特殊符號 (#) 來標記單字結尾。</li>
<li>因為動態語言中的資料型態是動態決定的，所以 Hash Table 內可以同時儲存不同資料型態 (存下一層 &#x2F; 存結尾)。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._root = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        curr = self._root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> curr:</span><br><span class="line">                curr [w] = &#123;&#125;</span><br><span class="line">            curr = curr [w]</span><br><span class="line">        curr [<span class="string">&quot;#&quot;</span>] = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        curr = self._root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">in</span> curr:</span><br><span class="line">                curr = curr [w]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> curr.get (<span class="string">&quot;#&quot;</span>, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">startsWith</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        curr = self._root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">in</span> curr:</span><br><span class="line">                curr = curr [w]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h1 id="相關文章"><a href="#相關文章" class="headerlink" title="相關文章"></a>相關文章</h1><p><a href="/posts/trie-2/">Trie (字典樹) - Design Add and Search Words Data Structure</a></p>
<h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>Trie 的基本觀念說實在還蠻簡單的，難應該是難在之後的應用，之後有機會看能不能更新一些進階的觀念，像是搜尋引擎之類的。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.youtube.com/watch?v=f48wGD-MuQw">https://www.youtube.com/watch?v=f48wGD-MuQw</a></p>
]]></content>
      <categories>
        <category>DSA</category>
      </categories>
      <tags>
        <tag>Trie</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
</search>
