<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello Hexo！用Hexo在GitHub Pages上架設個人部落格吧！(1)</title>
    <url>/posts/Hello-Hexo-1/</url>
    <content><![CDATA[<h1 id="Hexo-介紹"><a href="#Hexo-介紹" class="headerlink" title="Hexo 介紹"></a>Hexo 介紹</h1><p>Hexo 是一個基於Node.js 的自動化部落格部署框架，有近400種網頁主題可供選擇，支援Markdown語言撰寫文章內容而且部署相當迅速，簡直是自己架設部落格的必備神器呀！什麼？你說之前沒用過Node.js怎麼辦？沒關係，因為我之前也沒用過XD。事實上，只要掌握幾個基本的指令，就能夠架出漂漂亮亮、功能齊全的個人部落格囉！就讓我們一起看下去吧～<br>Hexo 官網：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a><br>Hexo GitHub：<a href="https://github.com/hexojs/hexo">https://github.com/hexojs/hexo</a></p>
<span id="more"></span>

<h1 id="前置作業"><a href="#前置作業" class="headerlink" title="前置作業"></a>前置作業</h1><ul>
<li><p>安裝 Node.js<br>官方載點：<a href="https://nodejs.org/zh-tw/download/">https://nodejs.org/zh-tw/download/</a></p>
<blockquote>
<p>進入網站後選擇LTS版本，然後選擇下載安裝程式，我自己是用Windows作業系統，直接點擊Windows icon就開始下載了，下載好後打開安裝程式一路確認到最後就安裝好啦～安裝完成後可以用 <code>npm --version</code> 來確認是否安裝成功。<br><img src="/../images/2023/03/14/nodejs.png" alt="Node.js"></p>
</blockquote>
</li>
<li><p>安裝 git<br>官方載點：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p>
<blockquote>
<p>選擇對應的作業系統直接下載就好～這裡一樣以Windows為例，選擇的是Standalone Installer下的64-bit Git for Windows Setup，下載好後打開安裝程式一路確認到最後就安裝好啦～安裝完成後可以用 <code>git --version</code> 來確認是否安裝成功。<br><img src="/../images/2023/03/14/git.png" alt="git"></p>
</blockquote>
</li>
<li><p>註冊GitHub帳號<br>官網連結：<a href="https://github.com/">https://github.com/</a></p>
</li>
</ul>
<h1 id="安裝-Hexo"><a href="#安裝-Hexo" class="headerlink" title="安裝 Hexo"></a>安裝 Hexo</h1><ul>
<li><p>安裝 Hexo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化資料夾，並將當前路徑移動到該資料夾下(blog 是資料夾名稱，可以改成自己喜歡的名字)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br></pre></td></tr></table></figure>
</li>
<li><p>下載 Hexo 所需套件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></li>
</ul>
<p>做完上面這些步驟後，我們就可以啟動伺服器來看看目前部落格的樣子囉。</p>
<ul>
<li>啟動伺服器<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server #or</span><br><span class="line">hexo s      </span><br></pre></td></tr></table></figure>
<blockquote>
<p>預設主題是landscape，也可以使用其他主題，下一篇文章會教大家如何套用Hexo上的熱門主題nexT！<br><img src="/../images/2023/03/14/landscape.png" alt="landscape"></p>
</blockquote>
</li>
</ul>
<h1 id="Hexo-架構"><a href="#Hexo-架構" class="headerlink" title="Hexo 架構"></a>Hexo 架構</h1><p>在開始加工我們的網站之前，先來認識一下Hexo的資料夾架構！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">|   ├── draft</span><br><span class="line">|   ├── page</span><br><span class="line">|   └── post</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">├── themes</span><br><span class="line">|   └── yourTheme</span><br><span class="line">|       └── _config.yml</span><br><span class="line">└── _config.yml</span><br></pre></td></tr></table></figure>

<ul>
<li>package.json<br>用來存放node.js的各種套件，一班情況下不太需要動到這個資料夾。</li>
<li>scaffolds<br>鷹架資料夾，裡面有三個檔案draft、page與post，分別對應了我們能建立的三種佈局，Hexo會依據這些佈局來生成新的頁面。</li>
<li>source<br>來源資料夾，用來存放文章、頁面以及圖片等內容，其中_drafts用來存放草稿，_posts用來存放已經發布的文章。</li>
<li>themes<br>主題資料夾，可以下載自己喜歡的主題放到裡面，在每個主題底下會有一個與主題設定檔，與主題有關的東西都在那裡進行設定。</li>
<li>_config.yml<br>網頁設定檔，與網頁有關的東西都在這裡進行設定。 (跟主題設定檔不一樣！)</li>
</ul>
<h1 id="Config-設置"><a href="#Config-設置" class="headerlink" title="Config 設置"></a>Config 設置</h1><p>進到_config.yml檔案中，對Site部分進行修改，可以參考下面的設置：</p>
<blockquote>
<p>subtitle跟description可寫可不寫<br>language預設是英文，可以改成zh-TW顯示繁體中文<br>keyword跟Google關鍵字搜尋有關，這裡先忽略不管他，未來有機會再來詳細介紹！<br><img src="/../images/2023/03/14/config_site.png" alt="config_site"></p>
</blockquote>
<h1 id="撰寫文章-x2F-新增頁面"><a href="#撰寫文章-x2F-新增頁面" class="headerlink" title="撰寫文章&#x2F;新增頁面"></a>撰寫文章&#x2F;新增頁面</h1><p>在Hexo當中共有三種佈局，分別是draft、post與page，其中draft跟page屬於文章，page則屬於頁面。</p>
<ul>
<li><p>post<br>所有draft都會被存放在_posts資料夾當中，會出現在網頁上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># post 可以省略</span><br><span class="line">hexo new post &quot;My Post&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>draft<br>draft是草稿，會另外從放於_drafts資料夾下，且不會出現在網頁上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new draft &quot;My Draft&quot;</span><br></pre></td></tr></table></figure>
<p>可以用指令將draft轉成post，原理只是換個資料夾而已，其實也可以手動作，反過來手動把post丟到draft也行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo publish &quot;My Draft&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>page<br>page是功能頁面，常見的有about、tags、categories等，下一篇文章就會介紹如何在nexT主題下建立對應的page！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;My Page&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="生成靜態文件"><a href="#生成靜態文件" class="headerlink" title="生成靜態文件"></a>生成靜態文件</h1><p>每次修改config檔或是寫完文章後，記得不要忘記重新生成一次網頁的靜態文件，不然剛剛做的變動網頁上是不會呈現出來的喔！</p>
<ul>
<li><p>清空原本的靜態文件&#x2F;暫存<br>這個步驟相當重要！否則容易出現新加的東西更新不上去的情況。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clear #or</span><br><span class="line">hexo cl</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成靜態文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate #or</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure>
</li>
<li><p>做完記得打開server確認一下結果！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server #or</span><br><span class="line">hexo s </span><br></pre></td></tr></table></figure></li>
</ul>
<p>這三個指令<br>非常重要！！！<br>非常重要！！！<br>非常重要！！！<br>簡單來說有動到東西請執行一下就對了！</p>
<h1 id="部署至-GitHub-Pages"><a href="#部署至-GitHub-Pages" class="headerlink" title="部署至 GitHub Pages"></a>部署至 GitHub Pages</h1><ol>
<li><p>在GitHub中創建一個新的repository (點右上角加號)<br><img src="/../images/2023/03/14/repository.png" alt="repository"></p>
</li>
<li><p>repository名稱取為<code>user_name.github.io</code>，然後直接create repository<br><img src="/../images/2023/03/14/repository_create.png" alt="repository_create"></p>
</li>
<li><p>修改網頁_config.yml中的URL設置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url: https://user_name.github.io/</span><br><span class="line">root: /</span><br></pre></td></tr></table></figure>
<blockquote>
<p>這裡的url是GitHub Pages的網址<br>root設成 &#x2F;<br><img src="/../images/2023/03/14/config_url.png" alt="config_url"></p>
</blockquote>
</li>
<li><p>修改網頁_config.yml中的deploy設置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/user_name/user_name.github.io.git</span><br></pre></td></tr></table></figure>
<blockquote>
<p>這裡選擇用HTTPS的方式連結，部署時直接輸入帳號密碼就行，也可以用SSH，不過就要設置金鑰，比較麻煩一些<br><img src="/../images/2023/03/14/config_deploy.png" alt="config_deploy"></p>
</blockquote>
</li>
<li><p>修改完後記得重新生成一次靜態文件</p>
</li>
<li><p>開始部署</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo deploy #or</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
</li>
<li><p>打開GitHub Pages的網址就能看到我們剛剛部署上去的網頁啦！<br><img src="/../images/2023/03/14/gitpage.png" alt="Alt text"></p>
</li>
</ol>
<h1 id="預告"><a href="#預告" class="headerlink" title="預告"></a>預告</h1><p>下一篇文章我將會介紹如何套用nexT主題，除了講解外觀設定以外，也將帶著大家打造標籤頁及站內搜尋等功能！</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Hexo！套用NexT主題打造簡潔頁面！(2)</title>
    <url>/posts/Hello-Hexo-2/</url>
    <content><![CDATA[<h1 id="NexT-介紹"><a href="#NexT-介紹" class="headerlink" title="NexT 介紹"></a>NexT 介紹</h1><p>NexT是一個相當受歡迎的Hexo主題，外觀簡潔、功能強大，且持續有在維護，今天會教大家如何套用NexT主題，並啟用標籤頁及站內搜尋等功能。<br>NexT 官網：<a href="https://theme-next.js.org/">https://theme-next.js.org/</a><br>NexT GitHub：<a href="https://github.com/next-theme/hexo-theme-next">https://github.com/next-theme/hexo-theme-next</a></p>
<span id="more"></span>

<h1 id="安裝-NexT"><a href="#安裝-NexT" class="headerlink" title="安裝 NexT"></a>安裝 NexT</h1><p>有兩個方法，第一個方法是透過npm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-theme-next</span><br></pre></td></tr></table></figure>
<p>第二個方法是透過git</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/next-theme/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p>我個人是喜歡第二種方法(git)，因為資源為自動進到themes資料夾當中，如果使用第二種方法(npm)的話資源會跑到node_modules資料夾中，雖然在功能上不會有差異，但未來要對主題的config檔做調整時要找比較久。</p>
<h1 id="套用主題"><a href="#套用主題" class="headerlink" title="套用主題"></a>套用主題</h1><p>到<strong>網頁</strong>的config檔(<code>/_config.yml</code>)，搜尋<strong>theme</strong>將主題設置成next就行了。<br><img src="/../images/2023/03/15/config_theme.png" alt="config_theme"></p>
<p>另外Next其實有提供4種版面可以做選擇，分別是：💟 <a href="https://theme-next.js.org/muse/">Muse</a> | 🔯 <a href="https://theme-next.js.org/mist/">Mist</a> | ♓️ <a href="https://theme-next.js.org/pisces/">Pisces</a> | ♊️ <a href="https://theme-next.js.org/">Gemini</a></p>
<p>大家可以點擊連結看看自己喜歡哪種版面，預設是使用Muse，如果要做更改的話，到<strong>主題</strong>的config檔(<code>themes/next/_config.yml</code>)中搜尋<strong>Schemes</strong>，將喜歡的佈局取消註解就可以了，另外下面的<strong>darkmode</strong>改成true的話則是可以讓網頁變成黑色模式。<br><img src="/../images/2023/03/15/next_schemes.png" alt="next_schemes"></p>
<p>NexT也支援canvas背景動畫，我們可以在<strong>主題</strong>config檔搜尋<strong>canvas_ribbon</strong>，將下方的enable改為true，部屬後網頁背景就會出現酷炫的彩色絲帶動畫了～</p>
<h1 id="添加頭像-avatar"><a href="#添加頭像-avatar" class="headerlink" title="添加頭像 avatar"></a>添加頭像 avatar</h1><ol>
<li>把準備好的圖片放入<code>themes/next/source/images</code>或<code>source/images</code>當中。</li>
<li>在<strong>主題</strong>config檔搜尋<strong>avatar</strong>，修改成自己準備的圖片路徑或者修改圖片名稱使其一致。<blockquote>
<p>rounded改成true的話頭像會是圓形，rotated改成true的話滑鼠移到頭像上時會有快速旋轉的動畫。<br><img src="/../images/2023/03/15/next_avatar.png" alt="next_avatar"></p>
</blockquote>
</li>
</ol>
<h1 id="更改網站圖示-favicon"><a href="#更改網站圖示-favicon" class="headerlink" title="更改網站圖示 favicon"></a>更改網站圖示 favicon</h1><p>我們可以把網站圖示換成自己的圖片，官方文件中建議可以使用<a href="https://realfavicongenerator.net/">Favicon Generator</a>來生成客製化的網站圖示。</p>
<ol>
<li>把準備好的圖片放入<code>themes/next/source/images</code>或<code>source/images</code>當中。</li>
<li>在<strong>主題</strong>config檔搜尋<strong>favicon</strong>，修改成自己準備的圖片路徑或者修改圖片名稱使其一致。<br><img src="/../images/2023/03/15/next_favicon.png" alt="next_favicon"></li>
</ol>
<h1 id="社群媒體連結-social-link"><a href="#社群媒體連結-social-link" class="headerlink" title="社群媒體連結 social link"></a>社群媒體連結 social link</h1><p>在<strong>主題</strong>config檔搜尋<strong>social</strong>，將自己的社群媒體連結填入並取消註解就可以了，下方的social_icon則可以設定是否顯示icon及icon外觀。<br><img src="/../images/2023/03/15/next_social.png" alt="next_social"></p>
<p>Hexo NexT使用<a href="https://fontawesome.com/icons">Font Awesome</a>提供的icons，因此我們可以為新的連結挑選適合的icon，接下來我們來新增一個Linkedin連結看看(包含icon)。</p>
<ol>
<li>先到Font Awesome上搜尋Linkedin，選擇自己喜歡的icon，複製綠色的那段文字。<br><img src="/../images/2023/03/15/font_awesome_linkedin.png" alt="font_awesome_linkedin"></li>
<li>依<code>標題: 連結 || 綠色文字</code>的格式在social下加入新的一行，舉例來說。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linkedin: https://www.linkedin.com/in/meng-chieh-liu-615952235/ || fa-brands fa-linkedin</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="啟用功能選單-Menu"><a href="#啟用功能選單-Menu" class="headerlink" title="啟用功能選單 Menu"></a>啟用功能選單 Menu</h1><p>在<strong>主題</strong>config檔搜尋<strong>menu</strong>，可以看到NexT預先幫我們建立好許多功能選單，其中home跟archives是預設就開啟的，我們可以取消註解來啟用其他功能選單，但目前那些頁面還是空的喔！所以我們的下一步就是要建立相應的分頁。<br><img src="/../images/2023/03/15/next_menu.png" alt="next_menu"></p>
<p>這邊介紹如何建立tags&#x2F;categories頁面：</p>
<ol>
<li><p>建立新頁面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;tags&quot;</span><br><span class="line">hexo new page &quot;categories&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>找到<code>source/tags/index.md</code>檔案，在檔案中加入<code>type: &quot;tags&quot;</code>，注意這裡的tags要加<strong>雙引號</strong>！！！<br>(categories比照辦理)<br><img src="/../images/2023/03/15/tags.png" alt="tags"></p>
</li>
<li><p>在post裡面加入tags&#x2F;categories，重新部署後這些tags&#x2F;categories就會出現對應的頁面上啦～<br><img src="/../images/2023/03/15/post_tags.png" alt="post_tags"></p>
</li>
</ol>
<h1 id="站內搜尋功能-local-search"><a href="#站內搜尋功能-local-search" class="headerlink" title="站內搜尋功能 local search"></a>站內搜尋功能 local search</h1><ol>
<li><p>安裝<code>hexo-generator-searchdb</code>套件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<strong>主題</strong>config檔搜尋<strong>local_search</strong>，將enable調為true。<br><img src="/../images/2023/03/15/next_local_search.png" alt="next_local_search"></p>
</li>
<li><p>在<strong>網頁</strong>config檔加入下面設置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新部署後就能開始使用站內搜尋啦～<br><img src="/../images/2023/03/15/local_search.png" alt="local_search"></p>
</li>
</ol>
<h1 id="預告"><a href="#預告" class="headerlink" title="預告"></a>預告</h1><p>下一篇文章將會帶大家做SEO，設定keywords與sitemap讓Google搜的到我們的部落格&#x2F;文章。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Hexo！簡單三步驟搞定Google SEO和Bing SEO！(3)</title>
    <url>/posts/Hello-Hexo-3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="/../images/2023/04/11/google_bing.png" alt="google and bing logo"></p>
<p>好不容易架設好Hexo網站，下一個問題就是如何讓自己寫的文章被其他人看見，大家可以在Google搜尋中輸入<code>site: 你的網站url</code>，看看Google能不能找到你的網站，沒意外的話Google應該還找不到你的網站，換做是Bing也一樣，原因是這些搜尋引擎還不認識我們的網站，本篇文章會帶大家使用Google Search Console以及Bing Webmaster來進行SEO。<br>(ps. 網路上已經有很多文章介紹Hexo的Google SEO，但在Bing與ChatGPT合作後，搜尋量有了明顯的提升，因此這篇文章除了介紹Google SEO外，也會介紹Bing SEO)</p>
<span id="more"></span>

<h1 id="Sitemap"><a href="#Sitemap" class="headerlink" title="Sitemap"></a>Sitemap</h1><p>Sitemap就是網站的地圖，搜尋引擎會透過Sitemap來認識我們的網站架構，我們可以透過下面指令安裝hexo的sitemap套件，之後hexo每次generate都會自動替我們生成sitemap。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap</span><br></pre></td></tr></table></figure>

<h1 id="Google-SEO"><a href="#Google-SEO" class="headerlink" title="Google SEO"></a>Google SEO</h1><p>我們要在<a href="https://search.google.com/search-console/about">Google Search Console</a>來設定Google的SEO，</p>
<h2 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h2><p>我們首先要驗證我們的網頁，選擇<strong>網站前置字元</strong>，將你的網站url複製上去(舉例:<code>https://MengChiehLiu.github.io/</code>)。<br><img src="/../images/2023/04/11/google_search_console.png" alt="google search console - resource type"></p>
<h2 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h2><p>我們使用建議的驗證方式，將html檔案下載下來，放到<code>/source</code>路徑下，我們要將檔案內容改成下面這樣:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 加上這段 --&gt;</span></span><br><span class="line">---</span><br><span class="line">layout: false</span><br><span class="line">---</span><br><span class="line"><span class="comment">&lt;!-- 原本的 --&gt;</span></span><br><span class="line">google-site-verification: googled0a70fa73d09cd65.html</span><br></pre></td></tr></table></figure>
<p>重新部署網頁後(這很重要!)就可以回到Google Search Console按下驗證。<br><img src="/../images/2023/04/11/google_search_console_2.png" alt="google search console - html verification"></p>
<h2 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h2><p>我們到Sitemap頁面中將加入<code>sitemap.xml</code>，這樣Google搜尋引擎就會定期到我們的sitemap去看我們的部落格有沒有更新了。<br><img src="/../images/2023/04/11/google_search_console_3.png" alt="google search console - sitemap"></p>
<h1 id="Bing-SEO"><a href="#Bing-SEO" class="headerlink" title="Bing SEO"></a>Bing SEO</h1><p>我們要在<a href="https://www.bing.com/webmasters/about">Bing Webmaster</a>來設定Bing的SEO，Bing的SEO超級簡單，登入後直接從Google Search Console匯入網站資訊就好。<br><img src="/../images/2023/04/11/bing_webmaster.png" alt="bing webmaster"></p>
<h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>做完這些設定後，Google和Bing會需要一些時間把我們的網站納入搜尋引擎當中，這個過程可能會需要1~2天。<br>上面這些設定只是讓搜尋引擎找的到我們的網站，屬於最基本的SEO，其他如關鍵字以、網址長度也會影響到網站排名，但最重要的還是文章的品質，所以努力寫出好文章也是SEO的關鍵喔。</p>
<blockquote>
<p>關鍵字設定<br>可以直接將<code>scaffolds/post.md</code>改成下面格式，之後new post的時候會自動套用下面格式。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">    -</span><br><span class="line">    -</span><br><span class="line">categories: </span><br><span class="line">keywords:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>使用時注意關鍵字與關鍵字之間用逗號分開不留空格!例如:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">keywords: Hexo,SEO,Google,Bing,Google Search Console,Bing Webmaster</span><br></pre></td></tr></table></figure>


<blockquote>
<p>網址長度<br>hexo預設使用<code>年/月/日/檔案名稱</code>來當作文章url，我們可以修改<code>/_config.yml</code>中的<code>permalink</code>來讓url更加精簡，詳細規則可以參考<a href="https://hexo.io/zh-tw/docs/permalinks.html">hexo官方文檔</a>，我自己是改成下面這樣:</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span> <span class="comment"># default</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:title/</span> <span class="comment"># shorter version</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Hexo！NexT 主題太單調？跟著這些美化步驟為部落格加入個人風格！(5)</title>
    <url>/posts/Hello-Hexo-5/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="/../images/2023/04/17/cover.png" alt="cover"></p>
<p>Hexo Next雖然已經將許多常見的設定整合到主題當中，但大家都採用一樣的設定的話其實挺無聊的，所以今天要在Hexo Next的基礎上帶大家來美化自己的部落格，為部落格加入<strong>個人風格</strong>，如果還不知道Hexo或者NexT是什麼可以參考我之前寫的<a href="/categories/Hexo/">Hello Hexo！</a>系列文章。 </p>
<span id="more"></span>

<h1 id="大綱"><a href="#大綱" class="headerlink" title="大綱"></a>大綱</h1><ul>
<li><a href="#%E5%A5%97%E7%94%A8%E8%83%8C%E6%99%AF%E5%9C%96%E7%89%87">套用背景圖片</a></li>
<li><a href="#%E8%AA%BF%E6%95%B4%E5%8D%80%E5%A1%8A%E9%80%8F%E6%98%8E%E5%BA%A6">調整區塊透明度</a></li>
<li><a href="#%E8%A8%AD%E7%BD%AE%E5%8D%80%E5%A1%8A%E5%9C%93%E8%A7%92">設置區塊圓角</a></li>
<li><a href="#%E6%96%87%E7%AB%A0%E5%8D%80%E5%A1%8A%E7%89%88%E9%9D%A2%E5%AF%AC%E5%BA%A6">文章區塊版面寬度</a></li>
<li><a href="#%E7%A8%8B%E5%BC%8F%E7%A2%BC%E5%8D%80%E5%A1%8A%E4%B8%BB%E9%A1%8C">程式碼區塊主題</a></li>
<li><a href="#%E8%AE%8A%E6%9B%B4%E6%96%87%E5%AD%97%E6%A8%A3%E5%BC%8F">變更文字樣式</a></li>
<li><a href="#%E8%AE%8A%E6%9B%B4%E5%AD%97%E9%AB%94%E9%A1%9E%E5%9E%8B">變更字體類型</a></li>
<li><a href="#%E5%9C%96%E7%89%87%E6%94%BE%E5%A4%A7%E6%AA%A2%E8%A6%96">圖片放大檢視</a></li>
</ul>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><h2 id="套用背景圖片"><a href="#套用背景圖片" class="headerlink" title="套用背景圖片"></a>套用背景圖片</h2><ol>
<li>準備一張圖片放到<code>themes/next/source/images/</code>路徑中。</li>
<li>到<code>themes/next/_config.yml</code>中，找到<code>custom_file_path</code>，將<code>style</code>的註解取消掉。<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.njk</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.njk</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.njk</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.njk</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.njk</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.njk</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.njk</span></span><br><span class="line">  <span class="comment">#variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure></li>
<li>在<code>source</code>內新增<code>_data</code>資料夾(<strong>注意是blog的，不是next裡面的!</strong>)，接著在裡面新增一個<code>styles.styl</code>文件。</li>
<li>在<code>styles.styl</code>中加入:<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>:<span class="built_in">url</span>(/images/background.jpg);  <span class="comment">// 背景圖片位置</span></span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-attachment</span>: fixed;            <span class="comment">// 是否滾動，fixed固定</span></span><br><span class="line">  <span class="attribute">background-size</span>: cover;                  <span class="comment">// 填滿畫面</span></span><br><span class="line">  <span class="attribute">background-position</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="調整區塊透明度"><a href="#調整區塊透明度" class="headerlink" title="調整區塊透明度"></a>調整區塊透明度</h2><p>套用背景圖片後，你可能會發現你的圖片大部分都被區塊擋住了!為了讓大家看到你美美的圖片，所以我們要來調整一下區跨的透明度，網路上很多調整透明度的方法都沒有用我試過了，最後在<a href="https://hui-shao.cn/next-transparent-background/" title="{rel=&#39;nofollow&#39;}">這篇文章</a>中找到讓我滿意的效果，這邊直接講結論，在<code>styles.styl</code>加入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:root &#123;</span><br><span class="line">  --content-bg-color:#ffffffe6;  // 白色半透明</span><br><span class="line">  --content-bg-color:#000000e6;  // 黑色半透明，兩者擇一</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>補充: 上面的設定是直接將區塊換成指定顏色，如果有開啟深色模式可以用黑色半透明，如果沒有的話可以用白色半透明，但切記不要混者用，否則文字會看不清楚。</p>
</blockquote>
<h2 id="設置區塊圓角"><a href="#設置區塊圓角" class="headerlink" title="設置區塊圓角"></a>設置區塊圓角</h2><ol>
<li><p>到<code>themes/next/_config.yml</code>中，找到<code>custom_file_path</code>，將<code>variable</code>的註解也取消掉。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.njk</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.njk</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.njk</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.njk</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.njk</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.njk</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.njk</span></span><br><span class="line">  <span class="attr">variable:</span> <span class="string">source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>source</code>內新增<code>_data</code>資料夾(<strong>注意是blog的，不是next裡面的!</strong>)，接著在裡面新增一個<code>variables.styl</code>文件。</p>
</li>
<li><p>在<code>variables.styl</code>中加入:</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="variable">$border</span>-radius-inner     = <span class="number">30px</span> <span class="number">30px</span> <span class="number">30px</span> <span class="number">30px</span>;  <span class="comment">// (內角) 左上 右上 右下 左下</span></span><br><span class="line"><span class="variable">$border</span>-radius           = <span class="number">30px</span>;                 <span class="comment">// (外角) 只填一個數字表示4個角</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="文章區塊版面寬度"><a href="#文章區塊版面寬度" class="headerlink" title="文章區塊版面寬度"></a>文章區塊版面寬度</h2><p>我們先來看一下預設的寬度(指的是網頁版，手機或平板都是用響應式網頁):</p>
<ul>
<li>Muse &#x2F; Mist<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="variable">$content</span>-desktop         = <span class="number">700px</span>   <span class="comment">// when screen width &lt; 1200px</span></span><br><span class="line"><span class="variable">$content</span>-desktop-large   = <span class="number">800px</span>   <span class="comment">// when screen width &gt;= 1200px</span></span><br><span class="line"><span class="variable">$content</span>-desktop-largest = <span class="number">900px</span>   <span class="comment">// when screen width &gt;= 1600px</span></span><br></pre></td></tr></table></figure></li>
<li>Pisces &#x2F; Gemini<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="variable">$content</span>-desktop         = <span class="string">&#x27;calc(100% - %s)&#x27;</span> % <span class="built_in">unit</span>(<span class="variable">$content</span>-desktop-<span class="attribute">padding</span> / <span class="number">2</span>, <span class="string">&#x27;px&#x27;</span>)</span><br><span class="line"><span class="variable">$content</span>-desktop-large   = <span class="number">1160px</span></span><br><span class="line"><span class="variable">$content</span>-desktop-largest = <span class="number">73%</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>可以看到不同主題的寬度定義方式不太一樣，如果要更改的話，我們可以到<code>variables.styl</code>中把預設的寬度覆蓋掉，舉例來說我使用Gemini，下面是我採用的設定:</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="variable">$content</span>-desktop         = <span class="number">90%</span>  <span class="comment">// 可以用百分比</span></span><br><span class="line"><span class="variable">$content</span>-desktop-large   = <span class="number">80%</span>  <span class="comment">// 也可用絕對數值 ex: 1000px</span></span><br></pre></td></tr></table></figure>


<h2 id="程式碼區塊主題"><a href="#程式碼區塊主題" class="headerlink" title="程式碼區塊主題"></a>程式碼區塊主題</h2><p>Hexo提供了<code>highlight.js</code>以及<code>prism.js</code>兩種程式碼區塊主題engine，可以參考<a href="https://theme-next.js.org/highlight/" title="{rel=&#39;nofollow&#39;}">NexT Highlight Theme Preview</a>來做挑選，以下已我自己套用<code>highlight.js</code>中的<code>night-owl</code>主題為例。</p>
<ol>
<li><p>到<code>_config.yml</code>中(不是next裡的)，找到<code>highlight</code>，將<code>enable</code>改成true。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span>   <span class="comment"># 是否顯示行數</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span>  <span class="comment"># 是否自動偵測語言(建議不要開，聽說很吃效能)</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hljs:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">prismjs:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span>       <span class="comment"># 如果是用prismjs的話那就是這裡改true，不要同時開兩個</span></span><br><span class="line">  <span class="attr">preprocess:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>到<code>themes/next/_config.yml</code>中，找到<code>codeblock</code>，根據是否開啟深色模式來填入主題名稱。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="attr">theme:</span>                      <span class="comment"># highlight.js 改這</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">night-owl</span>          <span class="comment"># (範例)淺色模式下套用night-owl </span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">stackoverflow-dark</span></span><br><span class="line">  <span class="attr">prism:</span>                      <span class="comment"># prism.js 改這</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">prism</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">prism-dark</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span>             <span class="comment"># 是否顯示複製按鈕</span></span><br><span class="line">    <span class="attr">style:</span>                    <span class="comment"># 風格(Available values: default | flat | mac)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="變更文字樣式"><a href="#變更文字樣式" class="headerlink" title="變更文字樣式"></a>變更文字樣式</h2><p>這部分主要是分享我在網路上找到的，覺得很不錯的設定，以下修改都是加在<code>source/_data/styles.styl</code>中。</p>
<ol>
<li><p>短網址樣式</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">code</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#c7254e</span>; <span class="comment">//文字顏色</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#f9f2f4</span>; <span class="comment">//底色</span></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>內文連結樣式</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> a&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0593d3</span>;</span><br><span class="line">  <span class="selector-pseudo">&amp;:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fc6423</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: none;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#fc6423</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改選中文字底色</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* webkit, opera, IE9 */</span></span><br><span class="line"><span class="selector-pseudo">::selection</span> &#123; </span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#00c4b6</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f7f7f7</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* firefox */</span></span><br><span class="line">::-moz-selection &#123; </span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#00c4b6</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f7f7f7</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改頁腳配色</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//頁腳統計文字顏色</span><br><span class="line">.footer&#123;</span><br><span class="line">  color: #F0D784</span><br><span class="line">&#125;</span><br><span class="line">//修改頁腳備案鏈接顏色</span><br><span class="line">.footer a&#123;</span><br><span class="line">  color: #F0D784</span><br><span class="line">&#125;</span><br><span class="line">//修改頁腳統計人數的顏色</span><br><span class="line">.footer .with-love&#123;</span><br><span class="line">  color: #F0D784</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="變更字體類型"><a href="#變更字體類型" class="headerlink" title="變更字體類型"></a>變更字體類型</h2><p>NexT可以直接使用<a href="https://fonts.google.com/" title="{rel=&#39;nofollow&#39;}">Google Fonts</a>提供的字體，但如果你使用的是繁體中文的話，你會發現其實也就只有兩種可以選而已XDDD，NexT預設是使用<strong>微軟正黑體</strong>，另外一種是<strong>唐宋思源體</strong>，我們今天就來試者把字體換成唐宋思源體看看吧!</p>
<ol>
<li>到<code>themes/next/_config.yml</code>中，找到<code>font</code>將<code>enable</code>改成<code>true</code>，接著更改<code>global</code>的設定(後面的不用改)。<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>              <span class="comment"># 設成true</span></span><br><span class="line">  <span class="attr">host:</span> </span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span>          <span class="comment"># 設成true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Noto</span> <span class="string">Serif</span> <span class="string">TC</span>   <span class="comment"># 唐宋思源體(TC: Traditional Chinese)</span></span><br><span class="line">    <span class="attr">size:</span>                   <span class="comment"># 字體大小，默認為1（16px）</span></span><br></pre></td></tr></table></figure></li>
<li>這邊特別說明<code>host</code>部分，在台灣基本上是不用設，但因為預設的host是Google的api，所以大陸地區的用戶在看我們的網站時可能會遇到一些穩定性上的問題?如果你部落格的target是整個大中華地區的話可以另外設個host，這邊提供<a href="https://github.com/cdnjs/cdnjs" title="{rel=&#39;nofollow&#39;}">cdnjs</a>的鏡像api給有需要的人:<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">host:</span> <span class="string">https://fonts.loli.net</span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>補充: 你可能會想問「如果我想要用的字體Google Fonts沒有提供怎麼辦?」，其實也是有辦法使用本地的字體喔，不過這部分稍微麻煩一丟丟，所以之後另外寫一篇文章介紹!</p>
</blockquote>
<h2 id="圖片放大檢視"><a href="#圖片放大檢視" class="headerlink" title="圖片放大檢視"></a>圖片放大檢視</h2><p>NexT目前提供兩種片放大檢視的工具，分別是<a href="https://fancyapps.com/fancybox/" title="{rel=&#39;nofollow&#39;}">FancyBox</a>以及<a href="https://medium-zoom.francoischalifour.com/" title="{rel=&#39;nofollow&#39;}">Medium Zoom</a>，可以看一下自己喜歡哪種。</p>
<p>到<code>themes/next/_config.yml</code>中找到<code>fancybox</code>&#x2F;<code>mediumzoom</code>，將其改為<code>true</code>，注意不要同時開啟兩個功能!!!</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">fancybox:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">mediumzoom:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>補充: FancyBox的功能比較多且可以顯示註解，不過有<a href="https://github.com/ppoffice/hexo-theme-icarus/issues/868" title="{rel=&#39;nofollow&#39;}">issue</a>表示FancyBox對於行動裝置似乎不是很友好? 不知道改了沒，Medium Zoom就跟Medium放大圖片的功能一樣，介面比較簡潔。</p>
</blockquote>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><p>文章內容大多是網路上的資料整理而來，再加上自己的採坑經驗，如果有遺漏來源的話再麻煩告知補上!</p>
<ul>
<li><a href="https://zenreal.github.io/posts/44730/" title="{rel=&#39;nofollow&#39;}">最新 Hexo NexT v7.4.1 主題優化</a></li>
<li><a href="https://hui-shao.cn/next-transparent-background/" title="{rel=&#39;nofollow&#39;}">Hexo + NexT8主题配置透明背景过程踩坑小记</a></li>
<li><a href="https://spartazhc.github.io/2020/06/03/Next%E4%B8%BB%E9%A2%98%E5%AD%97%E4%BD%93%E9%85%8D%E7%BD%AE/" title="{rel=&#39;nofollow&#39;}">Next主题字体配置</a></li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>Hello Hexo！功能全部開起來看起來就很厲害了吧？NexT常見設定整理 (4)</title>
    <url>/posts/Hello-Hexo-4/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="/../images/2023/04/14/cover.png" alt="cover image"></p>
<p>Next之所以受到歡迎，一大原因是因為NexT將很多常用的功能都整合進入主題當中，只要修改一下主題設定檔(config)、下載一下插件(plugins)，就能實現大部分的功能，今天就帶大家看一些常見的功能在NexT主題下要如何實現。</p>
<span id="more"></span>
<h1 id="大綱"><a href="#大綱" class="headerlink" title="大綱"></a>大綱</h1><ul>
<li><a href="#%E7%95%99%E8%A8%80%E6%9D%BF">留言板</a></li>
<li><a href="#%E7%89%88%E6%AC%8A%E8%81%B2%E6%98%8E">版權聲明</a></li>
<li><a href="#%E9%96%B1%E8%AE%80%E9%80%B2%E5%BA%A6">閱讀進度</a></li>
<li><a href="#%E5%9B%9E%E5%88%B0%E9%A0%82%E9%83%A8">回到頂部</a></li>
<li><a href="#%E8%A8%AA%E5%AE%A2%E7%B5%B1%E8%A8%88%E3%80%81%E6%96%87%E7%AB%A0%E9%96%B1%E8%AE%80%E7%B5%B1%E8%A8%88">訪客統計、文章閱讀次數</a></li>
<li><a href="#%E6%96%87%E7%AB%A0%E5%AD%97%E6%95%B8%E3%80%81%E9%96%B1%E8%AE%80%E6%99%82%E9%96%93">文章字數、閱讀時間</a></li>
</ul>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><h2 id="留言板"><a href="#留言板" class="headerlink" title="留言板"></a>留言板</h2><p>留言板是一個很奇妙的東西，雖然心裡想到底有誰會來留言，但沒有的話又好像少了些什麼，所以姑且還是放一下XD。<br>NexT支援多種留言版插件，網路上推薦使用的是disqus或utterances (gitalk因為權限要求過高所以沒什麼推薦了)，二選一的情況下，disqus要另外去註冊一個帳號有點麻煩，反觀utterances可以直接連結github repository來儲存評論，且外觀比較簡潔，所以最後決定使用utterances。</p>
<ol>
<li><p>到<a href="https://github.com/apps/utterances" title="{rel=&#39;nofollow&#39;}">utterances app</a>把app安裝到github上，將權限開給指定的專案repository。(我是直接跟部落格使用同一個，當然你也可以另外開一個新的repository。)</p>
</li>
<li><p>找到<code>next/_config.yml</code>中的<code>utterances</code>，將<code>enable</code>改成<code>true</code>，在<code>repo</code>填入剛剛開啟權限的repository名稱，舉例來說我是填<code>MengChiehLiu/MengChiehLiu.github.io</code>，<code>theme</code>參數可以設定不同留言板風格，大家可以自己試試看。</p>
</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">utterances:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">MengChiehLiu/MengChiehLiu.github.io</span></span><br><span class="line">  <span class="attr">issue_term:</span> <span class="string">pathname</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">github-light</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>最後如果你希望留言板只出現在文章頁面，而不要出現在其他page(ex: 標籤頁、分類頁)的話，那要到page下的<code>index.md</code>下修改標頭檔。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: </span><br><span class="line">date: </span><br><span class="line">type: </span><br><span class="line">&lt;!-- 加入下面這一行 --&gt;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="版權聲明"><a href="#版權聲明" class="headerlink" title="版權聲明"></a>版權聲明</h2><p>找到<code>next/_config.yml</code>中的<code>creative_commons</code>，將<code>post</code>改成<code>true</code>就可以了，協議的版本可以參考<a href="https://creativecommons.org/about/cclicenses/" title="{rel=&#39;nofollow&#39;}">About CC Licenses</a>自己做挑選。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">size:</span> <span class="string">small</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">language:</span></span><br></pre></td></tr></table></figure>

<p>我自己覺得預設的內容就挺不錯的，不過也可以自訂內容，這邊提供一篇不錯的文章給有興趣的人:</p>
<ul>
<li><a href="https://guiblogs.com/hexo30-21/" title="{rel=&#39;nofollow&#39;}">Day 21：在 Hexo 增加作者版權聲明（使用 Next 佈景）</a></li>
</ul>
<h2 id="閱讀進度"><a href="#閱讀進度" class="headerlink" title="閱讀進度"></a>閱讀進度</h2><p>找到<code>next/_config.yml</code>中的<code>reading_progress</code>，將<code>enable</code>改成<code>true</code>，開啟後會在網頁頂部&#x2F;底部顯示閱讀進度條。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">reading_progress:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">start_at:</span> <span class="string">left</span>   <span class="comment"># left/right，從左或右開始</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">top</span>    <span class="comment"># top/bottom，顯示在網頁頂部或底部</span></span><br><span class="line">  <span class="attr">reversed:</span> <span class="literal">false</span>  <span class="comment"># 開啟的話會從全滿開始扣</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;#37c6c0&quot;</span> <span class="comment"># 顏色</span></span><br><span class="line">  <span class="attr">height:</span> <span class="string">3px</span>      <span class="comment"># 進度條寬度</span></span><br></pre></td></tr></table></figure>


<h2 id="回到頂部"><a href="#回到頂部" class="headerlink" title="回到頂部"></a>回到頂部</h2><p>就是網頁往下滑右下角會出現的那個箭頭，按下去會回到網頁的頂部，找到<code>next/_config.yml</code>中的<code>back2top</code>，將<code>enable</code>改成<code>true</code>。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">back2top:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span>        <span class="comment"># 是否也顯示在側邊欄中</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">false</span>  <span class="comment"># 是否顯示百分比</span></span><br></pre></td></tr></table></figure>


<h2 id="訪客統計、文章閱讀統計"><a href="#訪客統計、文章閱讀統計" class="headerlink" title="訪客統計、文章閱讀統計"></a>訪客統計、文章閱讀統計</h2><p><a href="https://busuanzi.ibruce.info/" title="{rel=&#39;nofollow&#39;}">不蒜子</a>是一款極簡的前端計數工具，NexT已經幫我們將不蒜子整合在主題當中，只要修改<code>next/_config.yml</code>中的<code>busuanzi_count</code>，將<code>enable</code>改成<code>true</code>，就可以啟用訪客統計、文章閱讀次數的功能。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span>  <span class="comment"># 訪客人數</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span>     <span class="comment"># 全站閱覽次數</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span>      <span class="comment"># 文章閱讀統計</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">far</span> <span class="string">fa-eye</span></span><br></pre></td></tr></table></figure>

<h2 id="文章字數、閱讀時間"><a href="#文章字數、閱讀時間" class="headerlink" title="文章字數、閱讀時間"></a>文章字數、閱讀時間</h2><ol>
<li><p>下載<code>hexo-word-counter</code>插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install hexo-word-counter</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo clean</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在Hexo的config檔中(主目錄裡的)加入下面設定</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span>             <span class="comment"># 文章字數</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span>                <span class="comment"># 文章時間</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">false</span>      <span class="comment"># 總文章字數 (顯示在網頁底部)</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">false</span>         <span class="comment"># 總文章時間 (顯示在網頁底部)</span></span><br><span class="line">  <span class="attr">exclude_codeblock:</span> <span class="literal">false</span>  <span class="comment"># 不考慮程式碼部分</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span>                  <span class="comment"># Words Per Minute</span></span><br><span class="line">  <span class="attr">suffix:</span> <span class="string">&quot;mins.&quot;</span>           <span class="comment"># 時間單位</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>wpm官方文檔中給的建議是<br>Slow ≈ 200<br>Normal ≈ 275<br>Fast ≈ 350<br>如果主要是中文的話可以設300，中英夾雜維持275就好。</p>
</blockquote>
</li>
<li><p>這個插件有被整合進NexT當中，在完成前一個步驟後，我們可以修改theme config來調整外觀顯示</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span>        <span class="comment"># 是否顯示文字部分(文章)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span>   <span class="comment"># 是否獨立一行</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">false</span> <span class="comment"># 是否顯示文字部分(網頁底部)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>不顯示文字的話就不會有<code>文章字數：</code>和<code>所需閱讀時間 ≈</code>，只會有最前面的圖示。</p>
</blockquote>
</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>站內搜尋、主選單等功能我在<a href="/posts/Hello-Hexo-2/">這篇文章</a>中有介紹過了，有興趣的人可以去看看。</p>
<h1 id="預告"><a href="#預告" class="headerlink" title="預告"></a>預告</h1><p>下一篇文章會帶大家美化部落格!包括更換背景圖片、變更字體以及其他風格設定~</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>Spectral Clustering - 算法解析與numpy程式實作</title>
    <url>/posts/spectral-clustering/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="/../images/2023/04/27/cluster_analysis.jpg" alt="Spectral Clustering"></p>
<p>在社群網絡中分析中，有時候會想要找出網絡當中的社群(community detection)，一個最直觀的想法是直接對網絡進行分群，那麼分群結果就是各個community了。<br>如果我們能夠計算各個節點之間的相似性，那麼我們當然可以直接套用傳統的分群方法，如cosine similiarity，但一來是相似度特徵可能很難取得，二來是這樣分群的話就沒有利用到網絡的結構了，這時我們可以改為使用基於圖論的分群方法。<br>今天這篇文章會帶大家簡單瞭解什麼是cut approach, balanced-cut approach以及其代表方法spectral clustering，並示範不依賴其他套件，僅使用numpy實作spectral clustering。</p>
<span id="more"></span>

<h1 id="大綱"><a href="#大綱" class="headerlink" title="大綱"></a>大綱</h1><ul>
<li><a href="#Mini-cut-Approach">Mini-cut approach</a></li>
<li><a href="#Balanced-cut-Approach">Balanced-cut approach</a></li>
<li><a href="#Spectral-Clustering">Spectral clustering</a></li>
</ul>
<h1 id="內文"><a href="#內文" class="headerlink" title="內文"></a>內文</h1><h2 id="Mini-cut-Approach"><a href="#Mini-cut-Approach" class="headerlink" title="Mini-cut Approach"></a>Mini-cut Approach</h2><p>Cut approach，顧名思義是將網絡給切開來形成多個網絡，屬於partitional clustering的一種，每個節點只會屬於一個community，並且community之間也不會overlapping，而Mini-cut Approach則是希望在切割網絡時能最小化切掉的edge數量。<br>聽起來很直觀，但這樣切會有一個問題，那就是有可能會切出一些非常小的community，導致分群不夠balance。</p>
<h2 id="Balanced-cut-Approach"><a href="#Balanced-cut-Approach" class="headerlink" title="Balanced-cut Approach"></a>Balanced-cut Approach</h2><p>為了解決Mini-cut Approach的缺點，Balanced-cut Approach在切割網絡時除了考量原本的edge，另外除以community的node數做加權調整，切割的目標從最小化edge數轉為最小化ratio cut，公式如下:<br><img src="/../images/2023/04/27/ratio_cut.png" alt="Ratio Cut formula"></p>
<p>公式解釋: 分成k群(k要自己決定)，每次取一個群<code>Pi</code>出來看，分子部分表示將<code>Pi</code>切開的話會切到的edge數，分母部分表示<code>Pi</code>內部的node數，將k個群的結果加總起來就會是整個網路的ratio cut分數。</p>
<h3 id="Matrixs"><a href="#Matrixs" class="headerlink" title="Matrixs"></a>Matrixs</h3><p>為了要計算Ratio Cut，我們先要來認識一下三種矩陣:</p>
<ol>
<li><p>Diagonal Degree Matrix 度數矩陣<br>Degree(度數)指的是一個node有多少個鄰居，將這些Degree轉換為對角矩陣(Diagonal Matrix)就得到Diagonal Degree Matrix。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D = np.array([</span><br><span class="line">  [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>
</li>
<li><p>Adjacency Matrix 鄰接矩陣<br>只要是對Graph有些概念的人應該都對Adjacency Matrix不太陌生，Adjacency Matrix描述了node之間的關係，下面例子假設node之間的關係都是雙向的，所以會是個對稱矩陣。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = np.array([</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br></pre></td></tr></table></figure>
</li>
<li><p>Laplacian Matrix 調和矩陣(拉普拉斯矩陣)<br>Laplacian Matrix 的算法就是直接將Diagonal Degree Matrix 減去 Adjacency Matrix，聽起來可能讓人滿頭問號，為什麼要這麼做? 這邊先賣個關子，繼續看下去就知道了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = np.array([</span><br><span class="line">  [ <span class="number">2</span>, -<span class="number">1</span>,  <span class="number">0</span>,  <span class="number">0</span>, -<span class="number">1</span>,  <span class="number">0</span>,  <span class="number">0</span>],</span><br><span class="line">  [-<span class="number">1</span>,  <span class="number">4</span>, -<span class="number">1</span>, -<span class="number">1</span>,  <span class="number">0</span>,  <span class="number">0</span>, -<span class="number">1</span>],</span><br><span class="line">  [ <span class="number">0</span>, -<span class="number">1</span>,  <span class="number">2</span>, -<span class="number">1</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>],</span><br><span class="line">  [ <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>,  <span class="number">3</span>,  <span class="number">0</span>, -<span class="number">1</span>,  <span class="number">0</span>],</span><br><span class="line">  [-<span class="number">1</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">2</span>, -<span class="number">1</span>,  <span class="number">0</span>],</span><br><span class="line">  [ <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>,  <span class="number">3</span>, -<span class="number">1</span>],</span><br><span class="line">  [ <span class="number">0</span>, -<span class="number">1</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>, -<span class="number">1</span>,  <span class="number">2</span>]])</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Calculation"><a href="#Calculation" class="headerlink" title="Calculation"></a>Calculation</h3><p>現在先假設我們已經知道分群的結果了，並將結果以0,1的形式表示為一個matrix，令這個結果為X，下面結果是我隨便分的，分3群，<code>X[i][j]==1</code>表示node<code>i</code>屬於cluster<code>j</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = np.array([</span><br><span class="line">  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br></pre></td></tr></table></figure>
<ol>
<li><p>Diagonal Degree Matrix 解釋<br>我們先將X的轉置矩陣與D做內積(<code>X.T.dot(D)</code>):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br></pre></td></tr></table></figure>
<p>觀察一下結果會發現，這個矩陣就只是是把Degree填到對應的cluster中而已。<br>接著我們再把上面結果與X做內積(<code>X.T.dot(D).dot(X)</code>):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>]])</span><br></pre></td></tr></table></figure>
<p>這個結果其實就表示<strong>每個cluster的degree總和</strong>。</p>
</li>
<li><p>Adjacency Matrix 解釋<br>接著我們直接將上面公式的D換成A(<code>X.T.dot(A).dot(X)</code>):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>
<p>會發現結果表示在<strong>cluster與cluster間互相連接的edge數</strong>。</p>
</li>
<li><p>Laplacian Matrix 解釋<br>如果我們將兩個結果相減的話，會發現每一行的第i個元素(對角)就是我們想要計算的cut數(分子部分)!!!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[ <span class="number">4</span>, -<span class="number">2</span>, -<span class="number">2</span>],  <span class="comment"># i=0, 4</span></span><br><span class="line">       [-<span class="number">2</span>,  <span class="number">3</span>, -<span class="number">1</span>],  <span class="comment"># i=1, 3</span></span><br><span class="line">       [-<span class="number">2</span>, -<span class="number">1</span>,  <span class="number">3</span>]]) <span class="comment"># i=2, 3</span></span><br></pre></td></tr></table></figure>
<p>接著我們另外計算每個cluster裡面共有多少個node，我們可以將X的轉置後與自己相乘(<code>X.T.dot(X)</code>):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>
<p>最後將對角的結果相除後加起來就是算平均就得到Ratio Cut的分數啦~~~<br>(我這邊直接矩陣相除，大家可以自己算。)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[ <span class="number">2.</span> , -inf, -inf],</span><br><span class="line">       [-inf,  <span class="number">1.</span> , -inf],</span><br><span class="line">       [-inf, -inf,  <span class="number">1.5</span>]])</span><br></pre></td></tr></table></figure></li>
</ol>
<p>根據上面矩陣運算的過程，我們能將公式重新整理為:<br><img src="/../images/2023/04/27/ratio_cut_2.png" alt="ratio cut formula extended"></p>
<p>在第三行的部分，我們另外對X進行標準化(同除以分母)變成了<code>X prime</code>。</p>
<h3 id="Minimize"><a href="#Minimize" class="headerlink" title="Minimize"></a>Minimize</h3><p>回到最一開始的問題，我們的目標是要最小化ratio cut的分數，方法就是透過上面的公式去求解<code>X prime</code>矩陣，難過的是，還記的X矩陣裡最一開始只能填入0跟1嗎，想要在這樣嚴格的限制下求出最佳解是個<strong>NP-hard</strong>的問題。<br>不過不要灰心，我們還是可以放寬條件，套用近似演算法，其中一種方法就是接下來要介紹的Spectral Clustering~~~</p>
<h2 id="Spectral-Clustering"><a href="#Spectral-Clustering" class="headerlink" title="Spectral Clustering"></a>Spectral Clustering</h2><p>Spectral Clustering 基於ratio cut，不過X矩陣中可以填入的值變成介於0~1之間，在放寬條件後，這個最小化問題的解可以被證明是求解Laplacian Matrix的前k小個特徵值的特徵向量。</p>
<ol>
<li><p>Eigenvalue &amp; Eigenvactors<br>我們可以用<code>np.linalg.eig</code>來替我們計算特徵值與特徵向量，並使用<code>np.argsort</code>來替我們找出最小的k個特徵向量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># calculate eigenvalue and eigenvector</span></span><br><span class="line">eig_value, eig_vector = np.linalg.eig(L)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get eigenvector with smallest eigenvalue</span></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">top_k = np.argsort(eig_value)[:k]</span><br><span class="line">top_k_vector = eig_vector[:, top_k]</span><br></pre></td></tr></table></figure>
<p>得到的結果如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[ <span class="number">0.37796447</span>, -<span class="number">0.45244521</span>, -<span class="number">0.41243936</span>],</span><br><span class="line">       [ <span class="number">0.37796447</span>,  <span class="number">0.17351892</span>, -<span class="number">0.08541899</span>],</span><br><span class="line">       [ <span class="number">0.37796447</span>,  <span class="number">0.54280925</span>, -<span class="number">0.41243936</span>],</span><br><span class="line">       [ <span class="number">0.37796447</span>,  <span class="number">0.32598548</span>, -<span class="number">0.08541899</span>],</span><br><span class="line">       [ <span class="number">0.37796447</span>, -<span class="number">0.58986844</span>, -<span class="number">0.08541899</span>],</span><br><span class="line">       [ <span class="number">0.37796447</span>, -<span class="number">0.09036404</span>,  <span class="number">0.37705765</span>],</span><br><span class="line">       [ <span class="number">0.37796447</span>,  <span class="number">0.09036404</span>,  <span class="number">0.70407803</span>]])</span><br></pre></td></tr></table></figure>
</li>
<li><p>K-means<br>由於得到的特徵值並無法直接拿來做解釋，因此Spectral Clustering另外使用了K-means來為這些特徵值做分群，因為最小的特徵值為0、特徵向量一定是常數，所以我們可以把它刪去，也就是說，如果我們想要分成k群，那我們至少需要使用k-1個特徵向量。<br>下面程式提供一個簡單的K-means範例，可以根據自己的需求另外設置停止條件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">k_means</span>(<span class="params">X, k, max_iters=<span class="number">10000</span></span>):</span><br><span class="line">    <span class="comment"># randomly initialize centroids</span></span><br><span class="line">    centroids = X[np.random.choice(<span class="built_in">len</span>(X), k, replace=<span class="literal">False</span>)]</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(max_iters):</span><br><span class="line">       <span class="comment"># calculate distances</span></span><br><span class="line">       distances = np.linalg.norm(X[:, np.newaxis] - centroids, axis=<span class="number">2</span>)</span><br><span class="line">       <span class="comment"># assign labels </span></span><br><span class="line">       labels = np.argmin(distances, axis=<span class="number">1</span>)</span><br><span class="line">       <span class="comment"># calculate new centroids</span></span><br><span class="line">       centroids = np.array([np.mean(X[labels == i], axis=<span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)])</span><br><span class="line">    <span class="keyword">return</span> labels</span><br><span class="line"></span><br><span class="line"><span class="comment"># remove first vector</span></span><br><span class="line">features = top_k_vector[:, <span class="number">1</span>:]</span><br><span class="line"><span class="comment"># do k-maens</span></span><br><span class="line">labels = k_means(features, k)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>這樣就得到分群結果啦~~~(注意: 實際執行數字的順序可能不一樣)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>], dtype=int64)</span><br></pre></td></tr></table></figure>

<h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>其實忽略到複雜的數學證明的話，Spectral Clustering的概念還挺直觀的，文章參考了台大資管系的陳建錦教授所使用的上課講義，經過本人吸收轉化撰寫而成。</p>
]]></content>
      <categories>
        <category>Social Network Analysis</category>
      </categories>
      <tags>
        <tag>Spectral Clustering</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>深入瞭解社會網絡分析中的介數中心性(Betweenness Centrality) - 計算方法與Python程式實作</title>
    <url>/posts/betweenness-centrality/</url>
    <content><![CDATA[<h1 id="介紹"><a href="#介紹" class="headerlink" title="介紹"></a>介紹</h1><p><img src="/../images/2023/03/29/Betweenness_Centrality.png" alt="Betweenness Centrality"></p>
<p>介數中心性（Betweenness Centrality）是社會網絡分析中常用的一種指標，用於度量一個節點在整個網絡中扮演了多重要的角色，簡單來說，介數中心性指標評估了一個節點在網絡中擔任了多少條<strong>最短路徑</strong>的中介者角色。</p>
<p>更白話一點，介數中心性看的是一個節點有<strong>多常被其他人經過</strong>，舉例來說：某些公車站點連接了不同的公車路線，這些公車站點對於連接整個公車網絡起著重要的作用，如果這些公車站發生了任何問題，整個公車路線都會受到影響。這些公車站點就是具有高介數中心性的節點。</p>
<span id="more"></span>

<h1 id="計算方法"><a href="#計算方法" class="headerlink" title="計算方法"></a>計算方法</h1><h2 id="介數中心性"><a href="#介數中心性" class="headerlink" title="介數中心性"></a>介數中心性</h2><p><img src="/../images/2023/03/29/formula.png" alt="Betweenness Centrality Formula"></p>
<p>公式中，𝜎(sigma)表示最短路徑的數量，分母的意思是從點s到點w的最短路徑的數量，分子的意思是從點s到點w的最短路徑中經過v點的數量，聽起來有點抽象，我們用下面這張圖來解釋：</p>
<blockquote>
<p><img src="/../images/2023/03/29/simple_network.png" alt="Simple Network"><br>從s點到w點的最短路徑總共有4條，分別是<br><code>s -&gt; 1 -&gt; v -&gt; w</code><br><code>s -&gt; 2 -&gt; v -&gt; w</code><br><code>s -&gt; 3 -&gt; v -&gt; w</code><br><code>s -&gt; 3 -&gt; 4 -&gt; w</code><br>所以分母就是4，其中經過v的有三條所以分子就是3，能算出在s到w的路徑中，v的介數中心性就是<code>3/4</code>。<br>但要注意的是網絡中的任一點都有可能是s或是w，因此若要計算整個網絡當中v的中心性，我們要將網絡中的所有組合加總(Σ)才能得到最後的結果。</p>
</blockquote>
<h2 id="標準化"><a href="#標準化" class="headerlink" title="標準化"></a>標準化</h2><p>聰明的你可能會發現網絡中的節點越多，算出來的值也越大(因為是加總)，因此，為了讓不同網絡之間能被拿來比較，我們要對其進行標準化。</p>
<p><img src="/../images/2023/03/29/normalization_formula.png" alt="Normalization Formula"></p>
<p>其中，分母是Binomial Coefficient，指的是一個網絡的最大可能介數中心性(網路中任選兩點、n-1取2)：<br><img src="/../images/2023/03/29/binomial_coefficient.png" alt="Binomial Coefficient"></p>
<p>(上面標準化公式的假設是網絡是沒有方向性的，如果有方向性的話就不用除2了。)</p>
<h1 id="Python-實作"><a href="#Python-實作" class="headerlink" title="Python 實作"></a>Python 實作</h1><p>網路上很多有關Betweenness Centrality的教學都是直接套<code>networkx</code>套件，但對於程式邏輯究竟如何實現卻是著墨很少，因此接下來要以<strong>不用套件</strong>的方式來實現unweighted graph中Betweenness Centrality的計算！</p>
<p>在開始實作前，我們要先把 unweighted graph 轉換成以下格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">graph = &#123;</span><br><span class="line">    <span class="number">0</span> : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="comment"># 節點 : [他的鄰居]</span></span><br><span class="line">    <span class="number">1</span> : [<span class="number">0</span>, <span class="number">4</span>],</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Pseudo-Code"><a href="#Pseudo-Code" class="headerlink" title="Pseudo Code"></a>Pseudo Code</h2><p>來看看Pseudo Code，這個算法可以計算出graph中各個點的Betweenness Centrality:<br><img src="/../images/2023/03/29/pseudo_code.webp" alt="Pseudo Code for Betweenness Centrality"></p>
<h2 id="程式邏輯"><a href="#程式邏輯" class="headerlink" title="程式邏輯"></a>程式邏輯</h2><p>看了霧煞煞? 沒關係，來解釋一下變數的意涵：</p>
<blockquote>
<p>s: 起點<br>v: 中介點<br>w: 終點<br>S: stack，後進先出的佇列，用來儲存已經遍歷過的節點<br>P: path，s到w的最短路徑中，所經過的鄰居v<br>σ: sigma，s到其他點的最短路徑的數量<br>d: distance，s到其他點的最短距離<br>Q: queue，先進先出的佇列，用來實現BFS<br>δ: delta，介數中心性 (單一個節點s的結果)<br>C: centrality，介數中心性 (sum of delta)</p>
</blockquote>
<p>程式邏輯其實很簡單，先初始化graph的共用的變數(<code>C</code>)，接著就是對每個節點(<code>for s in graph:</code>)做下面三個步驟：</p>
<ol>
<li>初始化變量<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = [] <span class="comment"># stack</span></span><br><span class="line">P = &#123;node: [] <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125; <span class="comment"># path</span></span><br><span class="line">sigma = &#123;node: <span class="number">0</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125; <span class="comment"># 初始化為-1，因為原點是0</span></span><br><span class="line">sigma[s] = <span class="number">1</span> </span><br><span class="line">d = &#123;node: -<span class="number">1</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125; <span class="comment"># distance</span></span><br><span class="line">d[s] = <span class="number">0</span></span><br><span class="line">Q = deque([s]) <span class="comment"># queue</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>這部分就是根據各個變量的性質去初始化而已，唯一需要注意的是距離(<code>d</code>)一開始要初始化為-1，因為原點會是0。</li>
</ul>
<ol start="2">
<li>計算最短路徑 (BFS)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> Q:</span><br><span class="line">    v = Q.popleft()</span><br><span class="line">    S.append(v)</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> graph[v]: <span class="comment"># for neighbor in neighbors</span></span><br><span class="line">        <span class="keyword">if</span> d[w] &lt; <span class="number">0</span>: <span class="comment"># 如果遇到新的節點才去更新他的距離</span></span><br><span class="line">            Q.append(w)</span><br><span class="line">            d[w] = d[v] + <span class="number">1</span></span><br><span class="line">        <span class="comment"># -----------------------------------------------       </span></span><br><span class="line">        <span class="keyword">if</span> d[w] == d[v] + <span class="number">1</span>: <span class="comment"># 判斷v是否在s到w的最短路徑中</span></span><br><span class="line">            sigma[w] += sigma[v] <span class="comment"># 透過v去更新w的最短路徑數</span></span><br><span class="line">            P[w].append(v)</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>在這段程式中，我們可以把他切成兩半，前半段是基本的BFS演算法，比較不一樣的地方在於我們將queue彈出的節點再存入stack中，紀錄所有遍歷過的點；後半段則是從w的鄰居中，去尋找鄰居v是否位於最短路徑當中(透過判斷最短距離是否相差1)，如果是的話那就透過v去更新更新w的sigma，並且將v記錄至w的<code>path</code>中。</li>
</ul>
<ol start="3">
<li>計算Betweenness Centrality<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delta = &#123;node: <span class="number">0</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125;</span><br><span class="line"><span class="comment"># -----------------------------------------------   </span></span><br><span class="line"><span class="keyword">while</span> S:</span><br><span class="line">    w = S.pop() <span class="comment"># 從遍歷過的節點中pop一個</span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> P[w]:</span><br><span class="line">        delta[v] += (sigma[v]/sigma[w]) * (<span class="number">1</span> + delta[w])</span><br><span class="line">    <span class="keyword">if</span> w != s:</span><br><span class="line">        C[w] += delta[w]</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>delta其實也是初始化變量的一部分啦，只是Pseudo Code放在這部分所以寫在這邊。</li>
<li>我們將節點從stack中取出來，去更新這些點的Betweenness Centrality，之所以用stack有兩個原因，第一個原因是我們只需要考慮能到達的節點，第二個原因是我們希望由終點往起點去更新。  </li>
<li>接著我們將每個w的path中的v取出，去更新這些v，<code>sigma[v]/sigma[w]</code>表示經過v的最短路徑數&#x2F;經過w的最短路徑數，這邊比較讓人confused的點應該是，根據前面提到的Betweenness Centrality公式，不是只有<code>sigma[v]/sigma[w]</code>嗎?為什麼要乘以<code>1+delta[w]</code>呢?原因是目前的介數中心性只考慮了v之於w的影響，我們要對其進行修正以納入w後面的節點的影響，我們一樣拿前面用過的例子來解釋：</li>
</ul>
<blockquote>
<p><img src="/../images/2023/03/29/simple_network_2.png" alt="simple network 2"><br>我們把原本的v當成新的w，把點1當成新的v，從s到w的最短路徑有三條，分別是<br><code>s -&gt; v -&gt; w</code><br><code>s -&gt; 2 -&gt; w</code><br><code>s -&gt; 3 -&gt; w</code><br>其中，經過v的只有一條，所以算出來Betweenness Centrality就是<code>sigma[v]/sigma[w] = 1/3</code>，但是!!! v不只在<code>s -&gt; w</code>的最短的路徑上，他也位於<code>s -&gt; w&#39;</code>的最短路徑中，這部分也要考慮進去，前面提到從<code>s -&gt; w&#39;</code>共有4條最短路徑，經過現在的v的只有1條，因此這部分是<code>sigma[v]/sigma[w&#39;] = 1/4</code>，而這個值其實會等於<code>1/3 * 3/4</code>，其中<code>3/4</code>是我們前面算得的<code>delta[w]</code>，因此把<code>s -&gt; w</code>與<code>s -&gt; w&#39;</code>的結果加起來，就會是：<br> <code>(sigma[v]/sigma[w]) + (sigma[v]/sigma[w&#39;])</code><br>&#x3D;<code>(sigma[v]/sigma[w]) + (sigma[v]/sigma[w])*delta[w]</code><br>&#x3D;<code>(sigma[v]/sigma[w]) * (1+delta[w])</code></p>
</blockquote>
<ul>
<li>最後，針對非起點s的節點，我們將其更新到最終結果中。</li>
</ul>
<p>標準化的部分雖然不在Pseudo Code中，但一般來說會順便做，方法如同公式的部分提到的，除以<code>((n-1)*(n-2))/2</code>就好。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> graph:</span><br><span class="line">    C[node] /= ((n-<span class="number">1</span>)*(n-<span class="number">2</span>))/<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="簡化版架構"><a href="#簡化版架構" class="headerlink" title="簡化版架構"></a>簡化版架構</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">betweenness_centrality</span>(<span class="params">graph</span>):</span><br><span class="line">    C = &#123;node: <span class="number">0</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> graph:</span><br><span class="line">        <span class="number">1.</span> 初始化變量</span><br><span class="line">        <span class="number">2.</span> 計算最短路徑 (BFS)</span><br><span class="line">        <span class="number">3.</span> 計算centrality</span><br><span class="line">    </span><br><span class="line">    do Normalization</span><br><span class="line">    <span class="keyword">return</span> C</span><br></pre></td></tr></table></figure>

<h2 id="完整程式碼"><a href="#完整程式碼" class="headerlink" title="完整程式碼"></a>完整程式碼</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">betweenness_centrality</span>(<span class="params">graph</span>):</span><br><span class="line"></span><br><span class="line">    C = &#123;node: <span class="number">0</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125; <span class="comment"># centrality</span></span><br><span class="line">    n = <span class="built_in">len</span>(C)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍歷每個節點</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> graph:</span><br><span class="line">        <span class="comment"># 1. 初始化變量</span></span><br><span class="line">        S = [] <span class="comment"># stack</span></span><br><span class="line">        P = &#123;node: [] <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125; <span class="comment"># path</span></span><br><span class="line">        sigma = &#123;node: <span class="number">0</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125; <span class="comment"># 初始化為-1，因為原點是0</span></span><br><span class="line">        sigma[s] = <span class="number">1</span> </span><br><span class="line">        d = &#123;node: -<span class="number">1</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125; <span class="comment"># distance</span></span><br><span class="line">        d[s] = <span class="number">0</span></span><br><span class="line">        Q = deque([s]) <span class="comment"># queue</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2. 計算最短路徑 (BFS)</span></span><br><span class="line">        <span class="keyword">while</span> Q:</span><br><span class="line">            v = Q.popleft()</span><br><span class="line">            S.append(v)</span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> graph[v]: <span class="comment"># for neighbor in neighbors</span></span><br><span class="line">                <span class="keyword">if</span> d[w] &lt; <span class="number">0</span>: <span class="comment"># 如果遇到新的節點才去更新他的距離</span></span><br><span class="line">                    Q.append(w)</span><br><span class="line">                    d[w] = d[v] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> d[w] == d[v] + <span class="number">1</span>: <span class="comment"># 判斷v是否在s到w的最短路徑中</span></span><br><span class="line">                    sigma[w] += sigma[v] <span class="comment"># 透過v去更新w的最短路徑數</span></span><br><span class="line">                    P[w].append(v)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 計算centrality</span></span><br><span class="line">        delta = &#123;node: <span class="number">0</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125;</span><br><span class="line">        <span class="keyword">while</span> S:</span><br><span class="line">            w = S.pop() <span class="comment"># 從遍歷過的節點中pop一個</span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> P[w]:</span><br><span class="line">                delta[v] += (sigma[v]/sigma[w]) * (<span class="number">1</span> + delta[w])</span><br><span class="line">            <span class="keyword">if</span> w != s:</span><br><span class="line">                C[w] += delta[w]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Normalization</span></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> graph:</span><br><span class="line">        C[node] /= ((n-<span class="number">1</span>)*(n-<span class="number">2</span>))/<span class="number">2</span> <span class="comment"># 將每個節點除以最大可能值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C</span><br></pre></td></tr></table></figure>



<h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>如果真的遇到要計算Betweenness Centrality的情況，當然還是直接用<code>networkx</code>套件裡的<code>betweenness_centrality</code>就好了啦，寫這篇單純是因為網路上都找不到有人說明算法的邏輯，所以希望寫這篇能幫助到其他想了解算法的人。<br>要注意上面的算法建立在所有edge的權重都是一樣的情況下，也就是點與點之間不是1就是0的binary關係，那如果每條edge有不同的權重呢?方法其實也不太意外，就是把程式中計算最短路徑的部分換掉就好了，根據實際情況可以選擇Dijkstra或是Bellman–Ford等。</p>
]]></content>
      <categories>
        <category>Social Network Analysis</category>
      </categories>
      <tags>
        <tag>Graph</tag>
        <tag>Betweenness Centrality</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie (字典樹) - Design Add and Search Words Data Structure</title>
    <url>/posts/trie-2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>寫完上一篇<a href="/posts/trie/">Implement Trie (字典樹)</a>後，沒過兩天LeetCode每日一題又出現Trie的題目了(笑)，題目是<a href="https://leetcode.com/problems/design-add-and-search-words-data-structure/">211. Design Add and Search Words Data Structure</a>，簡單來說就是字典樹加上一點正規表達(regular expression)的概念，舉例來說trie裡有<code>bad</code>，那搜尋<code>b.d</code>的話也要回傳<code>true</code>，詳細題目一樣自己到LeetCode去看囉。</p>
<span id="more"></span>

<h1 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h1><p>如果不考慮正規表達的話，那其實就是最基本的Trie，還不了解trie的話可以參考前一篇文章！但現在多了這個特殊條件後，我們就需要去考慮所有可能，方法是寫一個dfs(Depth First Search)的輔助函式，遇到<code>.</code>的話就將當前節點下的所有子節點再帶入dfs，看最後有沒有符合的單字，只要有其中一個子節點符合的話會提前回傳<code>true</code>，都沒有的話就回傳<code>false</code>。</p>
<p>我們以下面的圖片來說明步驟，假設我們今天搜尋<code>b.t</code>：</p>
<ol>
<li>跟一般的trie一樣，我們會先確認root下有沒有b這個節點，有的話就走到這個節點上。</li>
<li>因為第二個字是<code>.</code>，表示<code>ba</code>跟<code>bo</code>都是我們可以走的路徑，因此我們兩條路都要去訪問，依字母順序我們先訪問<code>ba</code>。</li>
<li><code>ba</code>下面雖然有節點<code>bat</code>，但他不是單字的結尾，所以我們跳出這條路徑。</li>
<li>我們回到上一層，改走<code>bo</code>這條路徑。</li>
<li><code>bot</code>符合我們要找的答案，並且他也是單字的結尾，因此回傳<code>true</code>。</li>
</ol>
<p><img src="/../images/2023/03/20/trie.png" alt="trie"></p>
<h1 id="方法一-Pointers-C"><a href="#方法一-Pointers-C" class="headerlink" title="方法一: Pointers (C++)"></a>方法一: Pointers (C++)</h1><p>重點</p>
<ul>
<li>dfs除了要傳入節點<code>curr</code>，也要記錄目前走到第單字中的第幾個位置<code>start</code>。</li>
<li>遇到<code>.</code>的話就對所有可能路徑再做一次dfs。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    Node* children[<span class="number">26</span>];</span><br><span class="line">    <span class="type">bool</span> is_end = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node* root;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string word;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(Node* curr, <span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=start; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="comment">// 遇到 .</span></span><br><span class="line">            <span class="keyword">if</span> (word[i] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">// 用迴圈造訪所有可能路徑</span></span><br><span class="line">                <span class="keyword">for</span> (Node* next: curr-&gt;children)&#123;</span><br><span class="line">                    <span class="comment">// 路徑不可為空 &amp;&amp; 該路徑有符合答案者</span></span><br><span class="line">                    <span class="keyword">if</span> (next!=<span class="literal">nullptr</span> &amp;&amp; <span class="built_in">dfs</span>(next, i+<span class="number">1</span>))&#123;</span><br><span class="line">                        <span class="comment">// 提前回傳 true</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 全部路徑無答案，回傳 false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (curr-&gt;children[word[i]-<span class="string">&#x27;a&#x27;</span>] != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                curr = curr-&gt;children[word[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr-&gt;is_end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WordDictionary</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addWord</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Node* curr = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> w: word)&#123;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;children[w-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                curr-&gt;children[w-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;children[w-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        curr-&gt;is_end = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = word.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;word = word;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="方法二-Hash-Table-Python"><a href="#方法二-Hash-Table-Python" class="headerlink" title="方法二: Hash Table (Python)"></a>方法二: Hash Table (Python)</h1><p>重點</p>
<ul>
<li>注意要避開<code>#</code>因為他不是一個路徑，否則會報錯。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.root = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addWord</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        curr = self.root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> curr:</span><br><span class="line">                curr[w] = &#123;&#125;</span><br><span class="line">            curr = curr[w]</span><br><span class="line">        curr[<span class="string">&quot;#&quot;</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(word)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">curr, start</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n):</span><br><span class="line">                w = word[i]</span><br><span class="line">                <span class="comment"># 遇到 .</span></span><br><span class="line">                <span class="keyword">if</span> w == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                    <span class="comment"># 用迴圈造訪所有可能路徑</span></span><br><span class="line">                    <span class="keyword">for</span> c <span class="keyword">in</span> curr:</span><br><span class="line">                        <span class="comment"># 避開結尾標記 &amp;&amp; 該路徑有符合答案者</span></span><br><span class="line">                        <span class="keyword">if</span> c!=<span class="string">&quot;#&quot;</span> <span class="keyword">and</span> dfs(curr[c], i+<span class="number">1</span>):</span><br><span class="line">                            <span class="comment"># 提前回傳 true</span></span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    <span class="comment"># 全部路徑無答案，回傳 false</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">elif</span> w <span class="keyword">in</span> curr:</span><br><span class="line">                    curr = curr[w]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#&quot;</span> <span class="keyword">in</span> curr</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(self.root, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Trie</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Implement Trie (字典樹)</title>
    <url>/posts/trie/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天在寫LeetCode每日一題時遇到<a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/">208. Implement Trie (Prefix Tree)</a>，之前因為覺得Trie好像很難所以一直不願面對，但這題就是要跟Trie的直球對決了想躲也躲不掉XD，Anyway，看了一下發現Trie其實蠻好理解的，今天就來認識一下Trie，然後看看這一題可以怎麼寫吧！(Python, C++)</p>
<span id="more"></span>

<h1 id="Trie-介紹"><a href="#Trie-介紹" class="headerlink" title="Trie 介紹"></a>Trie 介紹</h1><p>Trie的中文可以叫做字典樹、字首樹或前綴樹，顧名思義是一種樹狀結構，常被用來檢索文本中的單詞或前綴(prefix)。</p>
<p>字典樹有幾個性質，這裡搭配下方圖片做介紹：</p>
<ol>
<li>每個節點代表一個字符，並且單字的結尾有標記，舉例來說單字”ten”會依序經過t、e、n三個節點，其中n是結尾(綠色)。</li>
<li>節點是可以被共用的，舉例來說”sun”及”sup”就共用了s、u兩個節點。</li>
<li>葉子節點一定是單字結尾，但非葉節點也可以是結尾，舉例來說”an”及”and”分別是兩個單字，其中n及d都是單字的結尾(綠色)。</li>
</ol>
<p><img src="/../images/2023/03/18/trie.png" alt="trie"><br>字典樹的優點是可以快速查找字符串，且可以按照字典序進行排序。但缺點是需要較大的空間來存儲，且插入和刪除操作相對較慢。</p>
<h1 id="實作-Trie"><a href="#實作-Trie" class="headerlink" title="實作 Trie"></a>實作 Trie</h1><p>實作的內容就是一開始提到的LeetCode 208，簡單來說就是要做出初始化、插入、尋找及尋找前綴4個功能，詳細題目可以自己到LeetCode去看。</p>
<p>值得一提的是，Trie 有兩種實作方法，第一個方法相當直覺，就是用指針連結各個節點來模擬出一個樹狀結構；第二個方法則是動態語言限定，我們可以直接用hash table來儲存字符，接下來分別用C++及Python來演示這兩種方法。</p>
<h2 id="方法一-Pointers-C"><a href="#方法一-Pointers-C" class="headerlink" title="方法一: Pointers (C++)"></a>方法一: Pointers (C++)</h2><p>重點</p>
<ul>
<li>英文字母只有26個，所以可以直接使用array，以index(<code>w-&#39;a&#39;</code>)來表示字符。</li>
<li>prefix的部分只要節點存在就OK，但search的部分還要檢查是不是結尾。</li>
<li>另外定義一個struct而不是直接new原本的class，是因為struct的結構比class簡單的多(沒有function)，可以提升執行效率。</li>
<li>使用靜態宣告(array)所以不用擔心memory leak。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">  Node* children[<span class="number">26</span>];</span><br><span class="line">  <span class="type">bool</span> is_word = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node* root;</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Node* curr = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> w: word) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;children[w-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                curr-&gt;children[w-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;children[w-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        curr-&gt;is_word = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Node* curr = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> w: word) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr == <span class="literal">NULL</span> || curr-&gt;children[w-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;children[w-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr-&gt;is_word;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        Node* curr = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> w: prefix) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;children[w-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;children[w-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="方法二-Hash-Table-Python"><a href="#方法二-Hash-Table-Python" class="headerlink" title="方法二: Hash Table (Python)"></a>方法二: Hash Table (Python)</h2><p>重點</p>
<ul>
<li>用特殊符號(#)來標記單字結尾。</li>
<li>因為動態語言中的資料型態是動態決定的，所以Hash Table內可以同時儲存不同資料型態(存下一層&#x2F;存結尾)。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._root = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        curr = self._root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> curr:</span><br><span class="line">                curr[w] = &#123;&#125;</span><br><span class="line">            curr = curr[w]</span><br><span class="line">        curr[<span class="string">&quot;#&quot;</span>] = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        curr = self._root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">in</span> curr:</span><br><span class="line">                curr = curr[w]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> curr.get(<span class="string">&quot;#&quot;</span>, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">startsWith</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        curr = self._root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">in</span> curr:</span><br><span class="line">                curr = curr[w]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h1 id="相關文章"><a href="#相關文章" class="headerlink" title="相關文章"></a>相關文章</h1><p><a href="/posts/trie-2/">Trie (字典樹) - Design Add and Search Words Data Structure</a></p>
<h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>Trie的基本觀念說實在還蠻簡單的，難應該是難在之後的應用，之後有機會看能不能更新一些進階的觀念，像是搜尋引擎之類的。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.youtube.com/watch?v=f48wGD-MuQw">https://www.youtube.com/watch?v=f48wGD-MuQw</a></p>
]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Trie</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
</search>
