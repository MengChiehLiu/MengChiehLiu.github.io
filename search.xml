<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello Hexo！功能全部開起來看起來就很厲害了吧？NexT 常見設定整理 (4)</title>
    <url>/posts/Blog/2023/Hello-Hexo-4/</url>
    <content><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p><img src="/images/2023/04/14/cover.png" alt="cover image" /></p>
<p>Next之所以受到歡迎，一大原因是因為NexT將很多常用的功能都整合進入主題當中，只要修改一下主題設定檔(config)、下載一下插件(plugins)，就能實現大部分的功能，今天就帶大家看一些常見的功能在NexT主題下要如何實現。</p>
<span id="more"></span>
<h1 id="大綱"><a class="markdownIt-Anchor" href="#大綱"></a> 大綱</h1>
<ul>
<li><a href="#%E7%95%99%E8%A8%80%E6%9D%BF">留言板</a></li>
<li><a href="#%E7%89%88%E6%AC%8A%E8%81%B2%E6%98%8E">版權聲明</a></li>
<li><a href="#%E9%96%B1%E8%AE%80%E9%80%B2%E5%BA%A6">閱讀進度</a></li>
<li><a href="#%E5%9B%9E%E5%88%B0%E9%A0%82%E9%83%A8">回到頂部</a></li>
<li><a href="#%E8%A8%AA%E5%AE%A2%E7%B5%B1%E8%A8%88%E3%80%81%E6%96%87%E7%AB%A0%E9%96%B1%E8%AE%80%E7%B5%B1%E8%A8%88">訪客統計、文章閱讀次數</a></li>
<li><a href="#%E6%96%87%E7%AB%A0%E5%AD%97%E6%95%B8%E3%80%81%E9%96%B1%E8%AE%80%E6%99%82%E9%96%93">文章字數、閱讀時間</a></li>
</ul>
<h1 id="功能"><a class="markdownIt-Anchor" href="#功能"></a> 功能</h1>
<h2 id="留言板"><a class="markdownIt-Anchor" href="#留言板"></a> 留言板</h2>
<p>留言板是一個很奇妙的東西，雖然心裡想到底有誰會來留言，但沒有的話又好像少了些什麼，所以姑且還是放一下XD。<br />
NexT支援多種留言版插件，網路上推薦使用的是disqus或utterances (gitalk因為權限要求過高所以沒什麼推薦了)，二選一的情況下，disqus要另外去註冊一個帳號有點麻煩，反觀utterances可以直接連結github repository來儲存評論，且外觀比較簡潔，所以最後決定使用utterances。</p>
<ol>
<li>
<p>到<a href="https://github.com/apps/utterances" title="{rel='nofollow'}">utterances app</a>把app安裝到github上，將權限開給指定的專案repository。(我是直接跟部落格使用同一個，當然你也可以另外開一個新的repository。)</p>
</li>
<li>
<p>找到<code>next/_config.yml</code>中的<code>utterances</code>，將<code>enable</code>改成<code>true</code>，在<code>repo</code>填入剛剛開啟權限的repository名稱，舉例來說我是填<code>MengChiehLiu/MengChiehLiu.github.io</code>，<code>theme</code>參數可以設定不同留言板風格，大家可以自己試試看。</p>
</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">utterances:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">MengChiehLiu/MengChiehLiu.github.io</span></span><br><span class="line">  <span class="attr">issue_term:</span> <span class="string">pathname</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">github-light</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>最後如果你希望留言板只出現在文章頁面，而不要出現在其他page(ex: 標籤頁、分類頁)的話，那要到page下的<code>index.md</code>下修改標頭檔。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: </span><br><span class="line">date: </span><br><span class="line">type: </span><br><span class="line">&lt;!-- 加入下面這一行 --&gt;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h2 id="版權聲明"><a class="markdownIt-Anchor" href="#版權聲明"></a> 版權聲明</h2>
<p>找到<code>next/_config.yml</code>中的<code>creative_commons</code>，將<code>post</code>改成<code>true</code>就可以了，協議的版本可以參考<a href="https://creativecommons.org/about/cclicenses/" title="{rel='nofollow'}">About CC Licenses</a>自己做挑選。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">size:</span> <span class="string">small</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">language:</span></span><br></pre></td></tr></table></figure>
<p>我自己覺得預設的內容就挺不錯的，不過也可以自訂內容，這邊提供一篇不錯的文章給有興趣的人:</p>
<ul>
<li><a href="https://guiblogs.com/hexo30-21/" title="{rel='nofollow'}">Day 21：在 Hexo 增加作者版權聲明（使用 Next 佈景）</a></li>
</ul>
<h2 id="閱讀進度"><a class="markdownIt-Anchor" href="#閱讀進度"></a> 閱讀進度</h2>
<p>找到<code>next/_config.yml</code>中的<code>reading_progress</code>，將<code>enable</code>改成<code>true</code>，開啟後會在網頁頂部/底部顯示閱讀進度條。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">reading_progress:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">start_at:</span> <span class="string">left</span>   <span class="comment"># left/right，從左或右開始</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">top</span>    <span class="comment"># top/bottom，顯示在網頁頂部或底部</span></span><br><span class="line">  <span class="attr">reversed:</span> <span class="literal">false</span>  <span class="comment"># 開啟的話會從全滿開始扣</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;#37c6c0&quot;</span> <span class="comment"># 顏色</span></span><br><span class="line">  <span class="attr">height:</span> <span class="string">3px</span>      <span class="comment"># 進度條寬度</span></span><br></pre></td></tr></table></figure>
<h2 id="回到頂部"><a class="markdownIt-Anchor" href="#回到頂部"></a> 回到頂部</h2>
<p>就是網頁往下滑右下角會出現的那個箭頭，按下去會回到網頁的頂部，找到<code>next/_config.yml</code>中的<code>back2top</code>，將<code>enable</code>改成<code>true</code>。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">back2top:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span>        <span class="comment"># 是否也顯示在側邊欄中</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">false</span>  <span class="comment"># 是否顯示百分比</span></span><br></pre></td></tr></table></figure>
<h2 id="訪客統計-文章閱讀統計"><a class="markdownIt-Anchor" href="#訪客統計-文章閱讀統計"></a> 訪客統計、文章閱讀統計</h2>
<p><a href="https://busuanzi.ibruce.info/" title="{rel='nofollow'}">不蒜子</a>是一款極簡的前端計數工具，NexT已經幫我們將不蒜子整合在主題當中，只要修改<code>next/_config.yml</code>中的<code>busuanzi_count</code>，將<code>enable</code>改成<code>true</code>，就可以啟用訪客統計、文章閱讀次數的功能。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span>  <span class="comment"># 訪客人數</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span>     <span class="comment"># 全站閱覽次數</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span>      <span class="comment"># 文章閱讀統計</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">far</span> <span class="string">fa-eye</span></span><br></pre></td></tr></table></figure>
<h2 id="文章字數-閱讀時間"><a class="markdownIt-Anchor" href="#文章字數-閱讀時間"></a> 文章字數、閱讀時間</h2>
<ol>
<li>下載<code>hexo-word-counter</code>插件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install hexo-word-counter</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo clean</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在Hexo的config檔中(主目錄裡的)加入下面設定</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span>             <span class="comment"># 文章字數</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span>                <span class="comment"># 文章時間</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">false</span>      <span class="comment"># 總文章字數 (顯示在網頁底部)</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">false</span>         <span class="comment"># 總文章時間 (顯示在網頁底部)</span></span><br><span class="line">  <span class="attr">exclude_codeblock:</span> <span class="literal">false</span>  <span class="comment"># 不考慮程式碼部分</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span>                  <span class="comment"># Words Per Minute</span></span><br><span class="line">  <span class="attr">suffix:</span> <span class="string">&quot;mins.&quot;</span>           <span class="comment"># 時間單位</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>wpm官方文檔中給的建議是<br />
Slow ≈ 200<br />
Normal ≈ 275<br />
Fast ≈ 350<br />
如果主要是中文的話可以設300，中英夾雜維持275就好。</p>
</blockquote>
<ol start="3">
<li>這個插件有被整合進NexT當中，在完成前一個步驟後，我們可以修改theme config來調整外觀顯示</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span>        <span class="comment"># 是否顯示文字部分(文章)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span>   <span class="comment"># 是否獨立一行</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">false</span> <span class="comment"># 是否顯示文字部分(網頁底部)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>不顯示文字的話就不會有<code>文章字數：</code>和<code>所需閱讀時間 ≈</code>，只會有最前面的圖示。</p>
</blockquote>
<h2 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h2>
<p>站內搜尋、主選單等功能我在<a href="/posts/Blog/2023/Hello-Hexo-2/">這篇文章</a>中有介紹過了，有興趣的人可以去看看。</p>
<h1 id="預告"><a class="markdownIt-Anchor" href="#預告"></a> 預告</h1>
<p>下一篇文章會帶大家美化部落格!包括更換背景圖片、變更字體以及其他風格設定~</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Hexo！簡單三步驟搞定 Google SEO 和 Bing SEO！(3)</title>
    <url>/posts/Blog/2023/Hello-Hexo-3/</url>
    <content><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p><img src="/images/2023/04/11/google_bing.png" alt="google and bing logo" /></p>
<p>好不容易架設好Hexo網站，下一個問題就是如何讓自己寫的文章被其他人看見，大家可以在Google搜尋中輸入<code>site: 你的網站url</code>，看看Google能不能找到你的網站，沒意外的話Google應該還找不到你的網站，換做是Bing也一樣，原因是這些搜尋引擎還不認識我們的網站，本篇文章會帶大家使用Google Search Console以及Bing Webmaster來進行SEO。<br />
(ps. 網路上已經有很多文章介紹Hexo的Google SEO，但在Bing與ChatGPT合作後，搜尋量有了明顯的提升，因此這篇文章除了介紹Google SEO外，也會介紹Bing SEO)</p>
<span id="more"></span>
<h1 id="sitemap"><a class="markdownIt-Anchor" href="#sitemap"></a> Sitemap</h1>
<p>Sitemap就是網站的地圖，搜尋引擎會透過Sitemap來認識我們的網站架構，我們可以透過下面指令安裝hexo的sitemap套件，之後hexo每次generate都會自動替我們生成sitemap。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap</span><br></pre></td></tr></table></figure>
<h1 id="google-seo"><a class="markdownIt-Anchor" href="#google-seo"></a> Google SEO</h1>
<p>我們要在<a href="https://search.google.com/search-console/about">Google Search Console</a>來設定Google的SEO，</p>
<h2 id="step-1"><a class="markdownIt-Anchor" href="#step-1"></a> Step 1</h2>
<p>我們首先要驗證我們的網頁，選擇<strong>網站前置字元</strong>，將你的網站url複製上去(舉例:<code>https://MengChiehLiu.github.io/</code>)。<br />
<img src="/images/2023/04/11/google_search_console.png" alt="google search console - resource type" /></p>
<h2 id="step-2"><a class="markdownIt-Anchor" href="#step-2"></a> Step 2</h2>
<p>我們使用建議的驗證方式，將html檔案下載下來，放到<code>/source</code>路徑下，我們要將檔案內容改成下面這樣:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 加上這段 --&gt;</span></span><br><span class="line">---</span><br><span class="line">layout: false</span><br><span class="line">---</span><br><span class="line"><span class="comment">&lt;!-- 原本的 --&gt;</span></span><br><span class="line">google-site-verification: googled0a70fa73d09cd65.html</span><br></pre></td></tr></table></figure>
<p>重新部署網頁後(這很重要!)就可以回到Google Search Console按下驗證。<br />
<img src="/images/2023/04/11/google_search_console_2.png" alt="google search console - html verification" /></p>
<h2 id="step-3"><a class="markdownIt-Anchor" href="#step-3"></a> Step 3</h2>
<p>我們到Sitemap頁面中將加入<code>sitemap.xml</code>，這樣Google搜尋引擎就會定期到我們的sitemap去看我們的部落格有沒有更新了。<br />
<img src="/images/2023/04/11/google_search_console_3.png" alt="google search console - sitemap" /></p>
<h1 id="bing-seo"><a class="markdownIt-Anchor" href="#bing-seo"></a> Bing SEO</h1>
<p>我們要在<a href="https://www.bing.com/webmasters/about">Bing Webmaster</a>來設定Bing的SEO，Bing的SEO超級簡單，登入後直接從Google Search Console匯入網站資訊就好。<br />
<img src="/images/2023/04/11/bing_webmaster.png" alt="bing webmaster" /></p>
<h1 id="結語"><a class="markdownIt-Anchor" href="#結語"></a> 結語</h1>
<p>做完這些設定後，Google和Bing會需要一些時間把我們的網站納入搜尋引擎當中，這個過程可能會需要1~2天。<br />
上面這些設定只是讓搜尋引擎找的到我們的網站，屬於最基本的SEO，其他如關鍵字以、網址長度也會影響到網站排名，但最重要的還是文章的品質，所以努力寫出好文章也是SEO的關鍵喔。</p>
<blockquote>
<p>關鍵字設定<br />
可以直接將<code>scaffolds/post.md</code>改成下面格式，之後new post的時候會自動套用下面格式。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">    -</span><br><span class="line">    -</span><br><span class="line">categories: </span><br><span class="line">keywords:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>使用時注意關鍵字與關鍵字之間用逗號分開不留空格!例如:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">keywords: Hexo,SEO,Google,Bing,Google Search Console,Bing Webmaster</span><br></pre></td></tr></table></figure>
<blockquote>
<p>網址長度<br />
hexo預設使用<code>年/月/日/檔案名稱</code>來當作文章url，我們可以修改<code>/_config.yml</code>中的<code>permalink</code>來讓url更加精簡，詳細規則可以參考<a href="https://hexo.io/zh-tw/docs/permalinks.html">hexo官方文檔</a>，我自己是改成下面這樣:</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span> <span class="comment"># default</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:title/</span> <span class="comment"># shorter version</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Hexo！套用 NexT 主題打造簡潔頁面！(2)</title>
    <url>/posts/Blog/2023/Hello-Hexo-2/</url>
    <content><![CDATA[<h1 id="next-介紹"><a class="markdownIt-Anchor" href="#next-介紹"></a> NexT 介紹</h1>
<p>NexT是一個相當受歡迎的Hexo主題，外觀簡潔、功能強大，且持續有在維護，今天會教大家如何套用NexT主題，並啟用標籤頁及站內搜尋等功能。<br />
NexT 官網：<a href="https://theme-next.js.org/">https://theme-next.js.org/</a><br />
NexT GitHub：<a href="https://github.com/next-theme/hexo-theme-next">https://github.com/next-theme/hexo-theme-next</a></p>
<span id="more"></span>
<h1 id="安裝-next"><a class="markdownIt-Anchor" href="#安裝-next"></a> 安裝 NexT</h1>
<p>有兩個方法，第一個方法是透過npm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-theme-next</span><br></pre></td></tr></table></figure>
<p>第二個方法是透過git</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/next-theme/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p>我個人是喜歡第二種方法(git)，因為資源為自動進到themes資料夾當中，如果使用第二種方法(npm)的話資源會跑到node_modules資料夾中，雖然在功能上不會有差異，但未來要對主題的config檔做調整時要找比較久。</p>
<h1 id="套用主題"><a class="markdownIt-Anchor" href="#套用主題"></a> 套用主題</h1>
<p>到<strong>網頁</strong>的config檔(<code>/_config.yml</code>)，搜尋<strong>theme</strong>將主題設置成next就行了。<br />
<img src="/images/2023/03/15/config_theme.png" alt="config_theme" /></p>
<p>另外Next其實有提供4種版面可以做選擇，分別是：💟 <a href="https://theme-next.js.org/muse/">Muse</a> | 🔯 <a href="https://theme-next.js.org/mist/">Mist</a> | ♓️ <a href="https://theme-next.js.org/pisces/">Pisces</a> | ♊️ <a href="https://theme-next.js.org/">Gemini</a></p>
<p>大家可以點擊連結看看自己喜歡哪種版面，預設是使用Muse，如果要做更改的話，到<strong>主題</strong>的config檔(<code>themes/next/_config.yml</code>)中搜尋<strong>Schemes</strong>，將喜歡的佈局取消註解就可以了，另外下面的<strong>darkmode</strong>改成true的話則是可以讓網頁變成黑色模式。<br />
<img src="/images/2023/03/15/next_schemes.png" alt="next_schemes" /></p>
<p>NexT也支援canvas背景動畫，我們可以在<strong>主題</strong>config檔搜尋<strong>canvas_ribbon</strong>，將下方的enable改為true，部屬後網頁背景就會出現酷炫的彩色絲帶動畫了～</p>
<h1 id="添加頭像-avatar"><a class="markdownIt-Anchor" href="#添加頭像-avatar"></a> 添加頭像 avatar</h1>
<ol>
<li>把準備好的圖片放入<code>themes/next/source/images</code>或<code>source/images</code>當中。</li>
<li>在<strong>主題</strong>config檔搜尋<strong>avatar</strong>，修改成自己準備的圖片路徑或者修改圖片名稱使其一致。</li>
</ol>
<blockquote>
<p>rounded改成true的話頭像會是圓形，rotated改成true的話滑鼠移到頭像上時會有快速旋轉的動畫。<br />
<img src="/images/2023/03/15/next_avatar.png" alt="next_avatar" /></p>
</blockquote>
<h1 id="更改網站圖示-favicon"><a class="markdownIt-Anchor" href="#更改網站圖示-favicon"></a> 更改網站圖示 favicon</h1>
<p>我們可以把網站圖示換成自己的圖片，官方文件中建議可以使用<a href="https://realfavicongenerator.net/">Favicon Generator</a>來生成客製化的網站圖示。</p>
<ol>
<li>把準備好的圖片放入<code>themes/next/source/images</code>或<code>source/images</code>當中。</li>
<li>在<strong>主題</strong>config檔搜尋<strong>favicon</strong>，修改成自己準備的圖片路徑或者修改圖片名稱使其一致。<br />
<img src="/images/2023/03/15/next_favicon.png" alt="next_favicon" /></li>
</ol>
<h1 id="社群媒體連結-social-link"><a class="markdownIt-Anchor" href="#社群媒體連結-social-link"></a> 社群媒體連結 social link</h1>
<p>在<strong>主題</strong>config檔搜尋<strong>social</strong>，將自己的社群媒體連結填入並取消註解就可以了，下方的social_icon則可以設定是否顯示icon及icon外觀。<br />
<img src="/images/2023/03/15/next_social.png" alt="next_social" /></p>
<p>Hexo NexT使用<a href="https://fontawesome.com/icons">Font Awesome</a>提供的icons，因此我們可以為新的連結挑選適合的icon，接下來我們來新增一個Linkedin連結看看(包含icon)。</p>
<ol>
<li>先到Font Awesome上搜尋Linkedin，選擇自己喜歡的icon，複製綠色的那段文字。<br />
<img src="/images/2023/03/15/font_awesome_linkedin.png" alt="font_awesome_linkedin" /></li>
<li>依<code>標題: 連結 || 綠色文字</code>的格式在social下加入新的一行，舉例來說。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linkedin: https://www.linkedin.com/in/meng-chieh-liu-615952235/ || fa-brands fa-linkedin</span><br></pre></td></tr></table></figure>
<h1 id="啟用功能選單-menu"><a class="markdownIt-Anchor" href="#啟用功能選單-menu"></a> 啟用功能選單 Menu</h1>
<p>在<strong>主題</strong>config檔搜尋<strong>menu</strong>，可以看到NexT預先幫我們建立好許多功能選單，其中home跟archives是預設就開啟的，我們可以取消註解來啟用其他功能選單，但目前那些頁面還是空的喔！所以我們的下一步就是要建立相應的分頁。<br />
<img src="/images/2023/03/15/next_menu.png" alt="next_menu" /></p>
<p>這邊介紹如何建立tags/categories頁面：</p>
<ol>
<li>建立新頁面</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;tags&quot;</span><br><span class="line">hexo new page &quot;categories&quot;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>找到<code>source/tags/index.md</code>檔案，在檔案中加入<code>type: &quot;tags&quot;</code>，注意這裡的tags要加<strong>雙引號</strong>！！！<br />
(categories比照辦理)<br />
<img src="/images/2023/03/15/tags.png" alt="tags" /></p>
</li>
<li>
<p>在post裡面加入tags/categories，重新部署後這些tags/categories就會出現對應的頁面上啦～<br />
<img src="/images/2023/03/15/post_tags.png" alt="post_tags" /></p>
</li>
</ol>
<h1 id="站內搜尋功能-local-search"><a class="markdownIt-Anchor" href="#站內搜尋功能-local-search"></a> 站內搜尋功能 local search</h1>
<ol>
<li>安裝<code>hexo-generator-searchdb</code>套件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>在<strong>主題</strong>config檔搜尋<strong>local_search</strong>，將enable調為true。<br />
<img src="/images/2023/03/15/next_local_search.png" alt="next_local_search" /></p>
</li>
<li>
<p>在<strong>網頁</strong>config檔加入下面設置。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>重新部署後就能開始使用站內搜尋啦～<br />
<img src="/images/2023/03/15/local_search.png" alt="local_search" /></li>
</ol>
<h1 id="預告"><a class="markdownIt-Anchor" href="#預告"></a> 預告</h1>
<p>下一篇文章將會帶大家做SEO，設定keywords與sitemap讓Google搜的到我們的部落格/文章。</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Hexo！用 Hexo 在 GitHub Pages 上架設個人部落格吧！(1)</title>
    <url>/posts/Blog/2023/Hello-Hexo-1/</url>
    <content><![CDATA[<h1 id="hexo-介紹"><a class="markdownIt-Anchor" href="#hexo-介紹"></a> Hexo 介紹</h1>
<p>Hexo 是一個基於Node.js 的自動化部落格部署框架，有近400種網頁主題可供選擇，支援Markdown語言撰寫文章內容而且部署相當迅速，簡直是自己架設部落格的必備神器呀！什麼？你說之前沒用過Node.js怎麼辦？沒關係，因為我之前也沒用過XD。事實上，只要掌握幾個基本的指令，就能夠架出漂漂亮亮、功能齊全的個人部落格囉！就讓我們一起看下去吧～<br />
Hexo 官網：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a><br />
Hexo GitHub：<a href="https://github.com/hexojs/hexo">https://github.com/hexojs/hexo</a></p>
<span id="more"></span>
<h1 id="前置作業"><a class="markdownIt-Anchor" href="#前置作業"></a> 前置作業</h1>
<ul>
<li>安裝 Node.js<br />
官方載點：<a href="https://nodejs.org/zh-tw/download/">https://nodejs.org/zh-tw/download/</a></li>
</ul>
<blockquote>
<p>進入網站後選擇LTS版本，然後選擇下載安裝程式，我自己是用Windows作業系統，直接點擊Windows icon就開始下載了，下載好後打開安裝程式一路確認到最後就安裝好啦～安裝完成後可以用 <code>npm --version</code> 來確認是否安裝成功。<br />
<img src="/images/2023/03/14/nodejs.png" alt="Node.js" /></p>
</blockquote>
<ul>
<li>安裝 git<br />
官方載點：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></li>
</ul>
<blockquote>
<p>選擇對應的作業系統直接下載就好～這裡一樣以Windows為例，選擇的是Standalone Installer下的64-bit Git for Windows Setup，下載好後打開安裝程式一路確認到最後就安裝好啦～安裝完成後可以用 <code>git --version</code> 來確認是否安裝成功。<br />
<img src="/images/2023/03/14/git.png" alt="git" /></p>
</blockquote>
<ul>
<li>註冊GitHub帳號<br />
官網連結：<a href="https://github.com/">https://github.com/</a></li>
</ul>
<h1 id="安裝-hexo"><a class="markdownIt-Anchor" href="#安裝-hexo"></a> 安裝 Hexo</h1>
<ul>
<li>安裝 Hexo</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化資料夾，並將當前路徑移動到該資料夾下(blog 是資料夾名稱，可以改成自己喜歡的名字)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br></pre></td></tr></table></figure>
<ul>
<li>下載 Hexo 所需套件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>做完上面這些步驟後，我們就可以啟動伺服器來看看目前部落格的樣子囉。</p>
<ul>
<li>啟動伺服器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server #or</span><br><span class="line">hexo s      </span><br></pre></td></tr></table></figure>
<blockquote>
<p>預設主題是landscape，也可以使用其他主題，下一篇文章會教大家如何套用Hexo上的熱門主題nexT！<br />
<img src="/images/2023/03/14/landscape.png" alt="landscape" /></p>
</blockquote>
<h1 id="hexo-架構"><a class="markdownIt-Anchor" href="#hexo-架構"></a> Hexo 架構</h1>
<p>在開始加工我們的網站之前，先來認識一下Hexo的資料夾架構！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">|   ├── draft</span><br><span class="line">|   ├── page</span><br><span class="line">|   └── post</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">├── themes</span><br><span class="line">|   └── yourTheme</span><br><span class="line">|       └── _config.yml</span><br><span class="line">└── _config.yml</span><br></pre></td></tr></table></figure>
<ul>
<li>package.json<br />
用來存放node.js的各種套件，一班情況下不太需要動到這個資料夾。</li>
<li>scaffolds<br />
鷹架資料夾，裡面有三個檔案draft、page與post，分別對應了我們能建立的三種佈局，Hexo會依據這些佈局來生成新的頁面。</li>
<li>source<br />
來源資料夾，用來存放文章、頁面以及圖片等內容，其中_drafts用來存放草稿，_posts用來存放已經發布的文章。</li>
<li>themes<br />
主題資料夾，可以下載自己喜歡的主題放到裡面，在每個主題底下會有一個與主題設定檔，與主題有關的東西都在那裡進行設定。</li>
<li>_config.yml<br />
網頁設定檔，與網頁有關的東西都在這裡進行設定。 (跟主題設定檔不一樣！)</li>
</ul>
<h1 id="config-設置"><a class="markdownIt-Anchor" href="#config-設置"></a> Config 設置</h1>
<p>進到_config.yml檔案中，對Site部分進行修改，可以參考下面的設置：</p>
<blockquote>
<p>subtitle跟description可寫可不寫<br />
language預設是英文，可以改成zh-TW顯示繁體中文<br />
keyword跟Google關鍵字搜尋有關，這裡先忽略不管他，未來有機會再來詳細介紹！<br />
<img src="/images/2023/03/14/config_site.png" alt="config_site" /></p>
</blockquote>
<h1 id="撰寫文章新增頁面"><a class="markdownIt-Anchor" href="#撰寫文章新增頁面"></a> 撰寫文章/新增頁面</h1>
<p>在Hexo當中共有三種佈局，分別是draft、post與page，其中draft跟page屬於文章，page則屬於頁面。</p>
<ul>
<li>post<br />
所有draft都會被存放在_posts資料夾當中，會出現在網頁上。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># post 可以省略</span><br><span class="line">hexo new post &quot;My Post&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>draft<br />
draft是草稿，會另外從放於_drafts資料夾下，且不會出現在網頁上。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new draft &quot;My Draft&quot;</span><br></pre></td></tr></table></figure>
<p>可以用指令將draft轉成post，原理只是換個資料夾而已，其實也可以手動作，反過來手動把post丟到draft也行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo publish &quot;My Draft&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>page<br />
page是功能頁面，常見的有about、tags、categories等，下一篇文章就會介紹如何在nexT主題下建立對應的page！</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;My Page&quot;</span><br></pre></td></tr></table></figure>
<h1 id="生成靜態文件"><a class="markdownIt-Anchor" href="#生成靜態文件"></a> 生成靜態文件</h1>
<p>每次修改config檔或是寫完文章後，記得不要忘記重新生成一次網頁的靜態文件，不然剛剛做的變動網頁上是不會呈現出來的喔！</p>
<ul>
<li>清空原本的靜態文件/暫存<br />
這個步驟相當重要！否則容易出現新加的東西更新不上去的情況。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clear #or</span><br><span class="line">hexo cl</span><br></pre></td></tr></table></figure>
<ul>
<li>生成靜態文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate #or</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<ul>
<li>做完記得打開server確認一下結果！</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server #or</span><br><span class="line">hexo s </span><br></pre></td></tr></table></figure>
<p>這三個指令<br />
非常重要！！！<br />
非常重要！！！<br />
非常重要！！！<br />
簡單來說有動到東西請執行一下就對了！</p>
<h1 id="部署至-github-pages"><a class="markdownIt-Anchor" href="#部署至-github-pages"></a> 部署至 GitHub Pages</h1>
<ol>
<li>
<p>在GitHub中創建一個新的repository (點右上角加號)<br />
<img src="/images/2023/03/14/repository.png" alt="repository" /></p>
</li>
<li>
<p>repository名稱取為<code>user_name.github.io</code>，然後直接create repository<br />
<img src="/images/2023/03/14/repository_create.png" alt="repository_create" /></p>
</li>
<li>
<p>修改網頁_config.yml中的URL設置</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url: https://user_name.github.io/</span><br><span class="line">root: /</span><br></pre></td></tr></table></figure>
<blockquote>
<p>這裡的url是GitHub Pages的網址<br />
root設成 /<br />
<img src="/images/2023/03/14/config_url.png" alt="config_url" /></p>
</blockquote>
<ol start="4">
<li>修改網頁_config.yml中的deploy設置</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/user_name/user_name.github.io.git</span><br></pre></td></tr></table></figure>
<blockquote>
<p>這裡選擇用HTTPS的方式連結，部署時直接輸入帳號密碼就行，也可以用SSH，不過就要設置金鑰，比較麻煩一些<br />
<img src="/images/2023/03/14/config_deploy.png" alt="config_deploy" /></p>
</blockquote>
<ol start="5">
<li>修改完後記得重新生成一次靜態文件</li>
<li>開始部署</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo deploy #or</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>打開GitHub Pages的網址就能看到我們剛剛部署上去的網頁啦！<br />
<img src="/images/2023/03/14/gitpage.png" alt="Alt text" /></li>
</ol>
<h1 id="預告"><a class="markdownIt-Anchor" href="#預告"></a> 預告</h1>
<p>下一篇文章我將會介紹如何套用nexT主題，除了講解外觀設定以外，也將帶著大家打造標籤頁及站內搜尋等功能！</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie (字典樹) - Design Add and Search Words Data Structure</title>
    <url>/posts/DSA/2023/trie-2/</url>
    <content><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>寫完上一篇<a href="/posts/DSA/2023/trie/">Implement Trie (字典樹)</a>後，沒過兩天LeetCode每日一題又出現Trie的題目了(笑)，題目是<a href="https://leetcode.com/problems/design-add-and-search-words-data-structure/">211. Design Add and Search Words Data Structure</a>，簡單來說就是字典樹加上一點正規表達(regular expression)的概念，舉例來說trie裡有<code>bad</code>，那搜尋<code>b.d</code>的話也要回傳<code>true</code>，詳細題目一樣自己到LeetCode去看囉。</p>
<span id="more"></span>
<h1 id="解題思路"><a class="markdownIt-Anchor" href="#解題思路"></a> 解題思路</h1>
<p>如果不考慮正規表達的話，那其實就是最基本的Trie，還不了解trie的話可以參考前一篇文章！但現在多了這個特殊條件後，我們就需要去考慮所有可能，方法是寫一個dfs(Depth First Search)的輔助函式，遇到<code>.</code>的話就將當前節點下的所有子節點再帶入dfs，看最後有沒有符合的單字，只要有其中一個子節點符合的話會提前回傳<code>true</code>，都沒有的話就回傳<code>false</code>。</p>
<p>我們以下面的圖片來說明步驟，假設我們今天搜尋<code>b.t</code>：</p>
<ol>
<li>跟一般的trie一樣，我們會先確認root下有沒有b這個節點，有的話就走到這個節點上。</li>
<li>因為第二個字是<code>.</code>，表示<code>ba</code>跟<code>bo</code>都是我們可以走的路徑，因此我們兩條路都要去訪問，依字母順序我們先訪問<code>ba</code>。</li>
<li><code>ba</code>下面雖然有節點<code>bat</code>，但他不是單字的結尾，所以我們跳出這條路徑。</li>
<li>我們回到上一層，改走<code>bo</code>這條路徑。</li>
<li><code>bot</code>符合我們要找的答案，並且他也是單字的結尾，因此回傳<code>true</code>。</li>
</ol>
<p><img src="/images/2023/03/20/trie.png" alt="trie" /></p>
<h1 id="方法一-pointers-c"><a class="markdownIt-Anchor" href="#方法一-pointers-c"></a> 方法一: Pointers (C++)</h1>
<p>重點</p>
<ul>
<li>dfs除了要傳入節點<code>curr</code>，也要記錄目前走到第單字中的第幾個位置<code>start</code>。</li>
<li>遇到<code>.</code>的話就對所有可能路徑再做一次dfs。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    Node* children[<span class="number">26</span>];</span><br><span class="line">    <span class="type">bool</span> is_end = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node* root;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string word;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(Node* curr, <span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=start; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="comment">// 遇到 .</span></span><br><span class="line">            <span class="keyword">if</span> (word[i] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">// 用迴圈造訪所有可能路徑</span></span><br><span class="line">                <span class="keyword">for</span> (Node* next: curr-&gt;children)&#123;</span><br><span class="line">                    <span class="comment">// 路徑不可為空 &amp;&amp; 該路徑有符合答案者</span></span><br><span class="line">                    <span class="keyword">if</span> (next!=<span class="literal">nullptr</span> &amp;&amp; <span class="built_in">dfs</span>(next, i+<span class="number">1</span>))&#123;</span><br><span class="line">                        <span class="comment">// 提前回傳 true</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 全部路徑無答案，回傳 false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (curr-&gt;children[word[i]-<span class="string">&#x27;a&#x27;</span>] != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                curr = curr-&gt;children[word[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr-&gt;is_end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WordDictionary</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addWord</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Node* curr = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> w: word)&#123;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;children[w-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                curr-&gt;children[w-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;children[w-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        curr-&gt;is_end = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = word.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;word = word;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="方法二-hash-table-python"><a class="markdownIt-Anchor" href="#方法二-hash-table-python"></a> 方法二: Hash Table (Python)</h1>
<p>重點</p>
<ul>
<li>注意要避開<code>#</code>因為他不是一個路徑，否則會報錯。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.root = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addWord</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        curr = self.root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> curr:</span><br><span class="line">                curr[w] = &#123;&#125;</span><br><span class="line">            curr = curr[w]</span><br><span class="line">        curr[<span class="string">&quot;#&quot;</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(word)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">curr, start</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n):</span><br><span class="line">                w = word[i]</span><br><span class="line">                <span class="comment"># 遇到 .</span></span><br><span class="line">                <span class="keyword">if</span> w == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                    <span class="comment"># 用迴圈造訪所有可能路徑</span></span><br><span class="line">                    <span class="keyword">for</span> c <span class="keyword">in</span> curr:</span><br><span class="line">                        <span class="comment"># 避開結尾標記 &amp;&amp; 該路徑有符合答案者</span></span><br><span class="line">                        <span class="keyword">if</span> c!=<span class="string">&quot;#&quot;</span> <span class="keyword">and</span> dfs(curr[c], i+<span class="number">1</span>):</span><br><span class="line">                            <span class="comment"># 提前回傳 true</span></span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    <span class="comment"># 全部路徑無答案，回傳 false</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">elif</span> w <span class="keyword">in</span> curr:</span><br><span class="line">                    curr = curr[w]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#&quot;</span> <span class="keyword">in</span> curr</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(self.root, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DSA</category>
      </categories>
      <tags>
        <tag>Trie</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Hexo！NexT 主題太單調？跟著這些美化步驟為部落格加入個人風格！(5)</title>
    <url>/posts/Blog/2023/Hello-Hexo-5/</url>
    <content><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p><img src="/images/2023/04/17/cover.png" alt="cover" /></p>
<p>Hexo Next雖然已經將許多常見的設定整合到主題當中，但大家都採用一樣的設定的話其實挺無聊的，所以今天要在Hexo Next的基礎上帶大家來美化自己的部落格，為部落格加入<strong>個人風格</strong>，如果還不知道Hexo或者NexT是什麼可以參考我之前寫的<a href="/categories/Hexo/">Hello Hexo！</a>系列文章。</p>
<span id="more"></span>
<h1 id="大綱"><a class="markdownIt-Anchor" href="#大綱"></a> 大綱</h1>
<ul>
<li><a href="#%E5%A5%97%E7%94%A8%E8%83%8C%E6%99%AF%E5%9C%96%E7%89%87">套用背景圖片</a></li>
<li><a href="#%E8%AA%BF%E6%95%B4%E5%8D%80%E5%A1%8A%E9%80%8F%E6%98%8E%E5%BA%A6">調整區塊透明度</a></li>
<li><a href="#%E8%A8%AD%E7%BD%AE%E5%8D%80%E5%A1%8A%E5%9C%93%E8%A7%92">設置區塊圓角</a></li>
<li><a href="#%E6%96%87%E7%AB%A0%E5%8D%80%E5%A1%8A%E7%89%88%E9%9D%A2%E5%AF%AC%E5%BA%A6">文章區塊版面寬度</a></li>
<li><a href="#%E7%A8%8B%E5%BC%8F%E7%A2%BC%E5%8D%80%E5%A1%8A%E4%B8%BB%E9%A1%8C">程式碼區塊主題</a></li>
<li><a href="#%E8%AE%8A%E6%9B%B4%E6%96%87%E5%AD%97%E6%A8%A3%E5%BC%8F">變更文字樣式</a></li>
<li><a href="#%E8%AE%8A%E6%9B%B4%E5%AD%97%E9%AB%94%E9%A1%9E%E5%9E%8B">變更字體類型</a></li>
<li><a href="#%E5%9C%96%E7%89%87%E6%94%BE%E5%A4%A7%E6%AA%A2%E8%A6%96">圖片放大檢視</a></li>
</ul>
<h1 id="功能"><a class="markdownIt-Anchor" href="#功能"></a> 功能</h1>
<h2 id="套用背景圖片"><a class="markdownIt-Anchor" href="#套用背景圖片"></a> 套用背景圖片</h2>
<ol>
<li>準備一張圖片放到<code>themes/next/source/images/</code>路徑中。</li>
<li>到<code>themes/next/_config.yml</code>中，找到<code>custom_file_path</code>，將<code>style</code>的註解取消掉。</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.njk</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.njk</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.njk</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.njk</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.njk</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.njk</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.njk</span></span><br><span class="line">  <span class="comment">#variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在<code>source</code>內新增<code>_data</code>資料夾(<strong>注意是blog的，不是next裡面的!</strong>)，接著在裡面新增一個<code>styles.styl</code>文件。</li>
<li>在<code>styles.styl</code>中加入:</li>
</ol>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>:<span class="built_in">url</span>(/images/background.jpg);  <span class="comment">// 背景圖片位置</span></span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-attachment</span>: fixed;            <span class="comment">// 是否滾動，fixed固定</span></span><br><span class="line">  <span class="attribute">background-size</span>: cover;                  <span class="comment">// 填滿畫面</span></span><br><span class="line">  <span class="attribute">background-position</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="調整區塊透明度"><a class="markdownIt-Anchor" href="#調整區塊透明度"></a> 調整區塊透明度</h2>
<p>套用背景圖片後，你可能會發現你的圖片大部分都被區塊擋住了!為了讓大家看到你美美的圖片，所以我們要來調整一下區跨的透明度，網路上很多調整透明度的方法都沒有用我試過了，最後在<a href="https://hui-shao.cn/next-transparent-background/" title="{rel='nofollow'}">這篇文章</a>中找到讓我滿意的效果，這邊直接講結論，在<code>styles.styl</code>加入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:root &#123;</span><br><span class="line">  --content-bg-color:#ffffffe6;  // 白色半透明</span><br><span class="line">  --content-bg-color:#000000e6;  // 黑色半透明，兩者擇一</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>補充: 上面的設定是直接將區塊換成指定顏色，如果有開啟深色模式可以用黑色半透明，如果沒有的話可以用白色半透明，但切記不要混者用，否則文字會看不清楚。</p>
</blockquote>
<h2 id="設置區塊圓角"><a class="markdownIt-Anchor" href="#設置區塊圓角"></a> 設置區塊圓角</h2>
<ol>
<li>到<code>themes/next/_config.yml</code>中，找到<code>custom_file_path</code>，將<code>variable</code>的註解也取消掉。</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.njk</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.njk</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.njk</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.njk</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.njk</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.njk</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.njk</span></span><br><span class="line">  <span class="attr">variable:</span> <span class="string">source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在<code>source</code>內新增<code>_data</code>資料夾(<strong>注意是blog的，不是next裡面的!</strong>)，接著在裡面新增一個<code>variables.styl</code>文件。</li>
<li>在<code>variables.styl</code>中加入:</li>
</ol>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="variable">$border</span>-radius-inner     = <span class="number">30px</span> <span class="number">30px</span> <span class="number">30px</span> <span class="number">30px</span>;  <span class="comment">// (內角) 左上 右上 右下 左下</span></span><br><span class="line"><span class="variable">$border</span>-radius           = <span class="number">30px</span>;                 <span class="comment">// (外角) 只填一個數字表示4個角</span></span><br></pre></td></tr></table></figure>
<h2 id="文章區塊版面寬度"><a class="markdownIt-Anchor" href="#文章區塊版面寬度"></a> 文章區塊版面寬度</h2>
<p>我們先來看一下預設的寬度(指的是網頁版，手機或平板都是用響應式網頁):</p>
<ul>
<li>Muse / Mist</li>
</ul>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="variable">$content</span>-desktop         = <span class="number">700px</span>   <span class="comment">// when screen width &lt; 1200px</span></span><br><span class="line"><span class="variable">$content</span>-desktop-large   = <span class="number">800px</span>   <span class="comment">// when screen width &gt;= 1200px</span></span><br><span class="line"><span class="variable">$content</span>-desktop-largest = <span class="number">900px</span>   <span class="comment">// when screen width &gt;= 1600px</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Pisces / Gemini</li>
</ul>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="variable">$content</span>-desktop         = <span class="string">&#x27;calc(100% - %s)&#x27;</span> % <span class="built_in">unit</span>(<span class="variable">$content</span>-desktop-<span class="attribute">padding</span> / <span class="number">2</span>, <span class="string">&#x27;px&#x27;</span>)</span><br><span class="line"><span class="variable">$content</span>-desktop-large   = <span class="number">1160px</span></span><br><span class="line"><span class="variable">$content</span>-desktop-largest = <span class="number">73%</span></span><br></pre></td></tr></table></figure>
<p>可以看到不同主題的寬度定義方式不太一樣，如果要更改的話，我們可以到<code>variables.styl</code>中把預設的寬度覆蓋掉，舉例來說我使用Gemini，下面是我採用的設定:</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="variable">$content</span>-desktop         = <span class="number">90%</span>  <span class="comment">// 可以用百分比</span></span><br><span class="line"><span class="variable">$content</span>-desktop-large   = <span class="number">80%</span>  <span class="comment">// 也可用絕對數值 ex: 1000px</span></span><br></pre></td></tr></table></figure>
<h2 id="程式碼區塊主題"><a class="markdownIt-Anchor" href="#程式碼區塊主題"></a> 程式碼區塊主題</h2>
<p>Hexo提供了<code>highlight.js</code>以及<code>prism.js</code>兩種程式碼區塊主題engine，可以參考<a href="https://theme-next.js.org/highlight/" title="{rel='nofollow'}">NexT Highlight Theme Preview</a>來做挑選，以下已我自己套用<code>highlight.js</code>中的<code>night-owl</code>主題為例。</p>
<ol>
<li>到<code>_config.yml</code>中(不是next裡的)，找到<code>highlight</code>，將<code>enable</code>改成true。</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span>   <span class="comment"># 是否顯示行數</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span>  <span class="comment"># 是否自動偵測語言(建議不要開，聽說很吃效能)</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hljs:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">prismjs:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span>       <span class="comment"># 如果是用prismjs的話那就是這裡改true，不要同時開兩個</span></span><br><span class="line">  <span class="attr">preprocess:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>到<code>themes/next/_config.yml</code>中，找到<code>codeblock</code>，根據是否開啟深色模式來填入主題名稱。</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="attr">theme:</span>                      <span class="comment"># highlight.js 改這</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">night-owl</span>          <span class="comment"># (範例)淺色模式下套用night-owl </span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">stackoverflow-dark</span></span><br><span class="line">  <span class="attr">prism:</span>                      <span class="comment"># prism.js 改這</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">prism</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">prism-dark</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span>             <span class="comment"># 是否顯示複製按鈕</span></span><br><span class="line">    <span class="attr">style:</span>                    <span class="comment"># 風格(Available values: default | flat | mac)</span></span><br></pre></td></tr></table></figure>
<h2 id="變更文字樣式"><a class="markdownIt-Anchor" href="#變更文字樣式"></a> 變更文字樣式</h2>
<p>這部分主要是分享我在網路上找到的，覺得很不錯的設定，以下修改都是加在<code>source/_data/styles.styl</code>中。</p>
<ol>
<li>短網址樣式</li>
</ol>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">code</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#c7254e</span>; <span class="comment">//文字顏色</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#f9f2f4</span>; <span class="comment">//底色</span></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>內文連結樣式</li>
</ol>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> a&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0593d3</span>;</span><br><span class="line">  <span class="selector-pseudo">&amp;:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fc6423</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: none;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#fc6423</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>修改選中文字底色</li>
</ol>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* webkit, opera, IE9 */</span></span><br><span class="line"><span class="selector-pseudo">::selection</span> &#123; </span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#00c4b6</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f7f7f7</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* firefox */</span></span><br><span class="line">::-moz-selection &#123; </span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#00c4b6</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f7f7f7</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>修改頁腳配色</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//頁腳統計文字顏色</span><br><span class="line">.footer&#123;</span><br><span class="line">  color: #F0D784</span><br><span class="line">&#125;</span><br><span class="line">//修改頁腳備案鏈接顏色</span><br><span class="line">.footer a&#123;</span><br><span class="line">  color: #F0D784</span><br><span class="line">&#125;</span><br><span class="line">//修改頁腳統計人數的顏色</span><br><span class="line">.footer .with-love&#123;</span><br><span class="line">  color: #F0D784</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="變更字體類型"><a class="markdownIt-Anchor" href="#變更字體類型"></a> 變更字體類型</h2>
<p>NexT可以直接使用<a href="https://fonts.google.com/" title="{rel='nofollow'}">Google Fonts</a>提供的字體，但如果你使用的是繁體中文的話，你會發現其實也就只有兩種可以選而已XDDD，NexT預設是使用<strong>微軟正黑體</strong>，另外一種是<strong>唐宋思源體</strong>，我們今天就來試者把字體換成唐宋思源體看看吧!</p>
<ol>
<li>到<code>themes/next/_config.yml</code>中，找到<code>font</code>將<code>enable</code>改成<code>true</code>，接著更改<code>global</code>的設定(後面的不用改)。</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>              <span class="comment"># 設成true</span></span><br><span class="line">  <span class="attr">host:</span> </span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span>          <span class="comment"># 設成true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Noto</span> <span class="string">Serif</span> <span class="string">TC</span>   <span class="comment"># 唐宋思源體(TC: Traditional Chinese)</span></span><br><span class="line">    <span class="attr">size:</span>                   <span class="comment"># 字體大小，默認為1（16px）</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>這邊特別說明<code>host</code>部分，在台灣基本上是不用設，但因為預設的host是Google的api，所以大陸地區的用戶在看我們的網站時可能會遇到一些穩定性上的問題?如果你部落格的target是整個大中華地區的話可以另外設個host，這邊提供<a href="https://github.com/cdnjs/cdnjs" title="{rel='nofollow'}">cdnjs</a>的鏡像api給有需要的人:</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">host:</span> <span class="string">https://fonts.loli.net</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>補充: 你可能會想問「如果我想要用的字體Google Fonts沒有提供怎麼辦?」，其實也是有辦法使用本地的字體喔，不過這部分稍微麻煩一丟丟，所以之後另外寫一篇文章介紹!</p>
</blockquote>
<h2 id="圖片放大檢視"><a class="markdownIt-Anchor" href="#圖片放大檢視"></a> 圖片放大檢視</h2>
<p>NexT目前提供兩種片放大檢視的工具，分別是<a href="https://fancyapps.com/fancybox/" title="{rel='nofollow'}">FancyBox</a>以及<a href="https://medium-zoom.francoischalifour.com/" title="{rel='nofollow'}">Medium Zoom</a>，可以看一下自己喜歡哪種。</p>
<p>到<code>themes/next/_config.yml</code>中找到<code>fancybox</code>/<code>mediumzoom</code>，將其改為<code>true</code>，注意不要同時開啟兩個功能!!!</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">fancybox:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">mediumzoom:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>補充: FancyBox的功能比較多且可以顯示註解，不過有<a href="https://github.com/ppoffice/hexo-theme-icarus/issues/868" title="{rel='nofollow'}">issue</a>表示FancyBox對於行動裝置似乎不是很友好? 不知道改了沒，Medium Zoom就跟Medium放大圖片的功能一樣，介面比較簡潔。</p>
</blockquote>
<h1 id="參考資料"><a class="markdownIt-Anchor" href="#參考資料"></a> 參考資料</h1>
<p>文章內容大多是網路上的資料整理而來，再加上自己的採坑經驗，如果有遺漏來源的話再麻煩告知補上!</p>
<ul>
<li><a href="https://zenreal.github.io/posts/44730/" title="{rel='nofollow'}">最新 Hexo NexT v7.4.1 主題優化</a></li>
<li><a href="https://hui-shao.cn/next-transparent-background/" title="{rel='nofollow'}">Hexo + NexT8主题配置透明背景过程踩坑小记</a></li>
<li><a href="https://spartazhc.github.io/2020/06/03/Next%E4%B8%BB%E9%A2%98%E5%AD%97%E4%BD%93%E9%85%8D%E7%BD%AE/" title="{rel='nofollow'}">Next主题字体配置</a></li>
</ul>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>系統架構筆記 - 常見的五種部署策略</title>
    <url>/posts/Back-end/2024/deployment-strategies/</url>
    <content><![CDATA[<p><img src="/images/2024/01/16/strategies.png" alt="strategies" /></p>
<p>這篇文章簡單紀錄了常見的五種部署策略: Big Bang Deployment、Rolling Deployment (滾動部署)、Blue-Green Deployment (藍綠部署)、Canary Deployment (金絲雀部署) 與 Shadow Deployment (影子部署)。</p>
<span id="more"></span>
<h1 id="big-bang-deployment"><a class="markdownIt-Anchor" href="#big-bang-deployment"></a> Big Bang Deployment</h1>
<p>名字聽起來很 Dramatic 的部署策略，將舊版本完全下線後部署新版本。</p>
<ul>
<li>優點:
<ul>
<li>easy、一次性完成</li>
</ul>
</li>
<li>缺點:
<ul>
<li>有 downtime，一般生產環境下不會使用</li>
</ul>
</li>
</ul>
<h1 id="rolling-deployment-滾動部署"><a class="markdownIt-Anchor" href="#rolling-deployment-滾動部署"></a> Rolling Deployment (滾動部署)</h1>
<p><img src="/images/2024/01/16/rolling.png" alt="rolling" /></p>
<p>將舊版本逐步 (one by one) 更新為新版本，在這個過程中，舊版本和新版本會共存一段時間。</p>
<ul>
<li>優點:
<ul>
<li>no downtime</li>
</ul>
</li>
<li>缺點:
<ul>
<li>新舊版本間沒有隔離，可能需要處理版本之間的相容性與數據一致性</li>
<li>rollback 也是逐步滾回去，複雜且耗時</li>
</ul>
</li>
</ul>
<h1 id="blue-green-deployment-藍綠部署"><a class="markdownIt-Anchor" href="#blue-green-deployment-藍綠部署"></a> Blue-Green Deployment (藍綠部署)</h1>
<p><img src="/images/2024/01/16/blue-green.png" alt="blue-green" /></p>
<p>同時維護兩個平行的環境，一個為主要環境 (Blue)，另一個為即將上線的新版本 (Green)，於測試環境測試完新版本後，直接將兩個環境的流量做切換。</p>
<ul>
<li>優點:
<ul>
<li>no downtime</li>
<li>直接切換流量即可完成版本切換，rollback 也是</li>
</ul>
</li>
<li>缺點:
<ul>
<li>要同時維護兩個環境，成本高</li>
</ul>
</li>
</ul>
<h1 id="canary-deployment-金絲雀部署"><a class="markdownIt-Anchor" href="#canary-deployment-金絲雀部署"></a> Canary Deployment (金絲雀部署)</h1>
<p><img src="/images/2024/01/16/canary.png" alt="canary" /></p>
<p>將新版本釋出給少量用戶做測試，測試沒問題後才將剩下的部署為新版本。</p>
<ul>
<li>優點:
<ul>
<li>no downtime</li>
<li>能於生產環境中評估新版本效能，降低新版本風險</li>
<li>rollback 較容易</li>
</ul>
</li>
<li>缺點:
<ul>
<li>部署時間較長</li>
<li>某些問題無法靠少量用戶就發現</li>
</ul>
</li>
<li>與 Rolling Deployment 的差異
<ul>
<li>Canary Deployment 是階段式的過程，先部署少部分，確定沒問題才擴大部署</li>
<li>Rolling Deployment 則連續的過程，一次對整個系統做升級，只是過程上是逐步部署</li>
</ul>
</li>
</ul>
<h1 id="shadow-deployment-影子部署"><a class="markdownIt-Anchor" href="#shadow-deployment-影子部署"></a> Shadow Deployment (影子部署)</h1>
<p>同時維護兩個平行的環境，新版本在幕後運行 (in the shadow)，使用者的 request 會被複製一份到新版本用於測試</p>
<ul>
<li>優點:
<ul>
<li>不會對使用者造成實際影響，同時能測試新版本效能</li>
</ul>
</li>
<li>缺點
<ul>
<li>實作上比較困難</li>
<li>成本高</li>
</ul>
</li>
</ul>
<h2 id="其他-feature-toggle"><a class="markdownIt-Anchor" href="#其他-feature-toggle"></a> 其他: Feature Toggle</h2>
<p><img src="/images/2024/01/16/feature-toggle.png" alt="feature-toggle" /></p>
<p>封面的圖片裡還有提到一個 Feature Toggle，概念是在程式中設計一個開關來控制新功能的狀態，可以針對特定用戶開啟，用來觀察新功能的效能、反饋如何，通常是用來做 A/B Test，本質上跟前面提到的幾個部署方法有點差異。</p>
]]></content>
      <categories>
        <category>Back-end</category>
      </categories>
      <tags>
        <tag>System Design</tag>
        <tag>Deployment</tag>
      </tags>
  </entry>
  <entry>
    <title>Implement Trie (字典樹)</title>
    <url>/posts/DSA/2023/trie/</url>
    <content><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>今天在寫LeetCode每日一題時遇到<a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/">208. Implement Trie (Prefix Tree)</a>，之前因為覺得Trie好像很難所以一直不願面對，但這題就是要跟Trie的直球對決了想躲也躲不掉XD，Anyway，看了一下發現Trie其實蠻好理解的，今天就來認識一下Trie，然後看看這一題可以怎麼寫吧！(Python, C++)</p>
<span id="more"></span>
<h1 id="trie-介紹"><a class="markdownIt-Anchor" href="#trie-介紹"></a> Trie 介紹</h1>
<p>Trie的中文可以叫做字典樹、字首樹或前綴樹，顧名思義是一種樹狀結構，常被用來檢索文本中的單詞或前綴(prefix)。</p>
<p>字典樹有幾個性質，這裡搭配下方圖片做介紹：</p>
<ol>
<li>每個節點代表一個字符，並且單字的結尾有標記，舉例來說單字&quot;ten&quot;會依序經過t、e、n三個節點，其中n是結尾(綠色)。</li>
<li>節點是可以被共用的，舉例來說&quot;sun&quot;及&quot;sup&quot;就共用了s、u兩個節點。</li>
<li>葉子節點一定是單字結尾，但非葉節點也可以是結尾，舉例來說&quot;an&quot;及&quot;and&quot;分別是兩個單字，其中n及d都是單字的結尾(綠色)。</li>
</ol>
<p><img src="/images/2023/03/18/trie.png" alt="trie" /><br />
字典樹的優點是可以快速查找字符串，且可以按照字典序進行排序。但缺點是需要較大的空間來存儲，且插入和刪除操作相對較慢。</p>
<h1 id="實作-trie"><a class="markdownIt-Anchor" href="#實作-trie"></a> 實作 Trie</h1>
<p>實作的內容就是一開始提到的LeetCode 208，簡單來說就是要做出初始化、插入、尋找及尋找前綴4個功能，詳細題目可以自己到LeetCode去看。</p>
<p>值得一提的是，Trie 有兩種實作方法，第一個方法相當直覺，就是用指針連結各個節點來模擬出一個樹狀結構；第二個方法則是動態語言限定，我們可以直接用hash table來儲存字符，接下來分別用C++及Python來演示這兩種方法。</p>
<h2 id="方法一-pointers-c"><a class="markdownIt-Anchor" href="#方法一-pointers-c"></a> 方法一: Pointers (C++)</h2>
<p>重點</p>
<ul>
<li>英文字母只有26個，所以可以直接使用array，以index(<code>w-'a'</code>)來表示字符。</li>
<li>prefix的部分只要節點存在就OK，但search的部分還要檢查是不是結尾。</li>
<li>另外定義一個struct而不是直接new原本的class，是因為struct的結構比class簡單的多(沒有function)，可以提升執行效率。</li>
<li>使用靜態宣告(array)所以不用擔心memory leak。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">  Node* children[<span class="number">26</span>];</span><br><span class="line">  <span class="type">bool</span> is_word = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node* root;</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Node* curr = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> w: word) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;children[w-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                curr-&gt;children[w-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;children[w-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        curr-&gt;is_word = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Node* curr = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> w: word) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr == <span class="literal">NULL</span> || curr-&gt;children[w-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;children[w-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr-&gt;is_word;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        Node* curr = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> w: prefix) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;children[w-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;children[w-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="方法二-hash-table-python"><a class="markdownIt-Anchor" href="#方法二-hash-table-python"></a> 方法二: Hash Table (Python)</h2>
<p>重點</p>
<ul>
<li>用特殊符號(#)來標記單字結尾。</li>
<li>因為動態語言中的資料型態是動態決定的，所以Hash Table內可以同時儲存不同資料型態(存下一層/存結尾)。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._root = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        curr = self._root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> curr:</span><br><span class="line">                curr[w] = &#123;&#125;</span><br><span class="line">            curr = curr[w]</span><br><span class="line">        curr[<span class="string">&quot;#&quot;</span>] = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        curr = self._root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">in</span> curr:</span><br><span class="line">                curr = curr[w]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> curr.get(<span class="string">&quot;#&quot;</span>, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">startsWith</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        curr = self._root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">in</span> curr:</span><br><span class="line">                curr = curr[w]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h1 id="相關文章"><a class="markdownIt-Anchor" href="#相關文章"></a> 相關文章</h1>
<p><a href="/posts/DSA/2023/trie-2/">Trie (字典樹) - Design Add and Search Words Data Structure</a></p>
<h1 id="結語"><a class="markdownIt-Anchor" href="#結語"></a> 結語</h1>
<p>Trie的基本觀念說實在還蠻簡單的，難應該是難在之後的應用，之後有機會看能不能更新一些進階的觀念，像是搜尋引擎之類的。</p>
<h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h1>
<p><a href="https://www.youtube.com/watch?v=f48wGD-MuQw">https://www.youtube.com/watch?v=f48wGD-MuQw</a></p>
]]></content>
      <categories>
        <category>DSA</category>
      </categories>
      <tags>
        <tag>Trie</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>系統架構筆記 - 垂直擴展、水平擴展</title>
    <url>/posts/Back-end/2024/scaling/</url>
    <content><![CDATA[<p><img src="/images/2024/01/17/scaling.png" alt="scaling" /></p>
<p>這篇文章會介紹垂直擴展以及水平擴展，並以資料庫的水平擴展為延伸，介紹讀寫分離與資料庫切分 (Sharding)。</p>
<span id="more"></span>
<h1 id="垂直擴展"><a class="markdownIt-Anchor" href="#垂直擴展"></a> 垂直擴展</h1>
<p>這台機器不行那我就換一台更好的。<br />
其實就是升級硬體，好處就是簡單直接，能用垂擴展解決那就優先考慮垂直擴展吧。但垂直擴展是有極限的，而且越好的機器越貴，這時就可以考慮水平擴展。</p>
<h1 id="水平擴展"><a class="markdownIt-Anchor" href="#水平擴展"></a> 水平擴展</h1>
<p>一台機器不行那我就多用幾台。<br />
要實現伺服器的水平擴展比較容易，不外乎就是多開幾台機器，然後做好 load balance，這裡重點介紹<strong>資料庫</strong>的水平擴展，大致上可以分為兩個策略：</p>
<h2 id="讀寫分離"><a class="markdownIt-Anchor" href="#讀寫分離"></a> 讀寫分離</h2>
<p>在原本的資料庫 (主節點) 外添加幾個從資料庫 (從節點) ，向主節點寫入資料，讀取時則優先自從節點讀取。讀寫分離會遇到幾個問題：</p>
<ol>
<li><strong>最終一致性問題</strong><br />
由於從節點的數據是自主節點同步過來，因此中間勢必存在一時間差，可能導致從節點的數據不是最即時的數據，因此從節點的數據僅滿足最終一致性。</li>
<li><strong>單個主節點</strong><br />
由於主節點仍然只有一個，如果遇到需要大量寫入的作業仍然會出現堵塞，這時候可能要考慮多個主節點的架構，不過就跟前一點一樣會遇到資料同步的問題，還需要考慮同時有多個寫入情況下的 race condition。</li>
</ol>
<h2 id="資料庫切分-partitioning-sharding"><a class="markdownIt-Anchor" href="#資料庫切分-partitioning-sharding"></a> 資料庫切分 (Partitioning / Sharding)</h2>
<p>將一個資料庫 (大資料表) 分割為多個小資料表，並將其儲存在不同節點上，又可以分為<strong>垂直切分</strong>與<strong>水平切分</strong>：<br />
<img src="/images/2024/01/17/sharding.png" alt="sharding" /></p>
<h3 id="垂直切分"><a class="markdownIt-Anchor" href="#垂直切分"></a> 垂直切分</h3>
<p>按照欄位來進行切分，通常可以按照業務功能來做切割，如電商平台中的買家資訊與賣家資訊就可以分開儲存。</p>
<h3 id="水平切分"><a class="markdownIt-Anchor" href="#水平切分"></a> 水平切分</h3>
<p>按照列來進行切分，主要有兩種切分方法：</p>
<ol>
<li><strong>按一定範圍切分</strong><br />
舉例來說 ID &lt;= 10000 為第一個表，接著每 10000 筆資料為一個表，這個做法的好處是<strong>容易新增表</strong>，壞處是<strong>較差的附載平衡</strong>，因為新資料與舊資料的活躍度可能有很大的差異。</li>
<li><strong>使用哈希表切分</strong><br />
將 ID 放入一個 Hash Function 中，如 <code>10 % 3 = 1</code>，根據 Hash 結果找到對應的表，好處是有<strong>較佳的附載平衡</strong>，缺點是<strong>不容易新增表</strong>，新增一個表通常涉及到<strong>修改 Hash Function</strong> 以及原先表的<strong>數據遷移</strong>。</li>
</ol>
<h1 id="參考資料"><a class="markdownIt-Anchor" href="#參考資料"></a> 參考資料</h1>
<p><a href="https://www.digitalocean.com/community/tutorials/understanding-database-sharding">Understanding Database Sharding</a><br />
<a href="https://blog.csdn.net/Dongguabai/article/details/83578092">高并发（水平扩展，垂直扩展）</a><br />
<a href="https://www.twblogs.net/a/5c99f60fbd9eee434fc6c4d5">數據庫的向上擴展和橫向擴展（即水平擴展：讀寫分離、垂直切分、水平切分）</a></p>
]]></content>
      <categories>
        <category>Back-end</category>
      </categories>
      <tags>
        <tag>System Design</tag>
        <tag>Scaling</tag>
      </tags>
  </entry>
  <entry>
    <title>試著自己寫了一個 Hexo 外掛：Hexo + HackMD</title>
    <url>/posts/Blog/2024/hexo-hackmd/</url>
    <content><![CDATA[<h2 id="重點"><a class="markdownIt-Anchor" href="#重點"></a> 重點</h2>
<p>寫了一個 Hexo 外掛 <strong><a href="https://github.com/MengChiehLiu/hexo-hackmd">hexo-hackmd</a></strong> 協助下載 HackMD 筆記到本地端，歡迎大家使用，有問題可以發 <strong><a href="https://github.com/MengChiehLiu/hexo-hackmd/issues">issues</a></strong> 給我。</p>
<span id="more"></span>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>對於使用 Hexo 搭建部落格的人來說，平時都是如何撰寫部落格文章的呢？我自己是蠻喜歡先用 <strong><a href="https://hackmd.io/">HackMD</a></strong> 來編寫文章，寫完之後再把文章複製到本地文件中。</p>
<p>在這個操作中，最麻煩的就是處理圖片了，如果直接在部落格中使用 HackMD 預設的圖片 URL (ex: <a href="https://hackmd.io/_uploads/XXX.png">https://hackmd.io/_uploads/XXX.png</a>)，是顯示不出東西的 (除非你把該筆記公開公開)，但我自己喜歡把圖片跟部落格存在一起，所以通常我都會手動將圖片下載下來並且修改 URL。</p>
<p>偏偏我是個蠻喜歡放圖片的人，當圖片一多起來，修改跟檢查也是要耗上不少時間，但這豈不是變成我在 HackMD 上要檢查一遍，在本地端又要檢查一遍嗎！</p>
<p><img src="/images/2024/04/30/cannot-accept-meme.png" alt="cannot-accept-meme" /></p>
<h2 id="hexo-plugin"><a class="markdownIt-Anchor" href="#hexo-plugin"></a> Hexo Plugin</h2>
<p>說真的功能不是很難實現，就只是打幾隻 API 然後看有沒有圖片把它們替換掉而已，比較不知道如何下手的是將其包裝成 Hexo plugin，畢竟該有的功能大致上都已經有人開發了。</p>
<p>研究了一下，發現也沒有真的動到 Hexo 的核心功能，用 <a href="https://hexo.io/api/console">Hexo API console extension</a> 就輕鬆搞定。</p>
<p>雖然是一個非常簡單的外掛，但從過去只能使用別人開發的外掛，到現在自己寫了一個出來，其實挺有成就感的。</p>
<h2 id="安裝與使用"><a class="markdownIt-Anchor" href="#安裝與使用"></a> 安裝與使用</h2>
<h3 id="install"><a class="markdownIt-Anchor" href="#install"></a> Install</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-hackmd</span><br></pre></td></tr></table></figure>
<h3 id="config"><a class="markdownIt-Anchor" href="#config"></a> Config</h3>
<p>新增下面至 Hexo Config，可以參考 <a href="https://hackmd.io/@hackmd-api/how-to-issue-an-api-token">How to issue an API token</a> 取得 <code>hackmd_token</code>。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">hackmd_token:</span> <span class="string">your_hackmd_token</span></span><br></pre></td></tr></table></figure>
<h3 id="usage"><a class="markdownIt-Anchor" href="#usage"></a> Usage</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo hackmd &lt;url&gt; &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p><code>url</code> 就是 HackMD 筆記的 URL。<br />
<code>title</code> 是文章的檔案名稱，預設是 <code>default-title</code>。</p>
<h3 id="options"><a class="markdownIt-Anchor" href="#options"></a> Options</h3>
<p>預設文章路徑是 <code>source/_posts</code>，預設圖片路徑是 <code>source/images</code>，也可以自己指定路徑，開頭必須是 <code>source/</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo hackmd &lt;url&gt; &lt;title&gt; -p &lt;post_dir&gt; -i &lt;img_dir&gt;</span><br></pre></td></tr></table></figure>
<h3 id="小提醒"><a class="markdownIt-Anchor" href="#小提醒"></a> 小提醒</h3>
<ol>
<li>這個外掛並不會考慮 HackMD 筆記右上角的 title 與 tags，你想要什麼 meta data 就直接寫進去 content 裡，另外這裡的 title 跟檔案名稱沒有關係。</li>
<li>HackMD 貼上的圖片預設 ALT 就是 image，記得要改掉，不然存下來的圖片會被取代掉。</li>
<li>如果你有用一些備份的外掛會備份 config 到公開空間的話，記得要<strong>先把 token 刪掉</strong>。</li>
</ol>
<h2 id="範例"><a class="markdownIt-Anchor" href="#範例"></a> 範例</h2>
<p>大家可以用這個公開發表的網址試試：<a href="https://hackmd.io/PPr2yfn9S3m10WMnHuVepg">https://hackmd.io/PPr2yfn9S3m10WMnHuVepg</a></p>
<p><img src="/images/2024/04/30/hackmd-example.png" alt="hackmd-example" /></p>
<h3 id="指令"><a class="markdownIt-Anchor" href="#指令"></a> 指令</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo hackmd https://hackmd.io/PPr2yfn9S3m10WMnHuVepg adventure time</span><br></pre></td></tr></table></figure>
<h3 id="結果"><a class="markdownIt-Anchor" href="#結果"></a> 結果</h3>
<p>儲存至預設路徑: <code>source/_posts</code><br />
<img src="/images/2024/04/30/post-dir-result.png" alt="post-dir-result" /></p>
<p>儲存至預設路徑: <code>source/images</code><br />
<img src="/images/2024/04/30/image-dir-result.png" alt="image-dir-result" /></p>
<p>我的部落格預覽成果:<br />
<img src="/images/2024/04/30/blog-view.png" alt="blog-view" /></p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB概念介紹 + PyMongo基本CRUD操作教學</title>
    <url>/posts/Back-end/2023/pymongo/</url>
    <content><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p><img src="/images/2023/05/05/cover.png" alt="cover image" /></p>
<p>因為課堂專案的關係需要用到MongoDB所以小學了一下，發現MongoDB真的是很香，撇開資料庫易用性，光是MongoDB Atlas提供每位使用者免費10GB的雲端資料庫空間(免填信用卡)，就很值得你辦個帳號來玩一下了。這篇文章會簡單介紹一下MongoDB，以及如何用python PyMongo完成資料庫的CRUD操作。</p>
<span id="more"></span>
<h1 id="mongodb-atlas"><a class="markdownIt-Anchor" href="#mongodb-atlas"></a> MongoDB Atlas</h1>
<p>MongoDB Atlas是MongoDB的雲端資料庫平台服務，顧名思義你可以把你的資料存在雲端裡面，如果你是用drivers(ex: python, nodejs…)連線進去的話，基本上就是安裝個套件就搞定了，不用額外去下載或是設定一些雜七雜八的東西真的很方便，另外也因為是雲端服務，因此在團隊成員要連線進來也很容易，拿來run一個課堂專案是綽綽有餘了。</p>
<p>因為文章重點會放在MongoDB的觀念與操作，這裡就提供一篇教學讓大家自己看:</p>
<ul>
<li><a href="https://www.tpisoftware.com/tpu/articleDetails/2758" title="{rel='nofollow'}">如何快速地架好自己的MongoDB - MongoDB Atlas介紹</a></li>
</ul>
<p>其實就是跟著指示做，都挺直覺的，雲端供應商的部分我也是選GCP，因為有台灣的region，這邊唯一要注意的是可連線IP的部分，要把IP地址加入名單中才能成功與資料庫建立連線，有個小撇步是只要在名單中加入<code>0.0.0.0</code>，就可以無視當前IP位址隨便連了~</p>
<h1 id="mongodb-introduction"><a class="markdownIt-Anchor" href="#mongodb-introduction"></a> MongoDb Introduction</h1>
<h2 id="datebase-architecture"><a class="markdownIt-Anchor" href="#datebase-architecture"></a> Datebase architecture</h2>
<p>MongoDB屬於<strong>General Purpose Document Database</strong>(文件資料庫)，先來了解一下幾個關鍵字:</p>
<blockquote>
<p><strong>Document</strong>: Basic unit of data<br />
<strong>Collection</strong>: A grouping of documents<br />
<strong>Database</strong>: A container for collections</p>
</blockquote>
<h2 id="document-model"><a class="markdownIt-Anchor" href="#document-model"></a> Document Model</h2>
<p>document是MongoDB的基本資料單位，每個document都以BSON格式儲存(類似JSON格式，但多了一些特殊的資料型態)，與關連式資料庫不同，MongoDB有polymorphic documents的特性，沒有寫死的schema，使用時不需要事先定義欄位、資料型態，相反的你想怎麼存就怎麼存，同個collection裡的document可以長的完全不一樣，<strong>BUT!!!</strong>，有彈性不代表就可以亂存，還是要視實際的使用情境來設計schema才不會害到自己喔。</p>
<h2 id="data-modeling"><a class="markdownIt-Anchor" href="#data-modeling"></a> Data Modeling</h2>
<p>延續前面提到的schema，究竟該如何設計一個好的schema，MongoDB有提供兩個非常明確的原則</p>
<blockquote>
<p>Thinking about the application rather than thinking about how it’s stored.<br />
Data accessed together should be stored todether.</p>
</blockquote>
<p>第一點是在說我們在設計資料庫schema時應該focus在「我們的application如何取用資料」，而不是「如何把資料存好」。<br />
第二點則是與MongoDB的架構有關，因為資料都是以document為單位，因此把會一起使用到的資料都存在同一個document裡面，通常會比存在兩個分別的document裡面來的方便取用。</p>
<h2 id="relationship-types"><a class="markdownIt-Anchor" href="#relationship-types"></a> Relationship types</h2>
<p>照上面這麼說的話，那簡單，全部塞進同個document就對了嗎? 其實也不對，因為每個documnet其實有16MB的size limit，所以我們還是要視情況來建立我們的關聯規則，以下介紹3種關聯規則以及MongoDB的建議的儲存方法。</p>
<ol>
<li>one to one<br />
顧名思義就是一個對一個，以學生資料來說，每位學生都有自己獨特且唯一學號，這時候我們就沒必要把學號另外存在別的document，直接存在一起就好。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#x27;_id&#x27;: ObjectID(...),  # MongoDB預設的_id格式，沒有設定_id的話會自動assign</span><br><span class="line">  &#x27;Name&#x27;: &#x27;Jack&#x27;,</span><br><span class="line">  &#x27;Mobile&#x27;: &#x27;0800-000000&#x27;,</span><br><span class="line">  &#x27;ID&#x27;: &#x27;A0001&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>one to many<br />
現在假設我們還需要存每位學生的家長資料，畢竟每個人的家長資料肯定是不重複的嘛，所以我們還是想存在同一個document裡，這時候我們可以使用<strong>Embedding</strong>的技巧，簡單來說就是巢狀結構加下去就對了XD。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#x27;_id&#x27;: ObjectID(...),</span><br><span class="line">  &#x27;Name&#x27;: &#x27;Jack&#x27;,</span><br><span class="line">  &#x27;Mobile&#x27;: &#x27;0800-000000&#x27;,</span><br><span class="line">  &#x27;ID&#x27;: &#x27;A0001&#x27;,</span><br><span class="line">  &#x27;Parents&#x27;: &#123;</span><br><span class="line">    &#x27;Dad&#x27;: &#123;&#x27;Name&#x27;: &#x27;Bob&#x27;, &#x27;Mobile&#x27;: &#x27;0800-000001&#x27;&#125;,</span><br><span class="line">    &#x27;Mom&#x27;: &#123;&#x27;Name&#x27;: &#x27;Amy&#x27;, &#x27;Mobile&#x27;: &#x27;0800-000002&#x27;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>many to many<br />
繼續前面例子，每個學生每學期都會修很多課，並且同一堂課會有很多學生一起修，這時候我們如果用Embedding的話雖然很方便，但有點太浪費資料庫空間了，會出現很多重複的資料，這時我們可以視情況使用<strong>Referencing</strong>的技巧，基本上跟Embedding很像，改成存用來join的key。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#x27;_id&#x27;: ObjectID(...),</span><br><span class="line">  &#x27;Name&#x27;: &#x27;Jack&#x27;,</span><br><span class="line">  &#x27;Mobile&#x27;: &#x27;0800-000000&#x27;,</span><br><span class="line">  &#x27;ID&#x27;: &#x27;A0001&#x27;,</span><br><span class="line">    &#x27;Parents&#x27;: &#123;</span><br><span class="line">    &#x27;Dad&#x27;: &#123;&#x27;Name&#x27;: &#x27;Bob&#x27;, &#x27;Mobile&#x27;: &#x27;0800-000001&#x27;&#125;,</span><br><span class="line">    &#x27;Mom&#x27;: &#123;&#x27;Name&#x27;: &#x27;Amy&#x27;, &#x27;Mobile&#x27;: &#x27;0800-000002&#x27;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x27;courses&#x27;: [ObjectID(...), ObjectID(...), ...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意的是Embedding跟Referencing的使用時機是看情況決定!不是one to many就一定要用Embedding，也不是many to many就一定要用Referencing，還要考慮<strong>資料規模</strong>，如果one to many，但連出去的資料非常龐大，那一樣要改用Referencing才存得下。</p>
<h1 id="crud-in-pymongo"><a class="markdownIt-Anchor" href="#crud-in-pymongo"></a> CRUD in PyMongo</h1>
<p>以防有人不知道CRUD是什麼，CRUD對應到database的4個基本操作Create、Read、Update、Delete，要在MongoDB操作CRUD有很多方法，除了使用MogoDB自己的CLI外，官方也提供豐富的<a href="https://www.mongodb.com/docs/drivers/" title="{rel='nofollow'}">libraries</a>，以python來說就有兩個libraries，PyMongo負責處理同步連線、Motor負責處理非同步連線，接下來會介紹如何使用PyMongo來操作CRUD。</p>
<h2 id="beforehand"><a class="markdownIt-Anchor" href="#beforehand"></a> Beforehand</h2>
<p>第一步當然是要先安裝套件:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">! pip install pymongo</span><br></pre></td></tr></table></figure>
<p>接著我們import套件並建立連線:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line">client = MongoClient(CONNECTION_STRING)</span><br></pre></td></tr></table></figure>
<p>其中，<code>CONNECTION_STRING</code>的格式長這樣，記得要換成自己的帳號、密碼:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongodb+srv://&lt;user_name&gt;:&lt;password&gt;@thrifty.0xdedx2.mongodb.net/?retryWrites=true&amp;w=majority</span><br></pre></td></tr></table></figure>
<p>這串東西好長喔記不起來怎麼辦? 進入mongodb atlas後，可以在 Connect → Drivers → python 裡找到<br />
<img src="/images/2023/05/05/mongodb_atlas_connect.png" alt="mongodb atlas connect" /><br />
<img src="/images/2023/05/05/mongodb_atlas_connection_string.png" alt="mongodb atlas connection string" /></p>
<p>我們可以直接透過client物件來建立或取用database，可以使用key-value的方式或呼叫object的方式，舉例來說我想要create一個名叫test_database的database，那我可以用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">database = client.test_database <span class="comment"># or</span></span><br><span class="line">database = client[<span class="string">&#x27;test_database&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>同理，我們可以透過db物件來建立或取用collection:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">collection = database.test_collection <span class="comment"># or</span></span><br><span class="line">collection = database[<span class="string">&#x27;test_collection&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>好了，事前工作準備完成!</p>
<h2 id="create"><a class="markdownIt-Anchor" href="#create"></a> Create</h2>
<p>在PyMongo中，我們可以使用<code>insert_one</code>/<code>insert_many</code>來插入新的document:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 要插入的資料</span></span><br><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line">b = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;</span><br><span class="line">c = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;female&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">collection.insert_one(a)       <span class="comment"># 插入一個檔案</span></span><br><span class="line">collection.insert_many([b, c]) <span class="comment"># 插入多個檔案</span></span><br></pre></td></tr></table></figure>
<h2 id="read"><a class="markdownIt-Anchor" href="#read"></a> Read</h2>
<p>在PyMongo中，我們可以使用<code>find_one</code>或<code>find</code>來尋找一個或多個的document:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># find_one會回傳符合條件的第一筆資料(沒放條件的話就是collection的第一筆doc)</span></span><br><span class="line">collection.find_one()</span><br><span class="line"></span><br><span class="line"><span class="comment"># find會回傳所有符合條件的資料，並將其包裝為一個類似iterator的物件(沒放條件的話就是collection裡所有doc)</span></span><br><span class="line">docs = collection.find()</span><br><span class="line"><span class="comment"># 我們可以將該物件放入for迴圈中查看結果</span></span><br><span class="line"><span class="keyword">for</span> doc <span class="keyword">in</span> docs:</span><br><span class="line">  <span class="built_in">print</span>(doc)</span><br></pre></td></tr></table></figure>
<p>我們可以在function中加入條件，來查找符合條件的資料，因為操作都差不多，所以接下來只用<code>find_one</code>做示範。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">collection.find_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;a&#x27;</span>&#125;)</span><br><span class="line">collection.find_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;) <span class="comment"># 可以放多個條件</span></span><br></pre></td></tr></table></figure>
<p>上面的代碼會幫我們找到name等於a的資料，但其實這是一個簡化的寫法，MongoDB在進行條件篩選時通常會透過<strong>Comparison Operators</strong>的幫忙，實際上完整的寫法長這樣:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">collection.find_one(&#123;<span class="string">&#x27;name&#x27;</span>: &#123;<span class="string">&#x27;$eq&#x27;</span>: <span class="string">&#x27;a&#x27;</span>&#125;, <span class="string">&#x27;gender&#x27;</span>: &#123;<span class="string">&#x27;$eq&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>這裡的<code>$eq</code>就是equal to的意思，因為是最基本的操作所以可以直接不寫，另外還有很多用於條件判斷的operator，舉例來說:</p>
<blockquote>
<p><code>$gt</code> : greater to<br />
<code>$lt</code> : lower to<br />
<code>$gte</code> : greater or equal to<br />
<code>$lte</code> : lower or equal to<br />
<code>$ne</code> : not equal to</p>
</blockquote>
<p>除了<strong>Comparison Operators</strong>外，在處理多個條件時，我們通常需要使用<strong>Logical Operators</strong>來幫助我們做多條件的判斷，上面例子同樣因為是基本操作所以可以直接寫，實際上也可以這樣寫:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">collection.find_one(&#123;<span class="string">&#x27;$and&#x27;</span>: [&#123;<span class="string">&#x27;name&#x27;</span>: &#123;<span class="string">&#x27;$eq&#x27;</span>: <span class="string">&#x27;a&#x27;</span>&#125;&#125;, &#123;<span class="string">&#x27;gender&#x27;</span>: &#123;<span class="string">&#x27;$eq&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;&#125;]&#125;)</span><br></pre></td></tr></table></figure>
<p>基本上跟一般程式語言的用法很像，常見的有:</p>
<blockquote>
<p><code>$or</code> : or<br />
<code>$not</code> : not</p>
</blockquote>
<p>上面只介紹了部分的query operators，想了解更多query operators可以參考<a href="https://www.mongodb.com/docs/manual/reference/operator/query/" title="{rel='nofollow'}">這裡</a>。</p>
<h2 id="update"><a class="markdownIt-Anchor" href="#update"></a> Update</h2>
<p>PyMongo中用來更新document的function有三大類，分別是</p>
<ol>
<li><code>replace_one</code></li>
<li><code>update_one</code>/<code>update_many</code></li>
</ol>
<p>差別在於replace會把整個documnet都取代為新的，update則只會去更新document中被指定的部分。兩者在使用上都由三個部分組成，分別是filter、replacement/update和options，其中filter是篩選的條件，寫法跟前面find一樣，replacement/update是要更新的document/部分document，options則是更新時可以設定的選項。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># template</span></span><br><span class="line">collection.replace_one(<span class="built_in">filter</span>, replacement, options) <span class="comment"># 取代符合條件的資料的第一筆資料</span></span><br><span class="line">collection.update_one(<span class="built_in">filter</span>, update, options)       <span class="comment"># 更新符合條件的第一筆資料</span></span><br><span class="line">collection.update_many(<span class="built_in">filter</span>, update, options)      <span class="comment"># 更新符合條件的所有資料</span></span><br></pre></td></tr></table></figure>
<p>要特別留意的是，在update的部分一定要搭配使用<strong>Update Operators</strong>，否則會執行失敗!常用的operators有:</p>
<blockquote>
<p><code>$set</code> : set to new value<br />
<code>$push</code>: appends value to an array<br />
<code>$inc</code> : increased by value</p>
</blockquote>
<p>最後options部分，這邊只提最常被使用到的<code>upsert</code>(update+insert)，預設為<code>False</code>，如果將<code>upsert</code>設為<code>True</code>的話，那就算filter部分沒有找到符合的document，也會順便幫我們執行insert的動作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 尋找name為d的document並取代為新documnet，因為沒有這個document而且upsert=True，所以會直接insert</span></span><br><span class="line">collection.replace_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;d&#x27;</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;arr&#x27;</span>: []&#125;, upsert=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 將name重新命名</span></span><br><span class="line">collection.update_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;d&#x27;</span>&#125;, &#123;<span class="string">&#x27;$set&#x27;</span>: &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;e&#x27;</span>&#125;&#125;)</span><br><span class="line"><span class="comment"># 把item推入array當中</span></span><br><span class="line">collection.update_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;e&#x27;</span>&#125;, &#123;<span class="string">&#x27;$push&#x27;</span>: &#123;<span class="string">&#x27;arr&#x27;</span>: <span class="string">&#x27;item&#x27;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="delete"><a class="markdownIt-Anchor" href="#delete"></a> Delete</h2>
<p>PyMongo中用來刪除document的function是<code>delete_one</code>與<code>delete_many</code>，用法跟find基本一樣~</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">collection.delete_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;a&#x27;</span>&#125;)  <span class="comment"># 刪除符合條件的第一筆資料</span></span><br><span class="line">collection.delete_many(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;a&#x27;</span>&#125;) <span class="comment"># 刪除符合條件的所有資料</span></span><br></pre></td></tr></table></figure>
<h2 id="bulk_write"><a class="markdownIt-Anchor" href="#bulk_write"></a> bulk_write</h2>
<p>前面的操作都一次針對一個條件進行動作，假如我們想要快速地執行多個不同動作該怎麼辦呢? 這時我們可以將原先的CRUD指令包裝成Object，並透過<code>bulk_write</code>來進行批次操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> InsertOne, DeleteMany, ReplaceOne, UpdateOne</span><br><span class="line">result = colection.bulk_write([</span><br><span class="line">    DeleteMany(&#123;&#125;),</span><br><span class="line">    InsertOne(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;),</span><br><span class="line">    InsertOne(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;),</span><br><span class="line">    InsertOne(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;female&#x27;</span>&#125;),</span><br><span class="line">    ReplaceOne(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;d&#x27;</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;arr&#x27;</span>: []&#125;, upsert=<span class="literal">True</span>),</span><br><span class="line">    UpdateOne(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;d&#x27;</span>&#125;, &#123;<span class="string">&#x27;$set&#x27;</span>: &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;e&#x27;</span>&#125;&#125;),</span><br><span class="line">    UpdateOne(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;e&#x27;</span>&#125;, &#123;<span class="string">&#x27;$push&#x27;</span>: &#123;<span class="string">&#x27;arr&#x27;</span>: <span class="string">&#x27;item&#x27;</span>&#125;&#125;)</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h1 id="結語"><a class="markdownIt-Anchor" href="#結語"></a> 結語</h1>
<p>MongoDB在網路上的教學資源真的很豐富，官方也有提供<a href="https://learn.mongodb.com/" title="{rel='nofollow'}">免費課程</a>，想要上手真的不是一件難事，我都邊寫邊懷疑自己寫這篇到底有多大價值，因為網路上其他地方大概也都找的到類似的內容，不過抱持著當做筆記說不定哪天旺季會想回來看的精神，還是乖乖把他寫完了XDDD</p>
]]></content>
      <categories>
        <category>Back-end</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>解決 Hexo NexT 主題 Sidebar 加載緩慢問題</title>
    <url>/posts/Blog/2024/speed-up-sidebar-loading/</url>
    <content><![CDATA[<h2 id="問題說明"><a class="markdownIt-Anchor" href="#問題說明"></a> 問題說明</h2>
<p><img src="/images/2024/04/27/sidebar_slow_new.gif" alt="sidebar slow" /></p>
<p>如上面所展示的，Sidebar 渲染的速度明顯比其他部分要慢上許多。</p>
<span id="more"></span>
<p><img src="/images/2024/04/27/website_score.png" alt="website score" /></p>
<p>透過 <a href="https://pagespeed.web.dev">PageSpeed Insights</a> 幫網站進行評分，經過測試後效能是慘澹的 60 分。畢竟網站速度確確實實是會影響到 Google 的 SEO 評分的，所以勢必得好好正視這個問題。詳情可以參考：<a href="https://www.yesharris.com/seo-basic/page-speed-seo/">SEO重點項目：網站速度測試、速度優化指南</a>。</p>
<h2 id="問題解決"><a class="markdownIt-Anchor" href="#問題解決"></a> 問題解決</h2>
<p>直接說最簡單的解法，因為 Next Config 預設開啟動畫選項 (就是 fadeIn fadeOut 之類的)，要馬直接關閉動畫選項，要馬開啟 <code>async</code>，讓動畫能非同步加載。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">motion:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">async:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/2024/04/27/sidebar_fast_new.gif" alt="sidebar fast" /></p>
<p>可以看到明顯速度快上了不少，看上去協調多了。</p>
<h2 id="網頁加速"><a class="markdownIt-Anchor" href="#網頁加速"></a> 網頁加速</h2>
<p>既然都講到網站速度了，那就順便來看看還可以做什麼優化：</p>
<h3 id="lazy-loading"><a class="markdownIt-Anchor" href="#lazy-loading"></a> Lazy Loading</h3>
<p>可以讓圖片晚點才載入。</p>
<ul>
<li>安裝套件：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-lazyload-image</span><br></pre></td></tr></table></figure>
<ul>
<li>修改 Next Config：</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">lazyload:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="minify"><a class="markdownIt-Anchor" href="#minify"></a> Minify</h3>
<p>簡單來說就是刪除冗餘的檔案，NexT 內建就有 minify 功能。</p>
<ul>
<li>修改 Next Config：</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">minify:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>此外還可以使用 hexo 的外掛 <a href="https://github.com/next-theme/hexo-optimize">hexo-optimize</a>，除了 minify 外，還包括其他優化，如預載資源、將 CSS 直接嵌入 html 等等。</p>
<ul>
<li>安裝套件：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-optimize</span><br></pre></td></tr></table></figure>
<ul>
<li>修改 Hexo Config：</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filter_optimize:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># static resource versioning</span></span><br><span class="line">  <span class="attr">versioning:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">css:</span></span><br><span class="line">    <span class="comment"># minify all css files</span></span><br><span class="line">    <span class="attr">minify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">excludes:</span></span><br><span class="line">    <span class="comment"># use preload to load css elements dynamically</span></span><br><span class="line">    <span class="attr">delivery:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;@fortawesome/fontawesome-free&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;fonts.googleapis.com&#x27;</span></span><br><span class="line">    <span class="comment"># make specific css content inline into the html page</span></span><br><span class="line">    <span class="attr">inlines:</span></span><br><span class="line">      <span class="comment"># support full path only</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">css/main.css</span></span><br><span class="line">  <span class="attr">js:</span></span><br><span class="line">    <span class="comment"># minify all js files</span></span><br><span class="line">    <span class="attr">minify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">excludes:</span></span><br><span class="line">    <span class="comment"># remove the comments in each of the js files</span></span><br><span class="line">    <span class="attr">remove_comments:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">html:</span></span><br><span class="line">    <span class="comment"># minify all html files</span></span><br><span class="line">    <span class="attr">minify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">excludes:</span></span><br><span class="line">  <span class="comment"># set the priority of this plugin,</span></span><br><span class="line">  <span class="comment"># lower means it will be executed first, default of Hexo is 10</span></span><br><span class="line">  <span class="attr">priority:</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>老實說我也不是很清楚這個外掛跟 NexT 內建的 minify 到底差異多少，但實際使用起來各自有各自的效果。</p>
<p>舉例來說 hexo-optimize 雖然有 minify 的功能，但測試後 generate 出來的文件數量確沒有比較少，反倒是 NexT 內建的 minify 開啟後 generate 的文件數有明顯的減少。</p>
<p>不過使用 hexo-optimize 後的確會讓網站加載速度更快，既然如此這裡一律建議 <strong>兩種都用</strong>。</p>
<h2 id="後記"><a class="markdownIt-Anchor" href="#後記"></a> 後記</h2>
<p><img src="/images/2024/04/27/gif_speed.png" alt="gif speed" /></p>
<p>試了一下網站效能的分數還是不太理想，檢查之後發現跟 <strong>Largest Contentful Paint</strong> 有關，原本以為是 gif 檔案太大，所以試著用 <a href="https://ezgif.com/optimize">GIF optimizer</a> 來壓縮 gif 的大小，將檔案大小壓縮了 50% 以上，但這項指標還是沒什麼改善，瞭解之後很可能是因為我的圖片是直接存在 github 的 server 中，實在是快不起來的樣子，解法不是幫圖片搬家、轉格式、不然就是 CDN 了，等之後有時間再來折騰囉… (´・ω・)</p>
<p>不過實際的網站體驗還是好很多啦，也算成功！(精神勝利法)</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title>資料結構筆記 - 布隆過濾器 Bloom Filter</title>
    <url>/posts/DSA/2024/bloom-filter/</url>
    <content><![CDATA[<p><img src="/images/2024/01/10/bloom-filter-new.png" alt="bloom-filter" /></p>
<h1 id="summary"><a class="markdownIt-Anchor" href="#summary"></a> Summary</h1>
<ul>
<li>用途: 用來快速判斷元素是否存在於一個集合中</li>
<li>優點: 快速、節省空間</li>
<li>缺點: 可能有 false positive (不存在但判定為存在)</li>
<li>應用:
<ul>
<li>Check Duplicate: name、email 等是否已被使用</li>
<li>Filters: 過濾惡意請求 (ex: <a href="https://www.explainthis.io/zh-hant/swe/cache-mechanism">Cache penetration</a>)、垃圾郵件等</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h1 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h1>
<p>對元素使用 k 個 Hash Functions，將其映射到長度為 m 的 Array 中，寫入時將映射到的 k 個位置標示為 1，檢查時如果映射到的 k 個位置都命中，表示該元素<strong>可能存在</strong>。</p>
<ol>
<li>
<p>由預期的 <strong>False positive rate (p)</strong> 以及存入的<strong>資料筆數 (n)</strong> 來求出 <strong>Array Size (m)</strong> 以及 <strong>Hash Functions數 (k)</strong></p>
<ul>
<li><strong>False positive rate</strong><br />
<img src="/images/2024/01/10/false-positive-probability.png" alt="false-positive-probability" /></li>
<li><strong>Array size</strong><br />
<img src="/images/2024/01/10/array-size.png" alt="array-size" /></li>
<li><strong>Number of hash functions</strong><br />
<img src="/images/2024/01/10/number-of-hash-functions.png" alt="number-of-hash-functions" /></li>
</ul>
</li>
<li>
<p>選擇 Hash function<br />
可以使用 <strong>Non-Cryptographic Hash</strong> (非密碼雜湊函數)，雖然有 collision 的可能，但足夠好了，而且比較快。<br />
例如: MurmurHash、FarmHash、SpookyHash</p>
</li>
</ol>
<h1 id="實作"><a class="markdownIt-Anchor" href="#實作"></a> 實作</h1>
<p><strong>非原創!</strong> 基本上是下面參考文章中的程式碼，寫的很不錯所以只有小小修改一下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python 3 program to build Bloom Filter </span></span><br><span class="line"><span class="comment"># Install mmh3 and bitarray 3rd party module first </span></span><br><span class="line"><span class="comment"># pip install mmh3 </span></span><br><span class="line"><span class="comment"># pip install bitarray </span></span><br><span class="line"><span class="keyword">import</span> math </span><br><span class="line"><span class="keyword">import</span> mmh3 </span><br><span class="line"><span class="keyword">from</span> bitarray <span class="keyword">import</span> bitarray </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BloomFilter</span>(<span class="title class_ inherited__">object</span>): </span><br><span class="line"></span><br><span class="line">	<span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">	Class for Bloom filter, using murmur3 hash function </span></span><br><span class="line"><span class="string">	&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, items_count, fp_prob</span>): </span><br><span class="line">		<span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">		items_count : int </span></span><br><span class="line"><span class="string">			Number of items expected to be stored in bloom filter </span></span><br><span class="line"><span class="string">		fp_prob : float </span></span><br><span class="line"><span class="string">			False Positive probability in decimal </span></span><br><span class="line"><span class="string">		&#x27;&#x27;&#x27;</span></span><br><span class="line">		<span class="comment"># False possible probability in decimal </span></span><br><span class="line">		self.fp_prob = fp_prob </span><br><span class="line"></span><br><span class="line">		<span class="comment"># Size of bit array to use </span></span><br><span class="line">		self.size = self.get_size(items_count, fp_prob) </span><br><span class="line"></span><br><span class="line">		<span class="comment"># number of hash functions to use </span></span><br><span class="line">		self.hash_count = self.get_hash_count(self.size, items_count) </span><br><span class="line"></span><br><span class="line">		<span class="comment"># Bit array of given size, default all 0 </span></span><br><span class="line">		self.bit_array = bitarray(self.size) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, item</span>): </span><br><span class="line">		<span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">		Add an item in the filter </span></span><br><span class="line"><span class="string">		&#x27;&#x27;&#x27;</span></span><br><span class="line">		digests = [] </span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.hash_count): </span><br><span class="line"></span><br><span class="line">			<span class="comment"># create digest for given item. </span></span><br><span class="line">			<span class="comment"># i work as seed to mmh3.hash() function </span></span><br><span class="line">			<span class="comment"># With different seed, digest created is different </span></span><br><span class="line">			digest = mmh3.<span class="built_in">hash</span>(item, i) % self.size </span><br><span class="line">			digests.append(digest) </span><br><span class="line"></span><br><span class="line">			<span class="comment"># set the bit True in bit_array </span></span><br><span class="line">			self.bit_array[digest] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">self, item</span>): </span><br><span class="line">		<span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">		Check for existence of an item in filter </span></span><br><span class="line"><span class="string">		&#x27;&#x27;&#x27;</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.hash_count): </span><br><span class="line">			digest = mmh3.<span class="built_in">hash</span>(item, i) % self.size </span><br><span class="line">			<span class="keyword">if</span> self.bit_array[digest] == <span class="literal">False</span>: </span><br><span class="line"></span><br><span class="line">				<span class="comment"># if any of bit is False then,its not present </span></span><br><span class="line">				<span class="comment"># in filter </span></span><br><span class="line">				<span class="comment"># else there is probability that it exist </span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">	@staticmethod</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">get_size</span>(<span class="params">n, p</span>): </span><br><span class="line">		<span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">		Return the size of bit array(m) to used using </span></span><br><span class="line"><span class="string">		following formula </span></span><br><span class="line"><span class="string">		m = -(n * lg(p)) / (lg(2)^2) </span></span><br><span class="line"><span class="string">		n : int </span></span><br><span class="line"><span class="string">			number of items expected to be stored in filter </span></span><br><span class="line"><span class="string">		p : float </span></span><br><span class="line"><span class="string">			False Positive probability in decimal </span></span><br><span class="line"><span class="string">		&#x27;&#x27;&#x27;</span></span><br><span class="line">		m = -(n * math.log(p))/(math.log(<span class="number">2</span>)**<span class="number">2</span>) </span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">int</span>(m) </span><br><span class="line"></span><br><span class="line"><span class="meta">	@staticmethod</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">get_hash_count</span>(<span class="params">m, n</span>): </span><br><span class="line">		<span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">		Return the hash function(k) to be used using </span></span><br><span class="line"><span class="string">		following formula </span></span><br><span class="line"><span class="string">		k = (m/n) * lg(2) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		m : int </span></span><br><span class="line"><span class="string">			size of bit array </span></span><br><span class="line"><span class="string">		n : int </span></span><br><span class="line"><span class="string">			number of items expected to be stored in filter </span></span><br><span class="line"><span class="string">		&#x27;&#x27;&#x27;</span></span><br><span class="line">		k = (m/n) * math.log(<span class="number">2</span>) </span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">int</span>(k)</span><br></pre></td></tr></table></figure>
<p>看一下成果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">100000</span> <span class="comment"># Number of items to add </span></span><br><span class="line">p = <span class="number">0.05</span> <span class="comment"># False positive probability </span></span><br><span class="line">  </span><br><span class="line">bloomf = BloomFilter(n,p) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Array size: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(bloomf.size)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of hash functions: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(bloomf.hash_count)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;False positive probability: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(bloomf.fp_prob)) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Add items</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">	bloomf.add(<span class="built_in">str</span>(i))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check false positive rate on Test data</span></span><br><span class="line">fp = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n, <span class="number">2</span>*n):</span><br><span class="line">	<span class="keyword">if</span> bloomf.check(<span class="built_in">str</span>(i)):</span><br><span class="line">		fp += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;False positive rate on test data: &#123;:.4f&#125;&quot;</span>.<span class="built_in">format</span>(fp/n)) </span><br></pre></td></tr></table></figure>
<p>可以看到實際的 FP Rate 與我們設定的非常接近。<br />
<img src="/images/2024/01/10/filter-result.png" alt="filter-result" /></p>
<h1 id="參考文章"><a class="markdownIt-Anchor" href="#參考文章"></a> 參考文章</h1>
<p><a href="https://www.geeksforgeeks.org/bloom-filters-introduction-and-python-implementation/">Bloom Filters – Introduction and Implementation</a></p>
]]></content>
      <categories>
        <category>DSA</category>
      </categories>
      <tags>
        <tag>Bloom Filter</tag>
      </tags>
  </entry>
  <entry>
    <title>遍歷台北捷運109個車站要花多久時間? 基於 Held Karp 算法尋找最佳路線!</title>
    <url>/posts/DSA/2024/MRT-held-karp/</url>
    <content><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p><img src="/images/2024/07/27/image.png" alt="MRT event" /></p>
<p>台北捷運最近推出了一個很瘋狂的<a href="https://web.metro.taipei/event/metrotaipeistamp/">集章全制霸</a>活動，集滿5條捷運路線(不含環狀線)，總共109個車站，就可以抽大獎，到底有誰會閒閒沒事想參加這個活動? 啊，我女朋友剛剛問我要不要參加，沒事沒事，真是個好活動! 問題來了，該如何用最短的時間集齊所有車站並回到出發地呢?</p>
<span id="more"></span>
<p>本文將使用 Held Karp 算法來計算從台北車站出發，遍歷 109 個車站，並在最後回到台北車站所需花費的最短時間與路徑，不想看過程的人也可以直接到最後面看結果。XD</p>
<h2 id="旅行推銷員問題"><a class="markdownIt-Anchor" href="#旅行推銷員問題"></a> 旅行推銷員問題</h2>
<p>肯定有人發現了，這本質就是一個旅行推銷員問題，可以簡稱為TSP問題 (Travelling salesman problem)。借用<a href="https://zh.wikipedia.org/zh-tw/%E6%97%85%E8%A1%8C%E6%8E%A8%E9%94%80%E5%91%98%E9%97%AE%E9%A2%98">維基百科</a>的介紹，其問題內容為「給定一系列城市和每對城市之間的距離，求解訪問每座城市一次並回到起始城市的最短迴路。」</p>
<p>我們可以使用台北捷運開放資料 API 中的 <a href="https://tdx.transportdata.tw/api-service/swagger/basic/268fc230-2e04-471b-a728-a726167c1cfc#/Metro/MetroApi_Line_2091">捷運路線基本資料</a> 來建立 Graph，再搭配 TSP 算法理論上就能算出最佳路徑與花費時間了，為了方便計算先不考慮班次跟轉乘時間了。另外，雖然環狀線不在集章活動的範圍內，但身為一條「捷徑」，肯定還是要考慮進去的。</p>
<ul>
<li>資料格式  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lines = [</span><br><span class="line">    &#123;</span><br><span class="line">    &quot;LineNo&quot;: &quot;BL&quot;,</span><br><span class="line">    &quot;LineID&quot;: &quot;BL&quot;,</span><br><span class="line">    &quot;RouteID&quot;: &quot;BL-1&quot;,</span><br><span class="line">    &quot;TrainType&quot;: 1,</span><br><span class="line">    &quot;TravelTimes&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;Sequence&quot;: 1,</span><br><span class="line">        &quot;FromStationID&quot;: &quot;BL23&quot;,</span><br><span class="line">        &quot;FromStationName&quot;: &#123;</span><br><span class="line">          &quot;Zh_tw&quot;: &quot;南港展覽館&quot;,</span><br><span class="line">          &quot;En&quot;: &quot;Taipei Nangang Exhibition Center&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ToStationID&quot;: &quot;BL22&quot;,</span><br><span class="line">        &quot;ToStationName&quot;: &#123;</span><br><span class="line">          &quot;Zh_tw&quot;: &quot;南港&quot;,</span><br><span class="line">          &quot;En&quot;: &quot;Nangang&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;RunTime&quot;: 112,</span><br><span class="line">        &quot;StopTime&quot;: 0</span><br><span class="line">      &#125;,</span><br><span class="line">      </span><br><span class="line">      ... and more</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li>建 Graph  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">graph = defaultdict(<span class="built_in">dict</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    <span class="keyword">for</span> edge <span class="keyword">in</span> line[<span class="string">&quot;TravelTimes&quot;</span>]:</span><br><span class="line">        start = edge[<span class="string">&#x27;FromStationName&#x27;</span>][<span class="string">&#x27;Zh_tw&#x27;</span>]</span><br><span class="line">        end = edge[<span class="string">&#x27;ToStationName&#x27;</span>][<span class="string">&#x27;Zh_tw&#x27;</span>]</span><br><span class="line">        time = edge[<span class="string">&quot;RunTime&quot;</span>]</span><br><span class="line">        graph[start][end] = time</span><br><span class="line">        graph[end][start] = time</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="held-karp-算法"><a class="markdownIt-Anchor" href="#held-karp-算法"></a> Held Karp 算法</h2>
<p>Held Karp 算法是基於動態規劃來求解TSP問題的一種算法，簡單來說，這個算法會遍歷所有可能的狀態，包括<em>已訪問節點</em>與<em>所在節點</em>，並根據當前狀態下去計算下一步該如何走。</p>
<p>為了記錄所有可能，我們可以用 binary 來表示已訪問節點，1表示已經過，0表示還沒經過，舉例來說</p>
<ul>
<li>000: 表示尚未訪問任何節點</li>
<li>001: 表示已訪問第1個節點</li>
<li>101: 表示已訪問第1跟第3個節點</li>
</ul>
<p>Held Karp 算法理論上能求出最佳解，可惜時間複雜度高，將已訪問節點 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{(2^n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> x 當前節點 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{(n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> x 下一節點 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{(n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>，會得到時間複雜度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{O(n^2 2^n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>Anyway，時間複雜度那麼高，最多也就容許圖中有20~25個節點，台北捷運109個站是要算到天荒地老? 所以我們的下個目標是要將圖縮小!</p>
<blockquote>
<p>BTW, 因為算法需要知道任意兩點之間的成本，所以下文中任意兩點間的距離使用 Dijkstra 來計算最短路徑。</p>
</blockquote>
<h2 id="cut-the-tails-and-circle"><a class="markdownIt-Anchor" href="#cut-the-tails-and-circle"></a> Cut the tails and circle</h2>
<p>仔細觀察捷運圖，會發現大部分捷運尾巴的部分是可以分開計算的，比如民權西路到淡水、大安到動物園等，直覺上來說這些路線肯定只能原路折返，更準確地講我們可以不斷地將 indgree 為 1 的節點移除掉，用剩餘的節點計算就好。</p>
<p>接著看到文湖線與板南線圍起的圓圈，如果你今天要用最快的時間遍歷圓圈內的所有車站，你會怎麼走這個圓圈? 要馬順時鐘繞完要馬逆時鐘繞完，絕對不會有繞一半往回走的情況，所以這一段我們也可以先移除。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tails = [</span><br><span class="line">    (<span class="string">&#x27;淡水&#x27;</span>, <span class="string">&#x27;民權西路&#x27;</span>), (<span class="string">&#x27;新北投&#x27;</span>, <span class="string">&#x27;北投&#x27;</span>), (<span class="string">&#x27;蘆洲&#x27;</span>, <span class="string">&#x27;大橋頭&#x27;</span>), </span><br><span class="line">    (<span class="string">&#x27;迴龍&#x27;</span>, <span class="string">&#x27;頭前庄&#x27;</span>), (<span class="string">&#x27;頂埔&#x27;</span>, <span class="string">&#x27;板橋&#x27;</span>), (<span class="string">&#x27;南勢角&#x27;</span>, <span class="string">&#x27;景安&#x27;</span>), </span><br><span class="line">    (<span class="string">&#x27;新店&#x27;</span>, <span class="string">&#x27;大坪林&#x27;</span>), (<span class="string">&#x27;小碧潭&#x27;</span>, <span class="string">&#x27;七張&#x27;</span>), (<span class="string">&#x27;松山&#x27;</span>, <span class="string">&#x27;南京復興&#x27;</span>), </span><br><span class="line">    (<span class="string">&#x27;動物園&#x27;</span>, <span class="string">&#x27;大安&#x27;</span>), (<span class="string">&#x27;象山&#x27;</span>, <span class="string">&#x27;大安&#x27;</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拆成3段算，否則用最短路徑算會直接走下去</span></span><br><span class="line">circles = [</span><br><span class="line">    (<span class="string">&quot;南京復興&quot;</span>, <span class="string">&quot;內湖&quot;</span>), (<span class="string">&quot;內湖&quot;</span>, <span class="string">&quot;南港&quot;</span>), (<span class="string">&quot;南港&quot;</span>, <span class="string">&quot;忠孝復興&quot;</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="compress-path"><a class="markdownIt-Anchor" href="#compress-path"></a> Compress path</h2>
<p>算了一下，剩下的節點還是太多了啊，這時候就拿出第二招，<strong>壓縮路徑</strong>，留下不重要的節點從路徑中移除。舉例來說，從古亭到景安雖然要經過2站 (頂溪、永安市場)，但這2個站都在同一條線上且沒有分支，可以當作是順便「路過」，所以我們可以把中間的節點都移除，用頭尾的節點做計算就好。</p>
<p>前面提到的圓圈部分其實也能算是一種路線壓縮 (忠孝復興 &lt;----&gt; 南京復興)，只留下頭跟尾，中間部分都省略。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Key Stations</span></span><br><span class="line">key_stations = [</span><br><span class="line">    <span class="string">&#x27;民權西路&#x27;</span>, <span class="string">&#x27;雙連&#x27;</span>, <span class="string">&#x27;中山&#x27;</span>, <span class="string">&#x27;台北車站&#x27;</span>, <span class="string">&#x27;台大醫院&#x27;</span>, <span class="string">&#x27;中正紀念堂&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;中山國小&#x27;</span>, <span class="string">&#x27;行天宮&#x27;</span>, <span class="string">&#x27;松江南京&#x27;</span>, <span class="string">&#x27;忠孝新生&#x27;</span>, <span class="string">&#x27;東門&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;古亭&#x27;</span>, <span class="string">&#x27;南京復興&#x27;</span>, <span class="string">&#x27;忠孝復興&#x27;</span>, <span class="string">&#x27;大安&#x27;</span>, <span class="string">&#x27;北門&#x27;</span>, <span class="string">&#x27;西門&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;小南門&#x27;</span>, <span class="string">&#x27;善導寺&#x27;</span>, <span class="string">&#x27;頭前庄&#x27;</span>, <span class="string">&#x27;板橋&#x27;</span>, <span class="string">&#x27;景安&#x27;</span>, <span class="string">&#x27;大坪林&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># compress path</span></span><br><span class="line">n = <span class="built_in">len</span>(key_stations)</span><br><span class="line">graph = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">sub_paths = defaultdict(<span class="built_in">dict</span>)</span><br><span class="line"><span class="keyword">for</span> start_idx <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> end_idx <span class="keyword">in</span> <span class="built_in">range</span>(start_idx+<span class="number">1</span>, n):</span><br><span class="line">        cost, path = dijkstra(original_graph, key_stations[start_idx], key_stations[end_idx])</span><br><span class="line">        graph[start_idx][end_idx] = cost</span><br><span class="line">        graph[end_idx][start_idx] = cost</span><br><span class="line">        sub_paths[start_idx][end_idx] = path</span><br><span class="line">        sub_paths[end_idx][start_idx] = path[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>如果我們只用頭跟尾去計算最佳路線，那我們要如何保證算法會經過那些被我們刪掉的節點呢? 同樣舉圓圈部分為例，要走入圓圈的前提是其中一段路的起點與終點分別是南京復興或忠孝復興，如果算出來根本不是這樣走呢?</p>
<p>其中一個解決方法是「提供誘因」，引誘算法選擇走這些路線，對於最短路徑算法來說，最大的誘因是什麼呢? 答案就是<strong>距離/時間</strong>，只要將兩點之間的距離/時間設為 0，那算法便會更偏好這條路徑。(當然，最後是會加回去的。)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 引誘路線</span></span><br><span class="line">key_paths = [</span><br><span class="line">    (<span class="string">&quot;忠孝復興&quot;</span>, <span class="string">&quot;南京復興&quot;</span>), (<span class="string">&quot;民權西路&quot;</span>, <span class="string">&quot;頭前庄&quot;</span>), (<span class="string">&quot;西門&quot;</span>, <span class="string">&quot;板橋&quot;</span>),</span><br><span class="line">    (<span class="string">&quot;古亭&quot;</span>, <span class="string">&quot;景安&quot;</span>), (<span class="string">&quot;古亭&quot;</span>, <span class="string">&quot;大坪林&quot;</span>), (<span class="string">&quot;大安&quot;</span>, <span class="string">&quot;東門&quot;</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">adjusted_graph = [row[:] <span class="keyword">for</span> row <span class="keyword">in</span> small_graph]</span><br><span class="line"><span class="keyword">for</span> start, end <span class="keyword">in</span> key_paths:</span><br><span class="line">    start = key_stations.index(start)</span><br><span class="line">    end = key_stations.index(end)</span><br><span class="line">    adjusted_graph[a][b] = <span class="number">0</span></span><br><span class="line">    adjusted_graph[b][a] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>既然這個做法聽起來那麼讚，那就把看起來能壓縮的路線全部壓一遍吧? 很遺憾，也不是所有路線都管用，舉例，從民權西路經中山國中、行天宮到松江南京的路線，就算將距離設為0，在很多情況下算法還是不會經過，而是選擇走其他條路，具體來說究竟哪些可以壓縮哪些不行我也說不清楚，如果有想法的話歡迎提供建議!</p>
<h2 id="算法實現"><a class="markdownIt-Anchor" href="#算法實現"></a> 算法實現</h2>
<h3 id="held-karp"><a class="markdownIt-Anchor" href="#held-karp"></a> Held Karp</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">held_karp</span>(<span class="params">graph, adjusted_graph, start, end</span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    graph: n*n 的 matrix of distance</span></span><br><span class="line"><span class="string">    adjusted_graph: n*n 的 matrix of adjusted distance</span></span><br><span class="line"><span class="string">    start: (int) 起點的 index</span></span><br><span class="line"><span class="string">    end: (int) 終點的 index</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">len</span>(adjusted_graph)</span><br><span class="line">    dp = [[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> &lt;&lt; n)]</span><br><span class="line">    parent = [[-<span class="number">1</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> &lt;&lt; n)]  <span class="comment"># 用來追蹤路徑</span></span><br><span class="line">    dp[<span class="number">1</span> &lt;&lt; start][start] = <span class="number">0</span>  <span class="comment"># 起點，start</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> mask <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(<span class="number">1</span> &lt;&lt; n)):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (mask &amp; (<span class="number">1</span> &lt;&lt; i)):</span><br><span class="line">                <span class="keyword">continue</span>  <span class="comment"># 節點 i 不在當前的子集中</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> mask &amp; (<span class="number">1</span> &lt;&lt; j):</span><br><span class="line">                    <span class="keyword">continue</span>  <span class="comment"># 節點 j 已經在子集中</span></span><br><span class="line">                new_mask = mask | (<span class="number">1</span> &lt;&lt; j) <span class="comment"># 將節點 j 加入子集</span></span><br><span class="line">                <span class="keyword">if</span> dp[new_mask][j] &gt; dp[mask][i] + adjusted_graph[i][j]:</span><br><span class="line">                    dp[new_mask][j] = dp[mask][i] + adjusted_graph[i][j]</span><br><span class="line">                    parent[new_mask][j] = i</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 計算到達終點的最小成本</span></span><br><span class="line">    min_cost = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    last_node = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        cost = dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][i] + graph[i][end] <span class="comment"># 回起點所花費的成本要用原本的 graph 做計算</span></span><br><span class="line">        <span class="keyword">if</span> min_cost &gt; cost:</span><br><span class="line">            min_cost = cost</span><br><span class="line">            last_node = i</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重建路徑</span></span><br><span class="line">    path = []</span><br><span class="line">    mask = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> last_node != -<span class="number">1</span>:</span><br><span class="line">        path.append(last_node)</span><br><span class="line">        new_mask = mask ^ (<span class="number">1</span> &lt;&lt; last_node)</span><br><span class="line">        last_node = parent[mask][last_node]</span><br><span class="line">        mask = new_mask</span><br><span class="line">    </span><br><span class="line">    path.reverse()</span><br><span class="line">    <span class="keyword">if</span> path[-<span class="number">1</span>] != end:</span><br><span class="line">        path.append(end)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min_cost, path</span><br></pre></td></tr></table></figure>
<h3 id="dijkstra"><a class="markdownIt-Anchor" href="#dijkstra"></a> Dijkstra</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dijkstra</span>(<span class="params">graph, start, end</span>):</span><br><span class="line">    <span class="comment"># 儲存從源點到各點的最短距離</span></span><br><span class="line">    distances = &#123;vertex: <span class="built_in">float</span>(<span class="string">&#x27;infinity&#x27;</span>) <span class="keyword">for</span> vertex <span class="keyword">in</span> graph&#125;</span><br><span class="line">    distances[start] = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 儲存前驅節點以便重建最短路徑</span></span><br><span class="line">    previous_nodes = &#123;vertex: <span class="literal">None</span> <span class="keyword">for</span> vertex <span class="keyword">in</span> graph&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 儲存優先隊列（以最小距離為優先）</span></span><br><span class="line">    priority_queue = [(<span class="number">0</span>, start)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> priority_queue:</span><br><span class="line">        current_distance, current_vertex = heapq.heappop(priority_queue)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果已經達到目的點，則停止計算</span></span><br><span class="line">        <span class="keyword">if</span> current_vertex == end:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果已經處理過的節點，則跳過</span></span><br><span class="line">        <span class="keyword">if</span> current_distance &gt; distances[current_vertex]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 更新相鄰節點的距離</span></span><br><span class="line">        <span class="keyword">for</span> neighbor, weight <span class="keyword">in</span> graph[current_vertex].items():</span><br><span class="line">            distance = current_distance + weight</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果找到更短的路徑，則更新並加入優先隊列</span></span><br><span class="line">            <span class="keyword">if</span> distance &lt; distances[neighbor]:</span><br><span class="line">                distances[neighbor] = distance</span><br><span class="line">                previous_nodes[neighbor] = current_vertex</span><br><span class="line">                heapq.heappush(priority_queue, (distance, neighbor))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 重建最短路徑</span></span><br><span class="line">    path = []</span><br><span class="line">    current_node = end</span><br><span class="line">    <span class="keyword">while</span> current_node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        path.append(current_node)</span><br><span class="line">        current_node = previous_nodes[current_node]</span><br><span class="line">    path.reverse()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> distances[end], path</span><br></pre></td></tr></table></figure>
<h2 id="完整程式碼"><a class="markdownIt-Anchor" href="#完整程式碼"></a> 完整程式碼</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> data <span class="keyword">import</span> key_stations, key_paths, lines, tails, circles</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> dijkstra <span class="keyword">import</span> dijkstra</span><br><span class="line"><span class="keyword">from</span> held_karp <span class="keyword">import</span> held_karp</span><br><span class="line"></span><br><span class="line"><span class="comment"># build graph</span></span><br><span class="line">original_graph = defaultdict(<span class="built_in">dict</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    <span class="keyword">for</span> edge <span class="keyword">in</span> line[<span class="string">&quot;TravelTimes&quot;</span>]:</span><br><span class="line">        start = edge[<span class="string">&#x27;FromStationName&#x27;</span>][<span class="string">&#x27;Zh_tw&#x27;</span>]</span><br><span class="line">        end = edge[<span class="string">&#x27;ToStationName&#x27;</span>][<span class="string">&#x27;Zh_tw&#x27;</span>]</span><br><span class="line">        time = edge[<span class="string">&quot;RunTime&quot;</span>]</span><br><span class="line">        original_graph[start][end] = time</span><br><span class="line">        original_graph[end][start] = time</span><br><span class="line"></span><br><span class="line"><span class="comment"># cacluate cost of tails, round-trip</span></span><br><span class="line">tail_cost = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> start, end <span class="keyword">in</span> tails:</span><br><span class="line">    cost, path = dijkstra(original_graph, start, end)</span><br><span class="line">    tail_cost += cost * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cacluate cost of circles, one-way</span></span><br><span class="line">circle_cost = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> start, end <span class="keyword">in</span> circles:</span><br><span class="line">    cost, path = dijkstra(original_graph, start, end)</span><br><span class="line">    circle_cost += cost</span><br><span class="line"></span><br><span class="line"><span class="comment"># compress path</span></span><br><span class="line">n = <span class="built_in">len</span>(key_stations)</span><br><span class="line">graph = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">sub_paths = defaultdict(<span class="built_in">dict</span>)</span><br><span class="line"><span class="keyword">for</span> start_idx <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> end_idx <span class="keyword">in</span> <span class="built_in">range</span>(start_idx+<span class="number">1</span>, n):</span><br><span class="line">        cost, path = dijkstra(original_graph, key_stations[start_idx], key_stations[end_idx])</span><br><span class="line">        graph[start_idx][end_idx] = cost</span><br><span class="line">        graph[end_idx][start_idx] = cost</span><br><span class="line">        sub_paths[start_idx][end_idx] = path</span><br><span class="line">        sub_paths[end_idx][start_idx] = path[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># adjust compressed graph</span></span><br><span class="line">adjusted_graph = [row[:] <span class="keyword">for</span> row <span class="keyword">in</span> graph]</span><br><span class="line"><span class="keyword">for</span> start, end <span class="keyword">in</span> key_paths:</span><br><span class="line">    start_idx = key_stations.index(start)</span><br><span class="line">    end_idx = key_stations.index(end)</span><br><span class="line">    adjusted_graph[start_idx][end_idx] = <span class="number">0</span></span><br><span class="line">    adjusted_graph[end_idx][start_idx] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># held karp</span></span><br><span class="line">start_station = <span class="string">&quot;台北車站&quot;</span></span><br><span class="line">end_station = <span class="string">&quot;台北車站&quot;</span></span><br><span class="line">start_idx = key_stations.index(start_station)</span><br><span class="line">end_idx = key_stations.index(end_station)</span><br><span class="line">core_cost, path = held_karp(graph, adjusted_graph, start_idx, end_idx)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add key_path back, start from 1</span></span><br><span class="line"><span class="keyword">for</span> start, end <span class="keyword">in</span> key_paths[<span class="number">1</span>:]:</span><br><span class="line">    start_idx = key_stations.index(start)</span><br><span class="line">    end_idx = key_stations.index(end)</span><br><span class="line">    core_cost += graph[start_idx][end_idx]</span><br><span class="line"></span><br><span class="line"><span class="comment"># show result</span></span><br><span class="line">total_cost = tail_cost + circle_cost + core_cost</span><br><span class="line">h = total_cost // <span class="number">3600</span></span><br><span class="line">m = total_cost // <span class="number">60</span> % <span class="number">60</span></span><br><span class="line">s = total_cost % <span class="number">60</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;總耗時: <span class="subst">&#123;h&#125;</span>h <span class="subst">&#123;m&#125;</span>m <span class="subst">&#123;s&#125;</span>s&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;核心部分路線:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(path)-<span class="number">1</span>):</span><br><span class="line">    start_idx = path[i]</span><br><span class="line">    end_idx = path[i+<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;i+<span class="number">1</span>&#125;</span>. <span class="subst">&#123;<span class="string">&#x27;--&gt;&#x27;</span>.join(sub_paths[start_idx][end_idx])&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="結果"><a class="markdownIt-Anchor" href="#結果"></a> 結果</h2>
<p>終於來到本篇文章精華? 根據計算結果，從台北車站出發，遍歷 109 個車站，並在最後回到台北車站所需花費的時間是<strong>4小時52分鐘7秒</strong>，核心路線如下，記得遇到 tails 與 circle 時要繞過去就行了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 台北車站--&gt;善導寺</span><br><span class="line">2. 善導寺--&gt;忠孝新生</span><br><span class="line">3. 忠孝新生--&gt;東門</span><br><span class="line">4. 東門--&gt;大安森林公園--&gt;大安</span><br><span class="line">5. 大安--&gt;忠孝復興</span><br><span class="line">6. 忠孝復興--&gt;南京復興</span><br><span class="line">7. 南京復興--&gt;松江南京</span><br><span class="line">8. 松江南京--&gt;行天宮</span><br><span class="line">9. 行天宮--&gt;中山國小</span><br><span class="line">10. 中山國小--&gt;民權西路--&gt;雙連--&gt;中山</span><br><span class="line">11. 中山--&gt;雙連</span><br><span class="line">12. 雙連--&gt;民權西路</span><br><span class="line">13. 民權西路--&gt;大橋頭--&gt;台北橋--&gt;菜寮--&gt;三重--&gt;先嗇宮--&gt;頭前庄</span><br><span class="line">14. 頭前庄--&gt;新埔民生--&gt;板橋</span><br><span class="line">15. 板橋--&gt;新埔--&gt;江子翠--&gt;龍山寺--&gt;西門</span><br><span class="line">16. 西門--&gt;北門</span><br><span class="line">17. 北門--&gt;西門--&gt;小南門</span><br><span class="line">18. 小南門--&gt;中正紀念堂--&gt;古亭--&gt;頂溪--&gt;永安市場--&gt;景安</span><br><span class="line">19. 景安--&gt;景平--&gt;秀朗橋--&gt;十四張--&gt;大坪林</span><br><span class="line">20. 大坪林--&gt;景美--&gt;萬隆--&gt;公館--&gt;台電大樓--&gt;古亭</span><br><span class="line">21. 古亭--&gt;中正紀念堂</span><br><span class="line">22. 中正紀念堂--&gt;台大醫院</span><br><span class="line">23. 台大醫院--&gt;台北車站</span><br></pre></td></tr></table></figure>
<p>不過說真的，雖然路線可能是最好沒錯，但這個計算結果肯定是低估多了，原因如文章中所提，並沒有將班次與轉乘的因素考慮進去。再者，這只是「遍歷」所花費的時間，大家還記得活動的目的是要集章嗎? 這些集章的機台大多都在站外，也就是你各位要出站啊 😂😂😂，保守一點算，假設每站要多停留5分鐘，換算下來差不多就要再多個 9 小時，這還只是保守，實際上肯定更久啦，除非你一大早就起床集章，並且整天都很認真跑路線集章，否則這裡強烈建議:</p>
<p><em>“跟一個有買通勤月票的朋友借卡，然後多分幾天跑完，如此一來還不用花到半毛錢喔”</em> 😉</p>
]]></content>
      <categories>
        <category>DSA</category>
      </categories>
      <tags>
        <tag>Held Karp</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 自學筆記 01 - Basics</title>
    <url>/posts/Java/2024/java-learning-01/</url>
    <content><![CDATA[<h2 id="jvm-jre-jdk"><a class="markdownIt-Anchor" href="#jvm-jre-jdk"></a> JVM, JRE &amp; JDK</h2>
<p><img src="/images/2024/03/18/JVM_JRE_JDK.png" alt="JVM, JRE &amp; JDK" /></p>
<h3 id="java-vs-c"><a class="markdownIt-Anchor" href="#java-vs-c"></a> Java vs C</h3>
<p>當開發 C 或 C++ 程式時，通常會先將原始碼透過編譯器轉換成目標機器可以理解的 Object Code。這個 Object Code 是特定於目標機器架構的，因此在不同的硬體平台上可能會產生不同的機器碼。因此，當將程式移植到不同的機器或架構時，通常需要重新編譯原始碼以生成適用於該特定平台的新 Object Code。</p>
<span id="more"></span>
<h3 id="jvm-java-virtual-machine"><a class="markdownIt-Anchor" href="#jvm-java-virtual-machine"></a> JVM (Java Virtual Machine)</h3>
<p>Java 通過 JVM 來解決跨平台的問題，程式在編譯時是先翻譯成 JVM 的 Byte code，執行時才由 JVM 轉換為機器碼，由於不是直接編譯成機械碼，這表示只要新的平台有安裝 JVM，就不用重新編譯一遍了。<br />
某方面來說 JVM 算是一種 interpreter，負責執行 Byte code。<br />
<img src="/images/2024/03/18/JVM.png" alt="JVM" /></p>
<h3 id="jre-java-runtime-environment"><a class="markdownIt-Anchor" href="#jre-java-runtime-environment"></a> JRE (Java Runtime Environment)</h3>
<p>JRE 包含了執行 Java 程式所需的所有檔案和庫，包括 JVM、Class Libraries、Java API 等，也就是說單單是執行而不需要開發的話安裝 JRE 就夠了。</p>
<h3 id="jdk-java-development-kit"><a class="markdownIt-Anchor" href="#jdk-java-development-kit"></a> JDK (Java Development Kit)</h3>
<p>JDK 是一個完整的 Java 開發套件，包括了 JRE、編譯器 (javac) 以及開發所需要的各種工具和庫。</p>
<h2 id="hello-java"><a class="markdownIt-Anchor" href="#hello-java"></a> Hello Java</h2>
<ul>
<li>Hello.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> <span class="comment">//Class 的名稱要跟檔名一模一樣</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">   &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello Java&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>compile</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">javac Hello.java</span></span><br></pre></td></tr></table></figure>
<ul>
<li>run</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java Hello</span></span><br></pre></td></tr></table></figure>
<h2 id="data-type"><a class="markdownIt-Anchor" href="#data-type"></a> Data Type</h2>
<p><img src="/images/2024/03/18/java_data_type.png" alt="Java Data Type" /></p>
<h3 id="資料型態轉換"><a class="markdownIt-Anchor" href="#資料型態轉換"></a> 資料型態轉換</h3>
<ul>
<li>浮點數大於整數<br />
double &gt; float &gt; long &gt; int &gt; short &gt; byte</li>
<li>小轉大OK，大轉小error<br />
<img src="/images/2024/03/18/java_casting.png" alt="Java Casting" /></li>
<li>大轉小可以強制轉換，但可能失真</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">n2</span> <span class="operator">=</span> (<span class="type">byte</span>)n1; <span class="comment">// 不一樣 (2進位高位被截斷)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字串轉數字</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;1234&quot;</span>)</span><br><span class="line"><span class="type">long</span> <span class="variable">n2</span> <span class="operator">=</span> Long.parseLong(<span class="string">&quot;1234&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>數字轉字串</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> String.valueOf(<span class="number">1234</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> String.valueOf(<span class="number">1.234</span>);</span><br></pre></td></tr></table></figure>
<h3 id="標準輸入"><a class="markdownIt-Anchor" href="#標準輸入"></a> 標準輸入</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> s.nextInt();</span><br><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> s.next();</span><br></pre></td></tr></table></figure>
<h2 id="array"><a class="markdownIt-Anchor" href="#array"></a> Array</h2>
<p>Java 的陣列跟 C 不一樣，不是以連續的記憶體表達陣列，而是以一種 object 的形式實作，因此多維的陣列係由前一層指向後一層，所以不同層的 Array 長度可以不一樣 !!!</p>
<p><img src="/images/2024/03/18/java_array.png" alt="Java Array" /></p>
<p>Array 的宣告與初始化方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] x = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">x = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line">x.length <span class="comment">// x的長度</span></span><br></pre></td></tr></table></figure>
<h2 id="class-and-object"><a class="markdownIt-Anchor" href="#class-and-object"></a> Class and Object</h2>
<ul>
<li>Object 產生時一定要呼叫的方法，稱為 Constructor (建構子)</li>
<li>Objec 消滅需要呼叫的方法，稱為 Destructor (解構子)</li>
<li>表達 Object 內部狀態的變數，稱為 Object Variable (物件變數成員)</li>
<li>Object 可以接收的訊息，稱為 Object Method (物件方法成員)</li>
<li>上述兩個可總稱為 Object Member</li>
<li>屬於 Class 的變數，稱為Class Variable (類別變數)</li>
<li>屬於 Class 的方法，稱為 Class Method (類別方法)</li>
<li>上述兩個可總稱為 Class Member</li>
<li>和其他 Class 間的繼承關係</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> speed; <span class="comment">// Object Variable</span></span><br><span class="line">    <span class="keyword">private</span> String direction; <span class="comment">// Object Variable, direction is a reference to String Object</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">numVehicle</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// Class Variable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vehicle</span><span class="params">()</span> &#123; <span class="comment">// Constructor, called when new a Object</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="number">0</span>,<span class="string">&quot;north&quot;</span>); <span class="comment">// call another constructor to do initialization</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vehicle</span><span class="params">(<span class="type">int</span> s, String dir)</span> &#123; <span class="comment">// Another Constructor. Use overloading to define two constructors</span></span><br><span class="line">        <span class="type">float</span> speed; <span class="comment">// define a local variable</span></span><br><span class="line">        speed = s; <span class="comment">// the speed here refers to the above local variable</span></span><br><span class="line">        <span class="built_in">this</span>.speed = s; <span class="comment">// If we want to set object variable, use this.speed to refer object variable speed</span></span><br><span class="line">        direction = dir; <span class="comment">// dir is a reference to object, not the object itself</span></span><br><span class="line">        numVehicle++;   <span class="comment">// increase the Vehicle number</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123; <span class="comment">// Destructor, called when the object is garbage collected by JVM</span></span><br><span class="line">        System.out.println(<span class="string">&quot;finalize has been called&quot;</span>);</span><br><span class="line">        numVehicle--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setSpeed</span><span class="params">(<span class="type">int</span> newSpeed)</span> &#123; <span class="comment">// Object Method</span></span><br><span class="line">        <span class="built_in">this</span>.speed = newSpeed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setDir</span><span class="params">(String dir)</span> &#123; <span class="comment">// Object Method</span></span><br><span class="line">        <span class="built_in">this</span>.direction = dir;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getSpeed</span><span class="params">()</span> &#123; <span class="comment">// Object Method</span></span><br><span class="line">        <span class="keyword">return</span> speed;</span><br><span class="line">    &#125;</span><br><span class="line">    String <span class="title function_">getDir</span><span class="params">()</span> &#123; <span class="comment">// Object Method</span></span><br><span class="line">        <span class="keyword">return</span> direction;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">totalVehicle</span><span class="params">()</span> &#123; <span class="comment">// Class Method</span></span><br><span class="line">        <span class="keyword">return</span> numVehicle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="參考資料"><a class="markdownIt-Anchor" href="#參考資料"></a> 參考資料</h2>
<p><a href="https://www.geeksforgeeks.org/differences-jdk-jre-jvm/">https://www.geeksforgeeks.org/differences-jdk-jre-jvm/</a><br />
<a href="https://programming.im.ncnu.edu.tw/J_index.html">https://programming.im.ncnu.edu.tw/J_index.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Monotonic Stack</title>
    <url>/posts/DSA/2024/monotonic-stack/</url>
    <content><![CDATA[<p><strong>Monotonic Stack</strong> 本質上就是一個 Stack 而已，只不過在操作 Stack 時需要同時維護其單調的特性，本文會簡單介紹 Monotonic Stack 並附上兩個有一點點難度的 LeetCode 題目做練習：<a href="https://leetcode.com/problems/largest-rectangle-in-histogram">84. Largest Rectangle in Histogram</a>、<a href="https://leetcode.com/problems/maximal-rectangle">85. Maximal Rectangle</a>。</p>
<span id="more"></span>
<h2 id="usage"><a class="markdownIt-Anchor" href="#usage"></a> Usage</h2>
<p>白話來說，如果我們要維護一個<strong>單調遞增</strong>的 stack (如上圖)，那麼在 <strong>push</strong> 新元素時要先和 stack 的 top 進行比較，如果新的元素比較大就直接放進去，如果新的元素比較小的話，就要先將 stack 中大於新元素的元素依次 <strong>pop</strong> 出來，之後才放入新元素，如此一來便能維護 Stack 的單調性。</p>
<p><img src="/images/2024/04/13/monotonic-stack.png" alt="monotonic stack" /></p>
<p>依此類推，單調遞減也是差不多作法。</p>
<h2 id="leetcode-example"><a class="markdownIt-Anchor" href="#leetcode-example"></a> LeetCode Example</h2>
<h3 id="84-largest-rectangle-in-histogram"><a class="markdownIt-Anchor" href="#84-largest-rectangle-in-histogram"></a> <a href="https://leetcode.com/problems/largest-rectangle-in-histogram">84. Largest Rectangle in Histogram</a></h3>
<p><img src="/images/2024/04/13/Largest-Rectangle-in-Histogram.png" alt="Largest Rectangle in Histogram" /></p>
<p>在這個題目中，我們要找出直方圖所能組成的最大長方形面積，我們其實可以把它看作 <a href="https://www.geeksforgeeks.org/next-smaller-element/">Next Smaller Element</a> 問題的變形，找到對於每個 hist 來說，下一個比它低的 hist 在哪，如此便能的到它長方形的寬，進一步計算出長方形的面積。<br />
具體來說，我們在遍歷直方圖的同時維護一個 Monotonic Stack，每次 pop 時都去計算被 pop 掉的柱體最多可以組成多少面積，以上圖來說：</p>
<ul>
<li><strong>push 2</strong><br />
直接放入 2，stack = <strong>[2]</strong></li>
<li><strong>push 1</strong><br />
1 &lt; 2，pop 2，長方形面積為 2 * 1 = 2。<br />
放入 1，stack = <strong>[1]</strong></li>
<li><strong>push 5</strong><br />
直接放入 5，stack = <strong>[1, 5]</strong></li>
<li><strong>push 6</strong><br />
直接放入 6，stack = <strong>[1, 5, 6]</strong></li>
<li><strong>push 2</strong><br />
2 &lt; 6，pop 6，長方形面積為 6 * 1 = 6。<br />
2 &lt; 5，pop 5，長方形面積為 5 * 2 = 10。<br />
放入 2，stack = <strong>[1, 2]</strong></li>
<li><strong>…</strong></li>
</ul>
<p>下面的程式中，我們使用嚴格單調遞增，所以高度一樣的話我們一樣不放進 stack 中，另外我們的 stack 同時存儲 hist 的高度以及 index，這樣在算面積時比較快。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">largestRectangleArea</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    </span><br><span class="line">    heights.append(<span class="number">0</span>)</span><br><span class="line">    stack = [(-<span class="number">1</span>, -<span class="number">1</span>)]</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, h <span class="keyword">in</span> <span class="built_in">enumerate</span>(heights):</span><br><span class="line">        t_i = i</span><br><span class="line">        <span class="keyword">while</span> h &lt; stack[-<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">            t_i, t_h = stack.pop()</span><br><span class="line">            res = <span class="built_in">max</span>(res, t_h*(i-t_i))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> h &gt; stack[-<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">            stack.append((t_i, h))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="85-maximal-rectangle"><a class="markdownIt-Anchor" href="#85-maximal-rectangle"></a> <a href="https://leetcode.com/problems/maximal-rectangle">85. Maximal Rectangle</a></h3>
<p><img src="/images/2024/04/13/Maximal-Rectangle.png" alt="Maximal Rectangle" /></p>
<p>上一題的延伸題，先將 matrix 中的每個 row 轉換為對應的直方圖，接著用同樣的方式去求出直方圖的最大長方形面積就行了，以上圖來說：</p>
<ul>
<li>matrix[0] = <strong>[1, 0, 1, 0, 0]</strong></li>
<li>matrix[1] = <strong>[2, 0, 2, 1, 1]</strong></li>
<li>matrix[2] = <strong>[3, 1, 3, 2, 2]</strong></li>
<li>matrix[3] = <strong>[4, 0, 0, 3, 0]</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maximalRectangle</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Apply monotonic stack to calculate maximal rectangle</span></span><br><span class="line"><span class="string">    1. reserve one more space for the zero</span></span><br><span class="line"><span class="string">    2. put a negative hist in the bottom to stay in a valid state (in while loop)</span></span><br><span class="line"><span class="string">    3. append a zero to calculate remaining hist in stack</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">len</span>(matrix)</span><br><span class="line">    m = <span class="built_in">len</span>(matrix[<span class="number">0</span>])+<span class="number">1</span>    <span class="comment"># 1</span></span><br><span class="line">    heights = [<span class="number">0</span>]*m</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        stack = [(-<span class="number">1</span>, -<span class="number">1</span>)]  <span class="comment"># 2</span></span><br><span class="line">        matrix[i].append(<span class="number">0</span>) <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            heights[j] = heights[j]+<span class="number">1</span> <span class="keyword">if</span> matrix[i][j] == <span class="string">&#x27;1&#x27;</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            t_j = j</span><br><span class="line">            <span class="keyword">while</span> heights[j] &lt; stack[-<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                t_j, t_h = stack.pop()</span><br><span class="line">                res = <span class="built_in">max</span>(res, t_h*(j-t_j))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> heights[j] &gt; stack[-<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                stack.append((t_j, heights[j]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DSA</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Monotonic Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 自學筆記 02 - OOP</title>
    <url>/posts/Java/2024/java-learning-02/</url>
    <content><![CDATA[<p><img src="/images/2024/03/18/java_oop.png" alt="Java OOP" /></p>
<p>Java 是一個物件導向的程式語言，重點在於如何定義物件之間的互動，Object Oriented Programming (OOP) 的三大特性分別是: <strong>Encapsulation (封裝)</strong>、<strong>Inheritance (繼承)</strong> 與 <strong>Polymorphism (多型)</strong> 。</p>
<span id="more"></span>
<h2 id="encapsulation-封裝"><a class="markdownIt-Anchor" href="#encapsulation-封裝"></a> Encapsulation (封裝)</h2>
<p>所謂封裝(Encapsulation)，是指class A的設計者可以指定其他的class能否存取A的某個member。</p>
<h3 id="access-modifier"><a class="markdownIt-Anchor" href="#access-modifier"></a> Access Modifier</h3>
<p>類別中每個 member 的權限都是分開控制的，存取範圍的大小是public &gt; protected &gt; package &gt; private。</p>
<ul>
<li><strong>private</strong>: 只有A自己才可以存取，使用keyword <strong>private</strong></li>
<li><strong>package (default)</strong>: 只有和A同一個package的class才可以存取，沒有相對應的keyword</li>
<li><strong>protected</strong>: 只有同一個package或是A的子類別才可以存取，使用keyword <strong>protected</strong></li>
<li><strong>public</strong>: 所有的class都可以存取，使用keyword <strong>public</strong></li>
</ul>
<h3 id="package"><a class="markdownIt-Anchor" href="#package"></a> Package</h3>
<p>對應到資料夾名稱，不同層的資料夾視為不同封包:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> math;</span><br><span class="line"><span class="keyword">package</span> math.geometry;</span><br></pre></td></tr></table></figure>
<p>要使用封包內的類別:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math.BasicMath;</span><br><span class="line"><span class="keyword">import</span> math.geometry.*;</span><br></pre></td></tr></table></figure>
<h2 id="inheritance-繼承"><a class="markdownIt-Anchor" href="#inheritance-繼承"></a> Inheritance (繼承)</h2>
<p>Java使用關鍵字extends來表達繼承，若class宣告時沒有指定extends，則Java會自動extends <strong>java.lang.Object</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">moveMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Unspecified&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">moveMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Fly&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="override-覆寫"><a class="markdownIt-Anchor" href="#override-覆寫"></a> Override (覆寫)</h3>
<p>子類別重新定義它所能看到的父類別中的 method (如 public、protected，如果子類別和父類別在同一個 package 裡，則沒有修飾字的method也可以)，稱為override。</p>
<ul>
<li>如果子類別看不到父類別的方法 (如父類別的 private 方法，或子父類別不在同一個 package 而子類別定義了父類別內的 package method)，則就算定義了同樣的 method 也不是override</li>
<li>重複定義 static method 也不算 override</li>
<li>子類別不可縮小父類別方法的存取範圍</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C1</span> <span class="keyword">extends</span> <span class="title class_">C2</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123; <span class="comment">// Compile Error，不得縮小存取範圍</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="final-修飾字"><a class="markdownIt-Anchor" href="#final-修飾字"></a> final 修飾字</h3>
<p>final 除可用來修飾變數外，也可放在class和object method前面:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FinalClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">finalMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>final放在class前面表示class不可被繼承，放在object method表示不可被Override。</p>
<h2 id="polymorphism-多形"><a class="markdownIt-Anchor" href="#polymorphism-多形"></a> Polymorphism (多形)</h2>
<h3 id="upcasting-向上轉型"><a class="markdownIt-Anchor" href="#upcasting-向上轉型"></a> UpCasting (向上轉型)</h3>
<p>子類別可以向上相容於父類別，舉例來說，Bird 是一種 Animal，所以可以順利向上轉型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal a;</span><br><span class="line">Bird b;</span><br><span class="line">a = b; <span class="comment">// upcasting, Bird is a kind of Animal</span></span><br></pre></td></tr></table></figure>
<h3 id="downcasting-向下轉型"><a class="markdownIt-Anchor" href="#downcasting-向下轉型"></a> DownCasting (向下轉型)</h3>
<p>相反的，父類別並不能像下相容子類別，因為 Animal 並不一定都是 Bird，如果要向下轉型必須要強制casting。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>(); <span class="comment">// upcasting</span></span><br><span class="line">Bird b;</span><br><span class="line">b = (Bird)a; <span class="comment">// downcasting, compile correct</span></span><br><span class="line"><span class="keyword">if</span> (a <span class="keyword">instanceof</span> Bird) &#123; <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>InheritanceExample.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritanceExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> &#123;</span><br><span class="line">        Animal a1, a2, a3, a4;</span><br><span class="line">        Bird b;</span><br><span class="line">        Dog d;</span><br><span class="line">        Fish f;</span><br><span class="line">        a2 = a1 = <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        b = <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">        d = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        f = <span class="keyword">new</span> <span class="title class_">Fish</span>();</span><br><span class="line">        System.out.println(a1.moveMethod());</span><br><span class="line">        System.out.println(b.moveMethod());</span><br><span class="line">        System.out.println(d.moveMethod());</span><br><span class="line">        System.out.println(f.moveMethod());</span><br><span class="line">        a1 = b; <span class="comment">// Correct, we call this upcasting</span></span><br><span class="line">        b = a1; <span class="comment">// Compile Error, type not compatible</span></span><br><span class="line">        b = (Bird)a1; <span class="comment">// downcasting, Compile Correct</span></span><br><span class="line">        a2 = b; <span class="comment">// Correct,we call this upcasting</span></span><br><span class="line">        d = a2; <span class="comment">// Compile Error, type not compatible</span></span><br><span class="line">        d = (Dog)a2; <span class="comment">// Compile Correct, but runtime error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="instanceof-關鍵字"><a class="markdownIt-Anchor" href="#instanceof-關鍵字"></a> instanceof 關鍵字</h2>
<p>用來判斷某 reference 所指到的物件與類別是否相容 (including upcasting):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object ref;</span><br><span class="line">ref = <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line"><span class="keyword">if</span> (ref <span class="keyword">instanceof</span> Animal) &#123; <span class="comment">// correct</span></span><br><span class="line">    System.out.println(<span class="string">&quot;ref is currently pointing to an Animal Object.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="virtual-function虛擬函數"><a class="markdownIt-Anchor" href="#virtual-function虛擬函數"></a> Virtual Function(虛擬函數)</h3>
<p>當父類別 reference 到子類別的 object，ex: <code>Animal a = new Bird()</code>，如果子類別 override 父類別的 method，java 會呼叫子類別的方法，也就是 Virtual Function，(如果是呼叫父類別的方法就是 Non-Virtual Function)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritanceExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> &#123;</span><br><span class="line">        Animal a1;</span><br><span class="line">        a1 = <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        System.out.println(a1.moveMethod()); <span class="comment">// print out &quot;Unspecified&quot;</span></span><br><span class="line">        a1 = <span class="keyword">new</span> <span class="title class_">Bird</span>(); <span class="comment">// polymorphism</span></span><br><span class="line">        System.out.println(a1.moveMethod()); <span class="comment">// print out &quot;Fly&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意 override 的範圍，只有被 override 的 method 才會呼叫 virtual function，舉例來說，static method 、private method 不能被 override，所以也不會有 virtual function。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">moveMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Unspecified&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> &#123;</span><br><span class="line">        Animal a1;</span><br><span class="line">        a1 = <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">        System.out.println(a1.moveMethod()); <span class="comment">// print out &quot;Unspecified&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// this is not override because Bird can&#x27;t see Animal&#x27;s moveMethod</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">moveMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Fly&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="參考資料"><a class="markdownIt-Anchor" href="#參考資料"></a> 參考資料</h2>
<p><a href="https://programming.im.ncnu.edu.tw/J_index.html">https://programming.im.ncnu.edu.tw/J_index.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 自學筆記 03 - Interface &amp; Abstract</title>
    <url>/posts/Java/2024/java-learning-03/</url>
    <content><![CDATA[<p><img src="/images/2024/03/19/java_interface_abstract.png" alt="Interface &amp; Abstract" /></p>
<p>OOP 除了有 Encapsulation、Inheritance 與 Polymorphism 三大要素外，<strong>Interface</strong> 與 <strong>Abstract</strong> 也是 OOP 中的重要概念。</p>
<span id="more"></span>
<h2 id="interface-介面"><a class="markdownIt-Anchor" href="#interface-介面"></a> Interface (介面)</h2>
<p>因為 java 的 class 不能多重繼承，所以發展出 Interface:</p>
<h3 id="宣告-interface"><a class="markdownIt-Anchor" href="#宣告-interface"></a> 宣告 interface</h3>
<p>interface 裡的變數都是 <strong>piblic</strong>、<strong>static</strong> 以及 <strong>final</strong> 的<br />
interface 裡的方法則是 <strong>public</strong> 以及 <strong>abstract</strong> 的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Listener</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14149</span>; <span class="comment">// 同public static final</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span>; <span class="comment">// 同public abstract</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnalbe</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PERIOD</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>; <span class="comment">// 注意這裡只有 ()，沒有 &#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AnotherRun</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PERIOD</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">run</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="interface-的繼承"><a class="markdownIt-Anchor" href="#interface-的繼承"></a> Interface 的繼承</h3>
<p>Interface 可以多重繼承</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ActionListener</span> <span class="keyword">extends</span> <span class="title class_">Listener</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MultiInterface</span> <span class="keyword">extends</span> <span class="title class_">Listener</span>, Runnalbe &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="class-實作-interface"><a class="markdownIt-Anchor" href="#class-實作-interface"></a> Class 實作 Interface</h3>
<p><strong>相同變數名稱</strong>: 用 interfaceA.var 以及 interfaceB.var 區分<br />
<strong>相同函數名稱</strong>: 實作一次就好</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">Listener</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">Listener</span>, Runnable &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">implements</span> <span class="title class_">MultiInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>, AnotherRun &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">run</span><span class="params">(<span class="type">int</span> period)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="abstarct-抽象"><a class="markdownIt-Anchor" href="#abstarct-抽象"></a> Abstarct (抽象)</h2>
<p>只有參數宣告，沒有實作的方法，稱為abstract method。</p>
<ul>
<li><strong>具有 abstract method 的 class 必須宣告為 abstract class。</strong></li>
<li>繼承 abstract class 的子類別必須 <strong>override 所有父類別的 abstract method</strong>，否則子類別也必須宣告為 abstract class。</li>
<li>實作 Interface A 的 Class 必須<strong>實作 A 裡的所有method</strong>，否則必須宣告自己為 abstract class。</li>
<li><strong>不能直接 new abstract class</strong>，只能 new 其非 abstract class 的子類別。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractExample</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">abstract</span> <span class="title function_">abstractMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractExample</span><span class="params">()</span> &#123;</span><br><span class="line">        x = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span> &#123; <span class="comment">// must override this method, or SubClass be declared as abstract class</span></span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> &#123;</span><br><span class="line">        <span class="type">AbstractExample</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubClass</span>(); <span class="comment">// correct</span></span><br><span class="line">        a.abstractMethod(); <span class="comment">// virtual function, call SubClass&#x27;s abstractMethod</span></span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">AbstractExample</span>(); <span class="comment">// Compile error, you can&#x27;t new abstract class</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="參考資料"><a class="markdownIt-Anchor" href="#參考資料"></a> 參考資料</h2>
<p><a href="https://programming.im.ncnu.edu.tw/J_index.html">https://programming.im.ncnu.edu.tw/J_index.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 自學筆記 04 - List &amp; Queue</title>
    <url>/posts/Java/2024/java-learning-04/</url>
    <content><![CDATA[<h2 id="collection"><a class="markdownIt-Anchor" href="#collection"></a> Collection</h2>
<p>Collection 是 Java 中用來存儲、操作數據結構的一種框架，在此之下提供了許多實用的 Interface，包括 <strong>List</strong>、<strong>Queue</strong> 以及 <strong>Set</strong> (Map 是分開的)。</p>
<p><img src="/images/2024/03/19/java_collection.png" alt="Java Collection" /></p>
<span id="more"></span>
<h2 id="list"><a class="markdownIt-Anchor" href="#list"></a> List</h2>
<p>List 基本上就是動態數組，其下有 <strong>ArrayList</strong>、<strong>LinkedList</strong>、<strong>Vector</strong> 等不同的實現。</p>
<p><img src="/images/2024/03/19/java_list_interface.png" alt="Java List Interface" /></p>
<ul>
<li><strong>ArrayList</strong>: 透過索引訪問的動態陣列，查尋的時間複雜度為 <strong>O(1)</strong>，然而插入時會將後面的元素全部往右移 (刪除時則是全部往左移)，因此時間複雜度最差為 <strong>O(n)</strong>。<strong>適合用在隨機查找、頻繁訪問及更新的資料上。</strong></li>
<li><strong>LinkedList</strong>: 透過雙向鏈結實現的動態陣列，插入與刪除的效率高，操作本身的時間複雜度為 <strong>O(1)</strong>，但查找時需要遍歷整個鏈表，因此時間複雜度最差為 <strong>O(n)</strong>。<strong>適用於需要大量插入和刪除操作的情況。</strong></li>
</ul>
<blockquote>
<p>Vector 是老舊的語法，透過 <code>synchronized</code> 同步以實現線程安全，性能不佳，大多時候都可以被 ArrayList 取代掉，兩者的用法幾乎一模一樣。</p>
</blockquote>
<h3 id="array-to-arraylist"><a class="markdownIt-Anchor" href="#array-to-arraylist"></a> Array to ArrayList</h3>
<p><code>Arrays.asList()</code> 可以將 Array 轉換為 <code>java.util.Arrays.ArrayList</code>，與 collections 中所指的 ArrayList 並不一樣，轉換而成的 ArrayList 並不能進行添加或刪除的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;Sandy&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line"><span class="comment">// names.add(&quot;Frank&quot;); // 還是可以 compile，但執行會報錯</span></span><br></pre></td></tr></table></figure>
<h3 id="basic-usage"><a class="markdownIt-Anchor" href="#basic-usage"></a> Basic Usage</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// Interface&lt;Object&gt;</span></span><br><span class="line"><span class="comment">// List&lt;String&gt; list = new LinkedList&lt;&gt;(); </span></span><br><span class="line">list.add(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Emma&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">list.addAll(names);</span><br><span class="line">System.out.println(list); <span class="comment">// [Jack, Emma, Jack, Sandy, Jack]</span></span><br><span class="line"></span><br><span class="line">list.get(<span class="number">0</span>); <span class="comment">// Jack</span></span><br><span class="line">list.indexOf(<span class="string">&quot;Jack&quot;</span>); <span class="comment">// 0</span></span><br><span class="line">list.size(); <span class="comment">// 5</span></span><br><span class="line">list.isEmpty(); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">list.set(<span class="number">0</span>, <span class="string">&quot;Timmy&quot;</span>);</span><br><span class="line">System.out.println(list);  <span class="comment">// [Timmy, Emma, Jack, Sandy, Jack]</span></span><br><span class="line"></span><br><span class="line">list.remove(<span class="number">0</span>); <span class="comment">// remove(index): return element or throw exception</span></span><br><span class="line">list.remove(<span class="string">&quot;Jack&quot;</span>); <span class="comment">// remove(Object): return True or False</span></span><br><span class="line">System.out.println(list);  <span class="comment">// [Emma, Sandy, Jack]</span></span><br><span class="line"></span><br><span class="line">list.removeIf(x-&gt;x.contains(<span class="string">&quot;J&quot;</span>));</span><br><span class="line">System.out.println(list);  <span class="comment">// [Emma, Sandy]</span></span><br><span class="line"></span><br><span class="line">list.clear();</span><br></pre></td></tr></table></figure>
<h2 id="queue"><a class="markdownIt-Anchor" href="#queue"></a> Queue</h2>
<p>Queue 是一個<strong>先進先出 (FIFO)</strong> 的資料集合，其下大致上可以分為 Deque 及 Priority Queue 兩類，Deque 有 <strong>ArrayDeque</strong>、<strong>LinkedList</strong> 等實現，Priority Queue 的實現則是 <strong>PriorityQueue</strong>。<br />
<img src="/images/2024/03/19/java_queue_interface.png" alt="Java Queue Interface" /></p>
<ul>
<li><strong>LinkedList</strong>: 前面就提到過了，雙向鏈結的特性使其能夠快速地對頭尾元素進行操作。</li>
<li><strong>ArrayDeque</strong>: 同時有 Deque 以及 Array 的性質，能快速地訪問元素，也可以快速地對頭尾元素進行操作。</li>
<li><strong>PriorityQueue</strong>: 其實就是 Min Heap。</li>
</ul>
<h3 id="deque"><a class="markdownIt-Anchor" href="#deque"></a> Deque</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// Deque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add from first</span></span><br><span class="line">deque.addFirst(<span class="number">1</span>);</span><br><span class="line">deque.addFirst(<span class="number">2</span>);</span><br><span class="line">deque.addFirst(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add from last</span></span><br><span class="line">deque.addLast(<span class="number">4</span>);</span><br><span class="line">deque.addLast(<span class="number">5</span>);</span><br><span class="line">deque.addLast(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(deque);  <span class="comment">// [3, 2, 1, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get from first</span></span><br><span class="line">deque.getFirst();           <span class="comment">// return 3</span></span><br><span class="line">System.out.println(deque);  <span class="comment">// [3, 2, 1, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get from last</span></span><br><span class="line">deque.getLast();            <span class="comment">// return 6</span></span><br><span class="line">System.out.println(deque);  <span class="comment">// [3, 2, 1, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// remove from first</span></span><br><span class="line">deque.removeFirst();        <span class="comment">// return 3</span></span><br><span class="line">System.out.println(deque);  <span class="comment">// [2, 1, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// remove from last</span></span><br><span class="line">deque.removeLast();         <span class="comment">// return 6</span></span><br><span class="line">System.out.println(deque);  <span class="comment">// [2, 1, 4, 5]</span></span><br></pre></td></tr></table></figure>
<h3 id="priority-queue"><a class="markdownIt-Anchor" href="#priority-queue"></a> Priority Queue</h3>
<p>將 pq 印出來會發現最小值永遠在第一個，後面順序則不一定，有興趣可以自己去看 heap 的規則。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">7</span>; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">    pq.offer(i);        <span class="comment">// similar to pq.add()</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(pq); <span class="comment">// [1, 4, 2, 7, 5, 6, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get first one</span></span><br><span class="line">pq.peek();</span><br><span class="line">System.out.println(pq); <span class="comment">// [1, 4, 2, 7, 5, 6, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// remove first one</span></span><br><span class="line">pq.poll();</span><br><span class="line">System.out.println(pq); <span class="comment">// [2, 4, 3, 7, 5, 6]</span></span><br></pre></td></tr></table></figure>
<p>But！都用到 PriorityQueue 了，肯定不只是拿來處理這麼簡單的任務，通常會儲存一組資料，例如 <code>&quot;apple&quot;, 2</code>、<code>&quot;banana&quot;, 3</code> 等，這時候 PriorityQueue 就不知道該如何進行排序了，這時我們可能就需要自訂義類別與比較器:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Self-defined Class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&#123;</span><br><span class="line">    String first;</span><br><span class="line">    <span class="type">int</span> second;</span><br><span class="line"></span><br><span class="line">    Pair(String first, <span class="type">int</span> second)&#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Self-defined Comparator</span></span><br><span class="line">Comparator&lt;Pair&gt; customComparator = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Pair p1, Pair p2)</span> &#123;</span><br><span class="line">        <span class="comment">// compare with second element</span></span><br><span class="line">        <span class="keyword">return</span> Integer.compare(p1.second, p2.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize PriorityQueue with Comparator</span></span><br><span class="line">PriorityQueue&lt;Pair&gt; pq2 = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(customComparator);</span><br><span class="line"></span><br><span class="line"><span class="comment">// offer</span></span><br><span class="line">pq2.offer(<span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="string">&quot;apple&quot;</span>, <span class="number">2</span>));</span><br><span class="line">pq2.offer(<span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="string">&quot;banana&quot;</span>, <span class="number">3</span>));</span><br><span class="line">pq2.offer(<span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="string">&quot;cherry&quot;</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// poll</span></span><br><span class="line"><span class="keyword">while</span> (!pq2.isEmpty()) &#123;</span><br><span class="line">    <span class="type">Pair</span> <span class="variable">pair</span> <span class="operator">=</span> pq2.poll();</span><br><span class="line">    System.out.println(<span class="string">&quot;(&quot;</span> + pair.first + <span class="string">&quot;, &quot;</span> + pair.second + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result</span></span><br><span class="line"><span class="comment">// (cherry, 1)</span></span><br><span class="line"><span class="comment">// (apple, 2)</span></span><br><span class="line"><span class="comment">// (banana, 3)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 自學筆記 05 - Set &amp; Map</title>
    <url>/posts/Java/2024/java-learning-05/</url>
    <content><![CDATA[<h2 id="set"><a class="markdownIt-Anchor" href="#set"></a> Set</h2>
<p>Set 的關係圖如下:<br />
<img src="/images/2024/03/19/java_set_interface.png" alt="Java Set Interface" /></p>
<p>比較常用的:</p>
<ul>
<li><strong>HashSet</strong>: 不保證保存順序，速度最快</li>
<li><strong>LinkedHashSet</strong>: 保存順序與存入順序相同</li>
<li><strong>TreeSet</strong>: 依元素的大小排序，存入的元素必須是可比較的</li>
</ul>
<span id="more"></span>
<h3 id="basic-usage"><a class="markdownIt-Anchor" href="#basic-usage"></a> Basic Usage</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(); </span><br><span class="line"><span class="comment">// Set&lt;String&gt; set = new LinkedHashSet&lt;&gt;(); </span></span><br><span class="line"><span class="comment">// Set&lt;String&gt; set = new TreeSet&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">set.add(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;Emma&quot;</span>);   </span><br><span class="line">set.add(<span class="string">&quot;Kevin&quot;</span>);   </span><br><span class="line">set.add(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line"></span><br><span class="line">set.contains(<span class="string">&quot;Tom&quot;</span>) <span class="comment">// False</span></span><br><span class="line">set.remove(<span class="string">&quot;Tom&quot;</span>); <span class="comment">// False</span></span><br><span class="line"></span><br><span class="line">set.size(); <span class="comment">// 3 ([Kevin, Jack, Emma])</span></span><br><span class="line">set.isEmpty(); <span class="comment">// False</span></span><br><span class="line"><span class="comment">// set.clear();</span></span><br></pre></td></tr></table></figure>
<h3 id="iterations"><a class="markdownIt-Anchor" href="#iterations"></a> Iterations</h3>
<p>Iterator 是老用法了不太推薦，用 for 跟 forEach 好多了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; newSet = set.iterator();     </span><br><span class="line"><span class="keyword">while</span> (newSet.hasNext()) &#123;   </span><br><span class="line">    System.out.println(newSet.next());   </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">for</span> (String name: set)&#123;</span><br><span class="line">    System.out.println(name); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">set.forEach((name)-&gt;&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="set-operations"><a class="markdownIt-Anchor" href="#set-operations"></a> Set Operations</h3>
<p>set 很適合用來做交集聯集等操作。</p>
<p><img src="/images/2024/03/19/set_operation.png" alt="Set Operation" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] source = &#123;<span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Tom&quot;</span>&#125;;</span><br><span class="line">Set&lt;String&gt; set2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(source)); </span><br><span class="line"></span><br><span class="line"><span class="comment">// union</span></span><br><span class="line">set.addAll(set2); <span class="comment">// [Kevin, Tom, Jack, Emma]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// intersection</span></span><br><span class="line">set.retainAll(set2); <span class="comment">// [Jack]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// difference (自己那邊)</span></span><br><span class="line">set.removeAll(set2); <span class="comment">// [Kevin, Emma]</span></span><br></pre></td></tr></table></figure>
<h2 id="map"><a class="markdownIt-Anchor" href="#map"></a> Map</h2>
<p>Map 的關係圖下:<br />
<img src="/images/2024/03/19/java_map_interface.png" alt="Java Map Interface" /></p>
<blockquote>
<p>上圖最左邊的 Hashtable 跟 Vector 一樣是老舊的語法，透過 <code>synchronized</code> 同步以實現線程安全，性能不佳，大多時候都可以被取代掉，真的要確保線程安全可以改用 <code>ConcurrentHashMap</code>。</p>
</blockquote>
<p>同樣有三種常用的 Map，各自的特色跟對應到的 Set 一模一樣，只是改成存鍵值對:</p>
<ul>
<li><strong>HashMap</strong>: 不保證保存順序，速度最快</li>
<li><strong>LinkedHashMap</strong>: 保存順序與存入順序相同</li>
<li><strong>TreeMap</strong>: 依元素的大小排序，存入的元素必須是可比較的</li>
</ul>
<h3 id="basic-usage-2"><a class="markdownIt-Anchor" href="#basic-usage-2"></a> Basic Usage</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// Map&lt;String, Integer&gt; set = new LinkedHashMap&lt;&gt;(); </span></span><br><span class="line"><span class="comment">// Map&lt;String, Integer&gt; set = new TreeMap&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">3</span>);</span><br><span class="line">map.put(<span class="string">&quot;banana&quot;</span>, <span class="number">2</span>);</span><br><span class="line">map.put(<span class="string">&quot;orange&quot;</span>, <span class="number">4</span>);  <span class="comment">// return null</span></span><br><span class="line">map.put(<span class="string">&quot;orange&quot;</span>, <span class="number">5</span>); <span class="comment">// return 4 (previous value)</span></span><br><span class="line">System.out.println(map); <span class="comment">// &#123;banana=2, orange=5, apple=3&#125;</span></span><br><span class="line"></span><br><span class="line">map.get(<span class="string">&quot;apple&quot;</span>); <span class="comment">// return 3</span></span><br><span class="line">map.get(<span class="string">&quot;peach&quot;</span>); <span class="comment">// return null</span></span><br><span class="line">map.getOrDefault(<span class="string">&quot;peach&quot;</span>, <span class="number">0</span>); <span class="comment">// return default 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map.remove(&quot;apple&quot;); // return 3</span></span><br><span class="line">map.remove(<span class="string">&quot;peach&quot;</span>); <span class="comment">// return null</span></span><br><span class="line"></span><br><span class="line">map.isEmpty(); <span class="comment">// return false</span></span><br><span class="line">map.size(); <span class="comment">// return 3</span></span><br><span class="line"><span class="comment">// map.clear(); </span></span><br></pre></td></tr></table></figure>
<h3 id="keys-and-values"><a class="markdownIt-Anchor" href="#keys-and-values"></a> Keys and Values</h3>
<p>取用方式基本上類似於 python 的 <code>keys()</code> 和 <code>values()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get keys</span></span><br><span class="line">Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">System.out.println(keys); <span class="comment">// [banana, orange, apple]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get values</span></span><br><span class="line">Collection&lt;Integer&gt; values = map.values();</span><br><span class="line">System.out.println(values); <span class="comment">// [2, 5, 3]</span></span><br></pre></td></tr></table></figure>
<h3 id="iterations-2"><a class="markdownIt-Anchor" href="#iterations-2"></a> Iterations</h3>
<p>遍歷 Map 有很多方法，這裡示範三種：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. keySet()，</span></span><br><span class="line"><span class="keyword">for</span> (String key: map.keySet())&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;key=&quot;</span> + key + <span class="string">&quot;, value=&quot;</span> + map.get(key));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. entrySet()，類愈 python 的 items()</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry: map.entrySet())&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;key=&quot;</span> + entry.getKey() + <span class="string">&quot;, value=&quot;</span> + entry.getValue());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. forEach()，建議使用</span></span><br><span class="line">map.forEach((key, value) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;key=&quot;</span> + key + <span class="string">&quot;, value=&quot;</span> + value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="map-operations"><a class="markdownIt-Anchor" href="#map-operations"></a> Map Operations</h3>
<p>跟 Set 一樣 Map 也可以做 operations，很酷的是我們對 <code>keySet()</code> 進行操作時，其實也會影響到 Map 本身。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()&#123;&#123;</span><br><span class="line">    put(<span class="string">&quot;orange&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    put(<span class="string">&quot;lemon&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    put(<span class="string">&quot;starwberry&quot;</span>, <span class="number">2</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// union</span></span><br><span class="line">map.putAll(map2); </span><br><span class="line">System.out.println(map); <span class="comment">// &#123;banana=2, orange=1, apple=3, lemon=1, starwberry=2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// intersection</span></span><br><span class="line">map.keySet().retainAll(map2.keySet());</span><br><span class="line">System.out.println(map); <span class="comment">// &#123;orange=5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// difference (left half)</span></span><br><span class="line">map.keySet().removeAll(map2.keySet());</span><br><span class="line">System.out.println(map); <span class="comment">// &#123;banana=2, apple=3&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="參考資料"><a class="markdownIt-Anchor" href="#參考資料"></a> 參考資料</h2>
<p><a href="https://www.javatpoint.com/set-in-java">Set in Java - Javapoint</a><br />
<a href="https://www.javatpoint.com/java-map">Java Map - Javapoint</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 自學筆記 07 - Concurrent Queue (w/ Producer Consumer Problem)</title>
    <url>/posts/Java/2024/java-learning-07/</url>
    <content><![CDATA[<p>在 Java 的多線程操作中，Concurrent Queue 是一種非常重要的容器，在共享資源的同時也能夠幫我們進行流程控制。<br />
Java 的 Concurrent Queue 可以分為兩類，分別是 <strong>Blocking Queue</strong> 以及 <strong>Non Blocking Queue</strong>，兩種都是線程安全的，文章的最後會用 Blocking Queue 來實作 <strong>Producer Consumer Problem</strong> !</p>
<p><img src="/images/2024/03/20/consumer_producer.png" alt="Consumer Producer" /></p>
<span id="more"></span>
<h2 id="non-blocking-queue"><a class="markdownIt-Anchor" href="#non-blocking-queue"></a> Non Blocking Queue</h2>
<p>Non Blocking Queue 其實就是一般的 Queue，對 Queue 進行操作要馬成功要馬失敗，無論如何會立刻知道結果。<br />
<strong>ConcurrentLinkedQueue</strong> 使用 <strong>CAS (Compare-And-Swap)</strong> 的機制來實現同步功能，對於響應式的應用來說，等待時間通常是不被允許的，這時候 Non Blocking Queue 會是好選擇。</p>
<blockquote>
<p><strong>什麼是 CAS (Compare-And-Swap) ?</strong><br />
CAS 是原子操作的一種 (atomic)，它的基本思想是比較目標內存位置的值與預期值，只有在相等的情況下才將該位置的值更新為新值。<br />
以 queue 的插入來說，首先要記錄 queue 尾部位置，每次操作時去檢查現在的位置跟所記錄的是否一樣，如果改變了就重來一遍，沒變的話就插入並記錄下新的尾部位置。</p>
</blockquote>
<h2 id="blocking-queue"><a class="markdownIt-Anchor" href="#blocking-queue"></a> Blocking Queue</h2>
<p>Blocking Queue 相比於 Non Blocking Queue 多了<strong>阻塞等待</strong>的動作，大部分的 Concurrent Queue 都是屬於 Blocking Queue，如 <strong>ArrayBlockingQueue</strong>、<strong>LinkedBlockingQueue</strong> 等，其阻塞是基於 <strong>Lock</strong> 來實現的，具體來說 Blocking Queue 多了四種操作:</p>
<p><img src="/images/2024/03/20/blocking_queue.png" alt="Blocking Queue" /></p>
<ul>
<li><strong>put(e)</strong>: 從尾部放入元素，如果佇列已滿則阻塞等待，直到出現空位並放入。</li>
<li><strong>take(e)</strong>: 從頭部取出元素，如果佇列為空則阻塞等待，直到出現元素並取出。</li>
<li><strong>offer(e, 時間, 時間單位)</strong>: 從尾部放入元素，如果佇列已滿則阻塞等待一段時間，超過時間則停止等待並回傳 false。</li>
<li><strong>poll(e, 時間, 時間單位)</strong>: 從頭部取出元素，如果佇列已滿則阻塞等待一段時間，超過時間則停止等待並回傳 false。</li>
</ul>
<h2 id="producer-consumer-problem"><a class="markdownIt-Anchor" href="#producer-consumer-problem"></a> Producer Consumer Problem</h2>
<p>用一個簡單的 Producer Consumer Problem 來練習：</p>
<p><em>6 Producers * 5 messages --&gt; 3 Consumers * 10 messages</em></p>
<ul>
<li>使用 <strong>LinkedBlockingQueue</strong> 作為傳遞訊息的容器</li>
<li>Producer 使用 <code>put()</code> 將訊息放入 queue，因為沒有限制長度所以基本不會阻塞</li>
<li>Consumer 使用 <code>take()</code> 將訊息從 queue 中取出，因為 要等 Producer 產出訊息所以會阻塞</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隨機 Sleep 一段時間</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomSleep</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    RandomSleep(<span class="type">int</span> second)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(rand.nextInt(second));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> idx;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line">    </span><br><span class="line">    Producer(<span class="type">int</span> idx, BlockingQueue&lt;Integer&gt; queue)&#123;</span><br><span class="line">        <span class="built_in">this</span>.idx = idx;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;  <span class="comment">//  5 messages</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">RandomSleep</span>(<span class="number">500</span>); <span class="comment">// time to produce a message</span></span><br><span class="line">                queue.put(idx);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> idx;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; reveived = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Consumer(<span class="type">int</span> idx, BlockingQueue&lt;Integer&gt; queue)&#123;</span><br><span class="line">        <span class="built_in">this</span>.idx = idx;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (reveived.size() &lt; <span class="number">10</span>)&#123;  <span class="comment">// 10 messages</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                reveived.offer(queue.take());</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer &quot;</span> + idx + <span class="string">&quot; received: &quot;</span> + reveived);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerProducerProblem</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Producer</span>(i, queue).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Consumer</span>(i, queue).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>執行結果如下，每次跑都會不太一樣：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Consumer 2 received: [1, 3, 4, 2, 4, 5, 4, 1, 3, 3]</span><br><span class="line">Consumer 1 received: [6, 1, 3, 5, 1, 2, 4, 6, 4, 2]</span><br><span class="line">Consumer 3 received: [2, 6, 5, 5, 5, 1, 2, 6, 3, 6]</span><br></pre></td></tr></table></figure>
<h2 id="參考資料"><a class="markdownIt-Anchor" href="#參考資料"></a> 參考資料</h2>
<p><a href="https://www.baeldung.com/java-concurrent-queues">A Guide to Concurrent Queues in Java</a><br />
<a href="https://blog.csdn.net/lzxlfly/article/details/86710382">LinkedBlockingQueue与ConcurrentLinkedQueue的区别</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 自學筆記 06 - Multi Thread</title>
    <url>/posts/Java/2024/java-learning-06/</url>
    <content><![CDATA[<h2 id="java-thread"><a class="markdownIt-Anchor" href="#java-thread"></a> Java Thread</h2>
<p>There are two ways to new a thread in Java:</p>
<p><img src="/images/2024/03/20/java_thread.png" alt="Java Thread" /></p>
<span id="more"></span>
<h3 id="implemented-from-runnable-interface"><a class="markdownIt-Anchor" href="#implemented-from-runnable-interface"></a> Implemented from Runnable Interface</h3>
<p>Runnable 是一個 interface，<code>run()</code> 裡面放的就是 thread 要執行的內容，一定要 <strong>override</strong> 且一定要設為 <strong>public</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// to new</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">TestRunnable</span>());</span><br></pre></td></tr></table></figure>
<h3 id="extended-from-thread-class"><a class="markdownIt-Anchor" href="#extended-from-thread-class"></a> Extended from Thread Class</h3>
<p>Thread 是 Runnable 的實現，用法一樣是把要執行的程式放進 <code>run()</code> 裡面，概念一樣是 <strong>override</strong> + <strong>public</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// to new</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestThread</span>()</span><br></pre></td></tr></table></figure>
<p>我們也可以直接用 lambda 來 new thread。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="start-and-join"><a class="markdownIt-Anchor" href="#start-and-join"></a> Start and Join</h2>
<p>我們可以用 <code>start()</code> 來開始執行 thread，並用 <code>join()</code> 來等待 thread 完成並回歸 main thread。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Run in thread&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Run in main&quot;</span>);</span><br><span class="line">thread.start();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    thread.join();</span><br><span class="line">&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;　<span class="comment">// 一定要處理 Exception</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;Back to main&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>執行結果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Run in main</span><br><span class="line">Run in thread</span><br><span class="line">Back to main</span><br></pre></td></tr></table></figure>
<h2 id="shared-resources"><a class="markdownIt-Anchor" href="#shared-resources"></a> Shared Resources</h2>
<p>同時有多個 thread 對同一個資源進行操作時，可能會出現 <strong>race condition</strong>，導致結果不如預期，舉例來說:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SyncThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++)&#123;</span><br><span class="line">            addOne();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addOne</span><span class="params">()</span>&#123;</span><br><span class="line">        sum += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharedResources</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SyncThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SyncThread</span>();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            thread1.join();</span><br><span class="line">            thread2.join();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(SyncThread.sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一個 thread 各別對 <code>sum</code> 進行 <code>addOne()</code> 10000 次，理論上最後的結果應該是<code>sum = 20000</code>，但最後結果卻小於 20000 (每次跑會不太一樣)，原因大致上是這樣:</p>
<p><img src="/images/2024/03/20/race_condition.png" alt="race_condition" /></p>
<h3 id="synchronized"><a class="markdownIt-Anchor" href="#synchronized"></a> Synchronized</h3>
<p>我們可以使用 <code>synchronized</code> 關鍵字來實現同步，確保在同一時間只有一個 thread 在執行指定的代碼，使用方法有:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 修飾方法</span></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addOne</span><span class="params">()</span>&#123;</span><br><span class="line">        sum += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 修飾代碼塊</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addOne</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">        sum += <span class="number">1</span>;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不過 <code>synchronized</code> 是比較古老的用法了，在高併發的情況下性能可能會不太好，所以可以考慮用後面的方法。</p>
<h3 id="atomic"><a class="markdownIt-Anchor" href="#atomic"></a> Atomic</h3>
<p>Atomic 表示不可被切分的動作，以我們的例子來說就是，我們可以將 <code>sum</code> 指定為  <strong>AtomicInteger</strong>，確保對 <code>sum</code> 的操作不會被中斷。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SyncThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            sum.addAndGet(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="concurrent-lock"><a class="markdownIt-Anchor" href="#concurrent-lock"></a> Concurrent Lock</h3>
<p><code>java.util.concurrent</code> 是 Java 中用來取代 <code>synchronized</code> 的一個 package，我們可以使用裡面的 Lock 機制，透過 Lock 的取得以及釋放來控制 thread 的動作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SyncThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            addOne();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addOne</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sum += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="concurrent-collection"><a class="markdownIt-Anchor" href="#concurrent-collection"></a> Concurrent Collection</h3>
<p>前兩篇在介紹 Collections 的時候有稍微提到，Vector、Hashtable 等容器透過 <code>synchronized</code> 來實現同步，在高併發時效率不太好，因此 Java 後來又提供了 <strong>ConcurrentHashMap</strong>、<strong>ConcurrentLinkedQueue</strong> 等基於 concurrent 實現的容器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SyncThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> ConcurrentHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            put(<span class="string">&quot;sum&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            map.compute(<span class="string">&quot;sum&quot;</span>, (key, value) -&gt; value + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="參考資料"><a class="markdownIt-Anchor" href="#參考資料"></a> 參考資料</h2>
<p><a href="https://popcornylu.gitbooks.io/java_multithread/content/">Java多執行緒的基本知識</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 自學筆記 09 - Stream API</title>
    <url>/posts/Java/2024/java-learning-09/</url>
    <content><![CDATA[<h2 id="java-stream"><a class="markdownIt-Anchor" href="#java-stream"></a> Java Stream</h2>
<p><img src="/images/2024/03/25/java_stream.png" alt="Java Stream" /></p>
<p><strong>Stream</strong> 是一個元素形成的隊列，其<strong>來源 (Source)</strong> 可以是集合或數組，Stream 本身並不會存儲元素，其操作也不會影響到原始來源，單純以數據流的方式來處理數據，依性質可以分為兩類：</p>
<ul>
<li><strong>中間操作 (Intermediate Operations)</strong><br />
Stream 的中間步驟，一個 Stream 可以有多個中間操作，會返回一個新的 stream，屬於<strong>惰性求值 (Lazy Evaluation)</strong>，意思是不會馬上計算結果，而是等到終端操作時才一併計算。</li>
<li><strong>終端操作 (Terminal Operations)</strong><br />
Stream 的最後一步，一個 stream 只能有一個終端操作，會產生一個新的集合或值。</li>
</ul>
<span id="more"></span>
<h3 id="創建-stream"><a class="markdownIt-Anchor" href="#創建-stream"></a> 創建 Stream</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// array to stream</span></span><br><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">Arrays.stream(array);</span><br><span class="line">Stream.of(array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// collecitions to stream</span></span><br><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(numbers);</span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()&#123;&#123;</span><br><span class="line">    put(<span class="number">1</span>, <span class="number">1</span>); put(<span class="number">2</span>, <span class="number">2</span>); put(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line">numbers.stream();</span><br><span class="line">set.stream();</span><br><span class="line">map.keySet().stream();</span><br><span class="line">map.values().stream();</span><br></pre></td></tr></table></figure>
<h3 id="parallel-stream"><a class="markdownIt-Anchor" href="#parallel-stream"></a> Parallel Stream</h3>
<p>Stream 支援<strong>併行流 (parallelStream)</strong>，底層默認使用 <strong>ForkJoinPool</strong>，所謂的 ForkJoinPool 其實就是 divide and conquer 算法，將任務不斷拆分成小任務處理，能充分利用 CPU 的效能，細節可以參考: <a href="https://popcornylu.gitbooks.io/java_multithread/content/threadpool/forkjoin.html">ForkJoin Pool</a></p>
<p><img src="/images/2024/03/25/ForkJoinPool.png" alt="ForkJoinPool" /></p>
<p>可以直接創建 Parallel Stream 也可以從 Stream 轉換：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">numbers.parallelStream();    <span class="comment">// or</span></span><br><span class="line">numbers.stream().parallel();</span><br></pre></td></tr></table></figure>
<h2 id="遍歷匹配-foreachfindmatch"><a class="markdownIt-Anchor" href="#遍歷匹配-foreachfindmatch"></a> 遍歷/匹配 (foreach/find/match)</h2>
<p>findFirst、findAny 等操作返回的為一個 <strong>Optional</strong> 物件，用來表示一個可能為 null 的值，常用方法為:</p>
<ul>
<li><strong>get()</strong>：获取 Optional 对象中的值，如果值为 null，则抛出 NoSuchElementException 异常。</li>
<li><strong>orElse(T other)</strong>：获取 Optional 对象中的值，如果值为 null，则返回指定的默认值。</li>
<li><strong>isPresent()</strong>：判断 Optional 对象是否包含值。</li>
<li><strong>ifPresent(Consumer&lt;? super T&gt; consumer)</strong>：如果 Optional 对象包含值，则执行指定的操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// forEach</span></span><br><span class="line">numbers.stream()</span><br><span class="line">    .forEach(System.out:: println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// findFirst (返回第一個)</span></span><br><span class="line">Optional&lt;Integer&gt; first = numbers.stream()</span><br><span class="line">    .filter(n -&gt; n &gt; <span class="number">2</span>)</span><br><span class="line">    .findFirst();</span><br><span class="line">first.get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// findAny (返回任一個)</span></span><br><span class="line">numbers.parallelStream()</span><br><span class="line">    .filter(n -&gt; n &gt; <span class="number">2</span>)</span><br><span class="line">    .findAny()</span><br><span class="line">    .get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// anyMatch (任一符合)</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">match</span> <span class="operator">=</span> numbers.parallelStream()</span><br><span class="line">    .filter(n -&gt; n &gt; <span class="number">2</span>)</span><br><span class="line">    .anyMatch();</span><br></pre></td></tr></table></figure>
<h2 id="篩選-filter"><a class="markdownIt-Anchor" href="#篩選-filter"></a> 篩選 (filter)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">numbers.stream()</span><br><span class="line">    .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    .sorted((n1, n2)-&gt; n2 - n1)    <span class="comment">// Descending </span></span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h2 id="映射-mapflatmap"><a class="markdownIt-Anchor" href="#映射-mapflatmap"></a> 映射 (map/flatMap)</h2>
<ul>
<li><strong>map</strong>: 把一個元素映射到一個新的元素</li>
<li><strong>flatMap</strong>: 把一個元素映射到一個新的 stream</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">numbers.stream()</span><br><span class="line">    .map(n -&gt; n * n)</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>假設要將 <code>&#123;&quot;Hello&quot;, &quot;World&quot;&#125;</code> 轉換成 <code>&#123;&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;o&quot;, &quot;W&quot;, &quot;r&quot;, &quot;d&quot;&#125;</code>，那我們不能直接用 <code>map(s-&gt;s.split(&quot;&quot;))</code>，因為 map 回傳的是一個元素，所以會是 <code>String[]</code>，這時候就可以改用<strong>flatMap</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">helloworld = &#123;<span class="string">&quot;H&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;o&quot;</span>, <span class="string">&quot;W&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">helloworld.stream()</span><br><span class="line">    .flatMap(word-&gt; Arrays.stream(word.split(<span class="string">&quot;&quot;</span>)))</span><br><span class="line">    .distinct()</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<h2 id="歸約-reduce"><a class="markdownIt-Anchor" href="#歸約-reduce"></a> 歸約 (reduce)</h2>
<ul>
<li><strong>identity</strong>: 初始值，沒設置就是用第一筆資料當初始值。</li>
<li><strong>accumulator</strong>: 累加器函數，第一個參數是累加值，第二個參數是當前值。</li>
<li><strong>combiner</strong>: 組合器函數，在 parallel 情況下用來合併各個線程的結果。</li>
</ul>
<h3 id="accumulator"><a class="markdownIt-Anchor" href="#accumulator"></a> accumulator</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Optional&lt;T&gt; reduce(</span></span><br><span class="line"><span class="comment">//     BinaryOperator&lt;T&gt; accumulator</span></span><br><span class="line"><span class="comment">// )</span></span><br><span class="line">Optional&lt;Integer&gt; opt_sum = numbers.stream()</span><br><span class="line">    .reduce((acc, x) -&gt; acc + x);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum1</span> <span class="operator">=</span> opt_sum.get();</span><br></pre></td></tr></table></figure>
<h3 id="identity-accumulator"><a class="markdownIt-Anchor" href="#identity-accumulator"></a> identity + accumulator</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// T reduce(</span></span><br><span class="line"><span class="comment">//     T identity, </span></span><br><span class="line"><span class="comment">//     BinaryOperator&lt;T&gt; accumulator</span></span><br><span class="line"><span class="comment">// )</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum2</span> <span class="operator">=</span> numbers.stream()</span><br><span class="line">    .reduce(<span class="number">0</span>, (acc, x) -&gt; acc + x);</span><br></pre></td></tr></table></figure>
<h3 id="identity-accumulator-combiner"><a class="markdownIt-Anchor" href="#identity-accumulator-combiner"></a> identity + accumulator + combiner</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;U&gt; U reduce(</span></span><br><span class="line"><span class="comment">//     U identity, </span></span><br><span class="line"><span class="comment">//     BiFunction&lt;U, ? super T, U&gt; accumulator,</span></span><br><span class="line"><span class="comment">//     BinaryOperator&lt;U&gt; combiner</span></span><br><span class="line"><span class="comment">// )</span></span><br><span class="line">numbers.parallelStream()</span><br><span class="line">    .reduce(<span class="number">0</span>, (acc, x)-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;acc: &quot;</span> + acc + <span class="string">&quot;, x: &quot;</span> + x);</span><br><span class="line">        <span class="keyword">return</span> acc+x;</span><br><span class="line">    &#125;,(comb, x)-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;comb: &quot;</span> + comb + <span class="string">&quot;, x: &quot;</span> + x);</span><br><span class="line">        <span class="keyword">return</span> comb+x;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acc: 0, x: 2    // 各線程</span><br><span class="line">acc: 0, x: 1</span><br><span class="line">acc: 0, x: 3</span><br><span class="line">comb: 2, x: 3   // 合併線程</span><br><span class="line">comb: 1, x: 5</span><br></pre></td></tr></table></figure>
<p>可以發現每個元素都被當作是一個新的線程了 (acc 都是 0)，等於 accumulator 根本沒派上用場，事實上，accumulator 在這裡的作用反而更像是一個中介的轉換器，負責將原本的類型 <strong>T</strong> 轉換到 <strong>U</strong>，可以參考: <a href="https://stackoverflow.com/questions/24308146/why-is-a-combiner-needed-for-reduce-method-that-converts-type-in-java-8">Why is a combiner needed for reduce method that converts type in java 8</a></p>
<h2 id="收集-collect"><a class="markdownIt-Anchor" href="#收集-collect"></a> 收集 (collect)</h2>
<p><strong>collect</strong> 的目的是用來將 stream 轉存為其他資料型態。</p>
<h3 id="stream-to-collections"><a class="markdownIt-Anchor" href="#stream-to-collections"></a> stream to collections</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">numbers.stream()</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line">numbers.stream()</span><br><span class="line">    .collect(Collectors.toSet());</span><br><span class="line">numbers.stream()</span><br><span class="line">    .collect(Collectors.toMap(x-&gt;x, x-&gt;x));</span><br></pre></td></tr></table></figure>
<h3 id="partitioningby-groupingby"><a class="markdownIt-Anchor" href="#partitioningby-groupingby"></a> partitioningBy / groupingBy</h3>
<ul>
<li><strong>partitioningBy</strong>: 分為兩群 (<code>Map&lt;boolean, List&lt;T&gt;&gt;</code>)</li>
<li><strong>groupingBy</strong>: 分為多群 (<code>Map&lt;T, List&lt;T&gt;&gt;</code>)</li>
</ul>
<p><img src="/images/2024/03/25/partitioningBy.png" alt="partitioningBy" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">numbers.stream()</span><br><span class="line">    .collect(Collectors.partitioningBy(x -&gt; x&gt;<span class="number">2</span>));</span><br><span class="line">numbers.stream()</span><br><span class="line">    .collect(Collectors.groupingBy(x -&gt; x%<span class="number">4</span>));</span><br></pre></td></tr></table></figure>
<h3 id="joining-string"><a class="markdownIt-Anchor" href="#joining-string"></a> joining (String)</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">joined</span> <span class="operator">=</span> numbers.stream()</span><br><span class="line">    .map(String::valueOf)</span><br><span class="line">    .collect(Collectors.joining(<span class="string">&quot;-&quot;</span>));</span><br></pre></td></tr></table></figure>
<h2 id="統計-maxminsumaveragecount"><a class="markdownIt-Anchor" href="#統計-maxminsumaveragecount"></a> 統計 (max/min/sum/average/count)</h2>
<h3 id="max-min"><a class="markdownIt-Anchor" href="#max-min"></a> max / min</h3>
<p>max / min 相關的操作都是返回 <strong>Optional</strong> 物件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// int</span></span><br><span class="line">Optional&lt;Integer&gt; max = numbers.stream()</span><br><span class="line">    .max(Integer::compareTo);</span><br><span class="line">max.get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// String</span></span><br><span class="line">names.stream()</span><br><span class="line">    .min(Comparator.comparing(String::valueOf))</span><br><span class="line">    .get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// stream</span></span><br><span class="line">numbers.stream()</span><br><span class="line">    .collect(Collectors.maxBy(Integer::compareTo))</span><br><span class="line">    .get();</span><br></pre></td></tr></table></figure>
<h3 id="sum-average-count"><a class="markdownIt-Anchor" href="#sum-average-count"></a> sum / average / count</h3>
<p>注意 average 回傳的是 double</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sum</span></span><br><span class="line">numbers.stream()</span><br><span class="line">    .collect(Collectors.summingInt(x-&gt;x));</span><br><span class="line"></span><br><span class="line"><span class="comment">// average</span></span><br><span class="line"><span class="type">double</span> <span class="variable">average</span> <span class="operator">=</span> numbers.stream()</span><br><span class="line">    .collect(Collectors.averagingInt(x-&gt;x));</span><br><span class="line"></span><br><span class="line"><span class="comment">// count</span></span><br><span class="line">names.stream().count();</span><br><span class="line">names.stream().collect(Collectors.counting());</span><br></pre></td></tr></table></figure>
<h2 id="參考資料"><a class="markdownIt-Anchor" href="#參考資料"></a> 參考資料</h2>
<p><a href="https://www.runoob.com/java/java8-streams.html">Java 8 Stream | 菜鸟教程</a><br />
<a href="https://blog.csdn.net/m0_58093863/article/details/123165069">Java8 Stream 流的创建、筛选、映射、排序、归约、分组、聚合、提取与组合、收集、接合、foreach遍历</a><br />
<a href="https://www.cnblogs.com/lijingran/p/8727507.html">java8中stream的map和flatmap的理解</a><br />
<a href="https://blog.csdn.net/IO_Field/article/details/54971679">Java 8系列之Stream中万能的reduce</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 自學筆記 08 - ExecutorService &amp; Future</title>
    <url>/posts/Java/2024/java-learning-08/</url>
    <content><![CDATA[<p>在 <a href="/posts/Java/2024/java-learning-08">Java 自學筆記 07 - Concurrent Queue</a> 中我們使用 concurrent queue 來實作 <strong>Producer Consumer Problem</strong>，將生產者產出的 task 丟給 queue，消費者一有空閒就會去 queue 中拿新的 task 出來，實際上這就是 <strong>Thread Pool</strong> 的概念，不過過程中我們是自己去創建與管理 thread 和 queue，而 Java 其實提供了許多跟 Thread Pool 有關的介面，讓我們能夠更簡單的實現這些功能。</p>
<h2 id="executorservice"><a class="markdownIt-Anchor" href="#executorservice"></a> ExecutorService</h2>
<p><img src="/images/2024/03/22/executor_service.png" alt="Executor Service" /></p>
<span id="more"></span>
<p><strong>ExecutorService</strong> 是 Java 中用於管理 Thread Pool 的 Interface，我們可以使用 <strong>Executors</strong> 類別下的 method 來去實作一個 ExecutorService，常見的方法有:</p>
<ul>
<li><strong>newSingleThreadExecutor()</strong>: 創建一個單個工作線程的線程池。</li>
<li><strong>newFixedThreadPool(int n)</strong>: 創建一個 n 個線程的線程池。</li>
<li><strong>newCachedThreadPool()</strong>: 創建一個可根據需要自動擴展的線程池。</li>
</ul>
<p>常用操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// new a ExecutorService</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// submit runnable tasks to ExecutorService</span></span><br><span class="line">executor.submit(<span class="keyword">new</span> <span class="title class_">RunnableTask</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// submit callable tasks to ExecutorService</span></span><br><span class="line">executor.submit(<span class="keyword">new</span> <span class="title class_">CallableTask</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// shutdown ExecutorService</span></span><br><span class="line">executor.shutdown();     <span class="comment">// smooth shutdown</span></span><br><span class="line">executor.shutdownNow();  <span class="comment">// force shutdown</span></span><br></pre></td></tr></table></figure>
<p>從上面的程式碼中可以發現， ExecutorService 除了跟 Thread 一樣可以執行 <strong>Runnable</strong> 外，還多了一個 <strong>Callable</strong>，兩者非常相似，差別只在於 Callable 會回傳東西而 Runnable 不會，實作 Callable 的方法如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CallableTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>call()</code> 屬於 abstract method，一定要 override 掉，另外就是要注意泛型的資料型態。</p>
<h2 id="future"><a class="markdownIt-Anchor" href="#future"></a> Future</h2>
<p><code>submit()</code> 方法會返回一個 <strong>Future</strong> 物件，簡單來說 Future 是一個未來會得到的結果，以 submit 一個 Callable  來的話，其 Futrue 就是未來的某一時間點我們會得到 Callable 的返回值。越看覺得越熟悉，這就是 javascript 裡的 promise 跟非同步的概念呀 !<br />
我們可以使用 <code>get()</code> 方法來取得結果，當呼叫 <code>get()</code> 時，主進程會被阻擋，直到 get() 取得返回值才會繼續，舉例來說：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CallableTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Task started.&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Task finished.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException&#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        Future&lt;String&gt; future = executor.submit(<span class="keyword">new</span> <span class="title class_">CallableTask</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread keeps running.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// main thread is blocked until task return</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> future.get();</span><br><span class="line">        System.out.println(str);;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread continues.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>執行結果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Main thread keeps running.</span><br><span class="line">Task started.</span><br><span class="line">Task finished.</span><br><span class="line">Main thread continues.</span><br></pre></td></tr></table></figure>
<h2 id="參考資料"><a class="markdownIt-Anchor" href="#參考資料"></a> 參考資料</h2>
<p><a href="https://popcornylu.gitbooks.io/java_multithread/content/">Java多執行緒的基本知識</a><br />
<a href="https://javarevisited.blogspot.com/2017/02/difference-between-executor-executorservice-and-executors-in-java.html#axzz7ZGX8FDUO">Difference between Executor, ExecutorService and Executers class in Java</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Spectral Clustering - 算法解析與 numpy 程式實作</title>
    <url>/posts/Others/2023/spectral-clustering/</url>
    <content><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p><img src="/images/2023/04/27/cluster_analysis.jpg" alt="Spectral Clustering" /></p>
<p>在社群網絡中分析中，有時候會想要找出網絡當中的社群(community detection)，一個最直觀的想法是直接對網絡進行分群，那麼分群結果就是各個community了。<br />
如果我們能夠計算各個節點之間的相似性，那麼我們當然可以直接套用傳統的分群方法，如cosine similiarity，但一來是相似度特徵可能很難取得，二來是這樣分群的話就沒有利用到網絡的結構了，這時我們可以改為使用基於圖論的分群方法。<br />
今天這篇文章會帶大家簡單瞭解什麼是cut approach, balanced-cut approach以及其代表方法spectral clustering，並示範不依賴其他套件，僅使用numpy實作spectral clustering。</p>
<span id="more"></span>
<h1 id="大綱"><a class="markdownIt-Anchor" href="#大綱"></a> 大綱</h1>
<ul>
<li><a href="#Mini-cut-Approach">Mini-cut approach</a></li>
<li><a href="#Balanced-cut-Approach">Balanced-cut approach</a></li>
<li><a href="#Spectral-Clustering">Spectral clustering</a></li>
</ul>
<h1 id="內文"><a class="markdownIt-Anchor" href="#內文"></a> 內文</h1>
<h2 id="mini-cut-approach"><a class="markdownIt-Anchor" href="#mini-cut-approach"></a> Mini-cut Approach</h2>
<p>Cut approach，顧名思義是將網絡給切開來形成多個網絡，屬於partitional clustering的一種，每個節點只會屬於一個community，並且community之間也不會overlapping，而Mini-cut Approach則是希望在切割網絡時能最小化切掉的edge數量。<br />
聽起來很直觀，但這樣切會有一個問題，那就是有可能會切出一些非常小的community，導致分群不夠balance。</p>
<h2 id="balanced-cut-approach"><a class="markdownIt-Anchor" href="#balanced-cut-approach"></a> Balanced-cut Approach</h2>
<p>為了解決Mini-cut Approach的缺點，Balanced-cut Approach在切割網絡時除了考量原本的edge，另外除以community的node數做加權調整，切割的目標從最小化edge數轉為最小化ratio cut，公式如下:<br />
<img src="/images/2023/04/27/ratio_cut.png" alt="Ratio Cut formula" /></p>
<p>公式解釋: 分成k群(k要自己決定)，每次取一個群<code>Pi</code>出來看，分子部分表示將<code>Pi</code>切開的話會切到的edge數，分母部分表示<code>Pi</code>內部的node數，將k個群的結果加總起來就會是整個網路的ratio cut分數。</p>
<h3 id="matrixs"><a class="markdownIt-Anchor" href="#matrixs"></a> Matrixs</h3>
<p>為了要計算Ratio Cut，我們先要來認識一下三種矩陣:</p>
<ol>
<li>Diagonal Degree Matrix 度數矩陣<br />
Degree(度數)指的是一個node有多少個鄰居，將這些Degree轉換為對角矩陣(Diagonal Matrix)就得到Diagonal Degree Matrix。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D = np.array([</span><br><span class="line">  [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>Adjacency Matrix 鄰接矩陣<br />
只要是對Graph有些概念的人應該都對Adjacency Matrix不太陌生，Adjacency Matrix描述了node之間的關係，下面例子假設node之間的關係都是雙向的，所以會是個對稱矩陣。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = np.array([</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>Laplacian Matrix 調和矩陣(拉普拉斯矩陣)<br />
Laplacian Matrix 的算法就是直接將Diagonal Degree Matrix 減去 Adjacency Matrix，聽起來可能讓人滿頭問號，為什麼要這麼做? 這邊先賣個關子，繼續看下去就知道了。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = np.array([</span><br><span class="line">  [ <span class="number">2</span>, -<span class="number">1</span>,  <span class="number">0</span>,  <span class="number">0</span>, -<span class="number">1</span>,  <span class="number">0</span>,  <span class="number">0</span>],</span><br><span class="line">  [-<span class="number">1</span>,  <span class="number">4</span>, -<span class="number">1</span>, -<span class="number">1</span>,  <span class="number">0</span>,  <span class="number">0</span>, -<span class="number">1</span>],</span><br><span class="line">  [ <span class="number">0</span>, -<span class="number">1</span>,  <span class="number">2</span>, -<span class="number">1</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>],</span><br><span class="line">  [ <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>,  <span class="number">3</span>,  <span class="number">0</span>, -<span class="number">1</span>,  <span class="number">0</span>],</span><br><span class="line">  [-<span class="number">1</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">2</span>, -<span class="number">1</span>,  <span class="number">0</span>],</span><br><span class="line">  [ <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>,  <span class="number">3</span>, -<span class="number">1</span>],</span><br><span class="line">  [ <span class="number">0</span>, -<span class="number">1</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>, -<span class="number">1</span>,  <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>
<h3 id="calculation"><a class="markdownIt-Anchor" href="#calculation"></a> Calculation</h3>
<p>現在先假設我們已經知道分群的結果了，並將結果以0,1的形式表示為一個matrix，令這個結果為X，下面結果是我隨便分的，分3群，<code>X[i][j]==1</code>表示node<code>i</code>屬於cluster<code>j</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = np.array([</span><br><span class="line">  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br></pre></td></tr></table></figure>
<ol>
<li>Diagonal Degree Matrix 解釋<br />
我們先將X的轉置矩陣與D做內積(<code>X.T.dot(D)</code>):</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br></pre></td></tr></table></figure>
<p>觀察一下結果會發現，這個矩陣就只是是把Degree填到對應的cluster中而已。<br />
接著我們再把上面結果與X做內積(<code>X.T.dot(D).dot(X)</code>):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>]])</span><br></pre></td></tr></table></figure>
<p>這個結果其實就表示<strong>每個cluster的degree總和</strong>。</p>
<ol start="2">
<li>Adjacency Matrix 解釋<br />
接著我們直接將上面公式的D換成A(<code>X.T.dot(A).dot(X)</code>):</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>
<p>會發現結果表示在<strong>cluster與cluster間互相連接的edge數</strong>。</p>
<ol start="3">
<li>Laplacian Matrix 解釋<br />
如果我們將兩個結果相減的話，會發現每一行的第i個元素(對角)就是我們想要計算的cut數(分子部分)!!!</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[ <span class="number">4</span>, -<span class="number">2</span>, -<span class="number">2</span>],  <span class="comment"># i=0, 4</span></span><br><span class="line">       [-<span class="number">2</span>,  <span class="number">3</span>, -<span class="number">1</span>],  <span class="comment"># i=1, 3</span></span><br><span class="line">       [-<span class="number">2</span>, -<span class="number">1</span>,  <span class="number">3</span>]]) <span class="comment"># i=2, 3</span></span><br></pre></td></tr></table></figure>
<p>接著我們另外計算每個cluster裡面共有多少個node，我們可以將X的轉置後與自己相乘(<code>X.T.dot(X)</code>):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>
<p>最後將對角的結果相除後加起來就是算平均就得到Ratio Cut的分數啦~~~<br />
(我這邊直接矩陣相除，大家可以自己算。)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[ <span class="number">2.</span> , -inf, -inf],</span><br><span class="line">       [-inf,  <span class="number">1.</span> , -inf],</span><br><span class="line">       [-inf, -inf,  <span class="number">1.5</span>]])</span><br></pre></td></tr></table></figure>
<p>根據上面矩陣運算的過程，我們能將公式重新整理為:<br />
<img src="/images/2023/04/27/ratio_cut_2.png" alt="ratio cut formula extended" /></p>
<p>在第三行的部分，我們另外對X進行標準化(同除以分母)變成了<code>X prime</code>。</p>
<h3 id="minimize"><a class="markdownIt-Anchor" href="#minimize"></a> Minimize</h3>
<p>回到最一開始的問題，我們的目標是要最小化ratio cut的分數，方法就是透過上面的公式去求解<code>X prime</code>矩陣，難過的是，還記的X矩陣裡最一開始只能填入0跟1嗎，想要在這樣嚴格的限制下求出最佳解是個<strong>NP-hard</strong>的問題。<br />
不過不要灰心，我們還是可以放寬條件，套用近似演算法，其中一種方法就是接下來要介紹的Spectral Clustering~~~</p>
<h2 id="spectral-clustering"><a class="markdownIt-Anchor" href="#spectral-clustering"></a> Spectral Clustering</h2>
<p>Spectral Clustering 基於ratio cut，不過X矩陣中可以填入的值變成介於0~1之間，在放寬條件後，這個最小化問題的解可以被證明是求解Laplacian Matrix的前k小個特徵值的特徵向量。</p>
<ol>
<li>Eigenvalue &amp; Eigenvactors<br />
我們可以用<code>np.linalg.eig</code>來替我們計算特徵值與特徵向量，並使用<code>np.argsort</code>來替我們找出最小的k個特徵向量。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># calculate eigenvalue and eigenvector</span></span><br><span class="line">eig_value, eig_vector = np.linalg.eig(L)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get eigenvector with smallest eigenvalue</span></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">top_k = np.argsort(eig_value)[:k]</span><br><span class="line">top_k_vector = eig_vector[:, top_k]</span><br></pre></td></tr></table></figure>
<p>得到的結果如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[ <span class="number">0.37796447</span>, -<span class="number">0.45244521</span>, -<span class="number">0.41243936</span>],</span><br><span class="line">       [ <span class="number">0.37796447</span>,  <span class="number">0.17351892</span>, -<span class="number">0.08541899</span>],</span><br><span class="line">       [ <span class="number">0.37796447</span>,  <span class="number">0.54280925</span>, -<span class="number">0.41243936</span>],</span><br><span class="line">       [ <span class="number">0.37796447</span>,  <span class="number">0.32598548</span>, -<span class="number">0.08541899</span>],</span><br><span class="line">       [ <span class="number">0.37796447</span>, -<span class="number">0.58986844</span>, -<span class="number">0.08541899</span>],</span><br><span class="line">       [ <span class="number">0.37796447</span>, -<span class="number">0.09036404</span>,  <span class="number">0.37705765</span>],</span><br><span class="line">       [ <span class="number">0.37796447</span>,  <span class="number">0.09036404</span>,  <span class="number">0.70407803</span>]])</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>K-means<br />
由於得到的特徵值並無法直接拿來做解釋，因此Spectral Clustering另外使用了K-means來為這些特徵值做分群，因為最小的特徵值為0、特徵向量一定是常數，所以我們可以把它刪去，也就是說，如果我們想要分成k群，那我們至少需要使用k-1個特徵向量。<br />
下面程式提供一個簡單的K-means範例，可以根據自己的需求另外設置停止條件。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">k_means</span>(<span class="params">X, k, max_iters=<span class="number">10000</span></span>):</span><br><span class="line">    <span class="comment"># randomly initialize centroids</span></span><br><span class="line">    centroids = X[np.random.choice(<span class="built_in">len</span>(X), k, replace=<span class="literal">False</span>)]</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(max_iters):</span><br><span class="line">       <span class="comment"># calculate distances</span></span><br><span class="line">       distances = np.linalg.norm(X[:, np.newaxis] - centroids, axis=<span class="number">2</span>)</span><br><span class="line">       <span class="comment"># assign labels </span></span><br><span class="line">       labels = np.argmin(distances, axis=<span class="number">1</span>)</span><br><span class="line">       <span class="comment"># calculate new centroids</span></span><br><span class="line">       centroids = np.array([np.mean(X[labels == i], axis=<span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)])</span><br><span class="line">    <span class="keyword">return</span> labels</span><br><span class="line"></span><br><span class="line"><span class="comment"># remove first vector</span></span><br><span class="line">features = top_k_vector[:, <span class="number">1</span>:]</span><br><span class="line"><span class="comment"># do k-maens</span></span><br><span class="line">labels = k_means(features, k)</span><br></pre></td></tr></table></figure>
<p>這樣就得到分群結果啦~~~(注意: 實際執行數字的順序可能不一樣)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>], dtype=int64)</span><br></pre></td></tr></table></figure>
<h1 id="結語"><a class="markdownIt-Anchor" href="#結語"></a> 結語</h1>
<p>其實忽略到複雜的數學證明的話，Spectral Clustering的概念還挺直觀的，文章參考了台大資管系的陳建錦教授所使用的上課講義，經過本人吸收轉化撰寫而成。</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Social Network Analysis</tag>
        <tag>Spectral Clustering</tag>
      </tags>
  </entry>
  <entry>
    <title>深入瞭解社會網絡分析中的介數中心性(Betweenness Centrality) - 計算方法與 Python 程式實作</title>
    <url>/posts/Others/2023/betweenness-centrality/</url>
    <content><![CDATA[<h1 id="介紹"><a class="markdownIt-Anchor" href="#介紹"></a> 介紹</h1>
<p><img src="/images/2023/03/29/Betweenness_Centrality.png" alt="Betweenness Centrality" /></p>
<p>介數中心性（Betweenness Centrality）是社會網絡分析中常用的一種指標，用於度量一個節點在整個網絡中扮演了多重要的角色，簡單來說，介數中心性指標評估了一個節點在網絡中擔任了多少條<strong>最短路徑</strong>的中介者角色。</p>
<p>更白話一點，介數中心性看的是一個節點有<strong>多常被其他人經過</strong>，舉例來說：某些公車站點連接了不同的公車路線，這些公車站點對於連接整個公車網絡起著重要的作用，如果這些公車站發生了任何問題，整個公車路線都會受到影響。這些公車站點就是具有高介數中心性的節點。</p>
<span id="more"></span>
<h1 id="計算方法"><a class="markdownIt-Anchor" href="#計算方法"></a> 計算方法</h1>
<h2 id="介數中心性"><a class="markdownIt-Anchor" href="#介數中心性"></a> 介數中心性</h2>
<p><img src="/images/2023/03/29/formula.png" alt="Betweenness Centrality Formula" /></p>
<p>公式中，𝜎(sigma)表示最短路徑的數量，分母的意思是從點s到點w的最短路徑的數量，分子的意思是從點s到點w的最短路徑中經過v點的數量，聽起來有點抽象，我們用下面這張圖來解釋：</p>
<blockquote>
<p><img src="/images/2023/03/29/simple_network.png" alt="Simple Network" /><br />
從s點到w點的最短路徑總共有4條，分別是<br />
<code>s -&gt; 1 -&gt; v -&gt; w</code><br />
<code>s -&gt; 2 -&gt; v -&gt; w</code><br />
<code>s -&gt; 3 -&gt; v -&gt; w</code><br />
<code>s -&gt; 3 -&gt; 4 -&gt; w</code><br />
所以分母就是4，其中經過v的有三條所以分子就是3，能算出在s到w的路徑中，v的介數中心性就是<code>3/4</code>。<br />
但要注意的是網絡中的任一點都有可能是s或是w，因此若要計算整個網絡當中v的中心性，我們要將網絡中的所有組合加總(Σ)才能得到最後的結果。</p>
</blockquote>
<h2 id="標準化"><a class="markdownIt-Anchor" href="#標準化"></a> 標準化</h2>
<p>聰明的你可能會發現網絡中的節點越多，算出來的值也越大(因為是加總)，因此，為了讓不同網絡之間能被拿來比較，我們要對其進行標準化。</p>
<p><img src="/images/2023/03/29/normalization_formula.png" alt="Normalization Formula" /></p>
<p>其中，分母是Binomial Coefficient，指的是一個網絡的最大可能介數中心性(網路中任選兩點、n-1取2)：<br />
<img src="/images/2023/03/29/binomial_coefficient.png" alt="Binomial Coefficient" /></p>
<p>(上面標準化公式的假設是網絡是沒有方向性的，如果有方向性的話就不用除2了。)</p>
<h1 id="python-實作"><a class="markdownIt-Anchor" href="#python-實作"></a> Python 實作</h1>
<p>網路上很多有關Betweenness Centrality的教學都是直接套<code>networkx</code>套件，但對於程式邏輯究竟如何實現卻是著墨很少，因此接下來要以<strong>不用套件</strong>的方式來實現unweighted graph中Betweenness Centrality的計算！</p>
<p>在開始實作前，我們要先把 unweighted graph 轉換成以下格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">graph = &#123;</span><br><span class="line">    <span class="number">0</span> : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="comment"># 節點 : [他的鄰居]</span></span><br><span class="line">    <span class="number">1</span> : [<span class="number">0</span>, <span class="number">4</span>],</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pseudo-code"><a class="markdownIt-Anchor" href="#pseudo-code"></a> Pseudo Code</h2>
<p>來看看Pseudo Code，這個算法可以計算出graph中各個點的Betweenness Centrality:<br />
<img src="/images/2023/03/29/pseudo_code.webp" alt="Pseudo Code for Betweenness Centrality" /></p>
<h2 id="程式邏輯"><a class="markdownIt-Anchor" href="#程式邏輯"></a> 程式邏輯</h2>
<p>看了霧煞煞? 沒關係，來解釋一下變數的意涵：</p>
<blockquote>
<p>s: 起點<br />
v: 中介點<br />
w: 終點<br />
S: stack，後進先出的佇列，用來儲存已經遍歷過的節點<br />
P: path，s到w的最短路徑中，所經過的鄰居v<br />
σ: sigma，s到其他點的最短路徑的數量<br />
d: distance，s到其他點的最短距離<br />
Q: queue，先進先出的佇列，用來實現BFS<br />
δ: delta，介數中心性 (單一個節點s的結果)<br />
C: centrality，介數中心性 (sum of delta)</p>
</blockquote>
<p>程式邏輯其實很簡單，先初始化graph的共用的變數(<code>C</code>)，接著就是對每個節點(<code>for s in graph:</code>)做下面三個步驟：</p>
<ol>
<li>初始化變量</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = [] <span class="comment"># stack</span></span><br><span class="line">P = &#123;node: [] <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125; <span class="comment"># path</span></span><br><span class="line">sigma = &#123;node: <span class="number">0</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125; <span class="comment"># 初始化為-1，因為原點是0</span></span><br><span class="line">sigma[s] = <span class="number">1</span> </span><br><span class="line">d = &#123;node: -<span class="number">1</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125; <span class="comment"># distance</span></span><br><span class="line">d[s] = <span class="number">0</span></span><br><span class="line">Q = deque([s]) <span class="comment"># queue</span></span><br></pre></td></tr></table></figure>
<ul>
<li>這部分就是根據各個變量的性質去初始化而已，唯一需要注意的是距離(<code>d</code>)一開始要初始化為-1，因為原點會是0。</li>
</ul>
<ol start="2">
<li>計算最短路徑 (BFS)</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> Q:</span><br><span class="line">    v = Q.popleft()</span><br><span class="line">    S.append(v)</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> graph[v]: <span class="comment"># for neighbor in neighbors</span></span><br><span class="line">        <span class="keyword">if</span> d[w] &lt; <span class="number">0</span>: <span class="comment"># 如果遇到新的節點才去更新他的距離</span></span><br><span class="line">            Q.append(w)</span><br><span class="line">            d[w] = d[v] + <span class="number">1</span></span><br><span class="line">        <span class="comment"># -----------------------------------------------       </span></span><br><span class="line">        <span class="keyword">if</span> d[w] == d[v] + <span class="number">1</span>: <span class="comment"># 判斷v是否在s到w的最短路徑中</span></span><br><span class="line">            sigma[w] += sigma[v] <span class="comment"># 透過v去更新w的最短路徑數</span></span><br><span class="line">            P[w].append(v)</span><br></pre></td></tr></table></figure>
<ul>
<li>在這段程式中，我們可以把他切成兩半，前半段是基本的BFS演算法，比較不一樣的地方在於我們將queue彈出的節點再存入stack中，紀錄所有遍歷過的點；後半段則是從w的鄰居中，去尋找鄰居v是否位於最短路徑當中(透過判斷最短距離是否相差1)，如果是的話那就透過v去更新更新w的sigma，並且將v記錄至w的<code>path</code>中。</li>
</ul>
<ol start="3">
<li>計算Betweenness Centrality</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delta = &#123;node: <span class="number">0</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125;</span><br><span class="line"><span class="comment"># -----------------------------------------------   </span></span><br><span class="line"><span class="keyword">while</span> S:</span><br><span class="line">    w = S.pop() <span class="comment"># 從遍歷過的節點中pop一個</span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> P[w]:</span><br><span class="line">        delta[v] += (sigma[v]/sigma[w]) * (<span class="number">1</span> + delta[w])</span><br><span class="line">    <span class="keyword">if</span> w != s:</span><br><span class="line">        C[w] += delta[w]</span><br></pre></td></tr></table></figure>
<ul>
<li>delta其實也是初始化變量的一部分啦，只是Pseudo Code放在這部分所以寫在這邊。</li>
<li>我們將節點從stack中取出來，去更新這些點的Betweenness Centrality，之所以用stack有兩個原因，第一個原因是我們只需要考慮能到達的節點，第二個原因是我們希望由終點往起點去更新。</li>
<li>接著我們將每個w的path中的v取出，去更新這些v，<code>sigma[v]/sigma[w]</code>表示經過v的最短路徑數/經過w的最短路徑數，這邊比較讓人confused的點應該是，根據前面提到的Betweenness Centrality公式，不是只有<code>sigma[v]/sigma[w]</code>嗎?為什麼要乘以<code>1+delta[w]</code>呢?原因是目前的介數中心性只考慮了v之於w的影響，我們要對其進行修正以納入w後面的節點的影響，我們一樣拿前面用過的例子來解釋：</li>
</ul>
<blockquote>
<p><img src="/images/2023/03/29/simple_network_2.png" alt="simple network 2" /><br />
我們把原本的v當成新的w，把點1當成新的v，從s到w的最短路徑有三條，分別是<br />
<code>s -&gt; v -&gt; w</code><br />
<code>s -&gt; 2 -&gt; w</code><br />
<code>s -&gt; 3 -&gt; w</code><br />
其中，經過v的只有一條，所以算出來Betweenness Centrality就是<code>sigma[v]/sigma[w] = 1/3</code>，但是!!! v不只在<code>s -&gt; w</code>的最短的路徑上，他也位於<code>s -&gt; w'</code>的最短路徑中，這部分也要考慮進去，前面提到從<code>s -&gt; w'</code>共有4條最短路徑，經過現在的v的只有1條，因此這部分是<code>sigma[v]/sigma[w'] = 1/4</code>，而這個值其實會等於<code>1/3 * 3/4</code>，其中<code>3/4</code>是我們前面算得的<code>delta[w]</code>，因此把<code>s -&gt; w</code>與<code>s -&gt; w'</code>的結果加起來，就會是：<br />
<code>(sigma[v]/sigma[w]) + (sigma[v]/sigma[w'])</code><br />
=<code>(sigma[v]/sigma[w]) + (sigma[v]/sigma[w])*delta[w]</code><br />
=<code>(sigma[v]/sigma[w]) * (1+delta[w])</code></p>
</blockquote>
<ul>
<li>最後，針對非起點s的節點，我們將其更新到最終結果中。</li>
</ul>
<p>標準化的部分雖然不在Pseudo Code中，但一般來說會順便做，方法如同公式的部分提到的，除以<code>((n-1)*(n-2))/2</code>就好。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> graph:</span><br><span class="line">    C[node] /= ((n-<span class="number">1</span>)*(n-<span class="number">2</span>))/<span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="簡化版架構"><a class="markdownIt-Anchor" href="#簡化版架構"></a> 簡化版架構</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">betweenness_centrality</span>(<span class="params">graph</span>):</span><br><span class="line">    C = &#123;node: <span class="number">0</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> graph:</span><br><span class="line">        <span class="number">1.</span> 初始化變量</span><br><span class="line">        <span class="number">2.</span> 計算最短路徑 (BFS)</span><br><span class="line">        <span class="number">3.</span> 計算centrality</span><br><span class="line">    </span><br><span class="line">    do Normalization</span><br><span class="line">    <span class="keyword">return</span> C</span><br></pre></td></tr></table></figure>
<h2 id="完整程式碼"><a class="markdownIt-Anchor" href="#完整程式碼"></a> 完整程式碼</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">betweenness_centrality</span>(<span class="params">graph</span>):</span><br><span class="line"></span><br><span class="line">    C = &#123;node: <span class="number">0</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125; <span class="comment"># centrality</span></span><br><span class="line">    n = <span class="built_in">len</span>(C)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍歷每個節點</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> graph:</span><br><span class="line">        <span class="comment"># 1. 初始化變量</span></span><br><span class="line">        S = [] <span class="comment"># stack</span></span><br><span class="line">        P = &#123;node: [] <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125; <span class="comment"># path</span></span><br><span class="line">        sigma = &#123;node: <span class="number">0</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125; <span class="comment"># 初始化為-1，因為原點是0</span></span><br><span class="line">        sigma[s] = <span class="number">1</span> </span><br><span class="line">        d = &#123;node: -<span class="number">1</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125; <span class="comment"># distance</span></span><br><span class="line">        d[s] = <span class="number">0</span></span><br><span class="line">        Q = deque([s]) <span class="comment"># queue</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2. 計算最短路徑 (BFS)</span></span><br><span class="line">        <span class="keyword">while</span> Q:</span><br><span class="line">            v = Q.popleft()</span><br><span class="line">            S.append(v)</span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> graph[v]: <span class="comment"># for neighbor in neighbors</span></span><br><span class="line">                <span class="keyword">if</span> d[w] &lt; <span class="number">0</span>: <span class="comment"># 如果遇到新的節點才去更新他的距離</span></span><br><span class="line">                    Q.append(w)</span><br><span class="line">                    d[w] = d[v] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> d[w] == d[v] + <span class="number">1</span>: <span class="comment"># 判斷v是否在s到w的最短路徑中</span></span><br><span class="line">                    sigma[w] += sigma[v] <span class="comment"># 透過v去更新w的最短路徑數</span></span><br><span class="line">                    P[w].append(v)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 計算centrality</span></span><br><span class="line">        delta = &#123;node: <span class="number">0</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125;</span><br><span class="line">        <span class="keyword">while</span> S:</span><br><span class="line">            w = S.pop() <span class="comment"># 從遍歷過的節點中pop一個</span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> P[w]:</span><br><span class="line">                delta[v] += (sigma[v]/sigma[w]) * (<span class="number">1</span> + delta[w])</span><br><span class="line">            <span class="keyword">if</span> w != s:</span><br><span class="line">                C[w] += delta[w]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Normalization</span></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> graph:</span><br><span class="line">        C[node] /= ((n-<span class="number">1</span>)*(n-<span class="number">2</span>))/<span class="number">2</span> <span class="comment"># 將每個節點除以最大可能值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C</span><br></pre></td></tr></table></figure>
<h1 id="結語"><a class="markdownIt-Anchor" href="#結語"></a> 結語</h1>
<p>如果真的遇到要計算Betweenness Centrality的情況，當然還是直接用<code>networkx</code>套件裡的<code>betweenness_centrality</code>就好了啦，寫這篇單純是因為網路上都找不到有人說明算法的邏輯，所以希望寫這篇能幫助到其他想了解算法的人。<br />
要注意上面的算法建立在所有edge的權重都是一樣的情況下，也就是點與點之間不是1就是0的binary關係，那如果每條edge有不同的權重呢?方法其實也不太意外，就是把程式中計算最短路徑的部分換掉就好了，根據實際情況可以選擇Dijkstra或是Bellman–Ford等。</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Social Network Analysis</tag>
        <tag>Betweenness Centrality</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 隨便寫 - ASCII Spinning Cube</title>
    <url>/posts/Others/2024/ascii-spinning-cube/</url>
    <content><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>因為被<a href="https://www.a1k0n.net/2011/07/20/donut-math.html">旋轉甜甜圈</a>給驚豔到，所以也想要自己來寫寫看，不過甜甜圈的數學看了頭好痛，所以改寫稍微簡單一點的<strong>旋轉立方體</strong>，不囉嗦先看成果：</p>
<p><img src="/images/2024/03/23/spinning_cube_new.gif" alt="Spinning Cube" /></p>
<span id="more"></span>
<h2 id="problem-analysis"><a class="markdownIt-Anchor" href="#problem-analysis"></a> Problem Analysis</h2>
<p>要在螢幕上繪製一個旋轉的立方體，我們大致上要處理兩個問題，一個是 <strong>3 維空間中物體的旋轉</strong>，另外一個是<strong>將 3D 的物體投影到 2D 的平面上</strong>。</p>
<p><img src="/images/2024/03/23/cube_projection.png" alt="Cube Projection" /></p>
<p>在開始之前先來定義一下座標空間，從我們的角度看像物體，物體的左右會是 x 軸，物體的上下是 y 軸，我們到物體的方向則是 z 軸。</p>
<p><img src="/images/2024/03/23/coordinate.png" alt="Coordinate Space" /></p>
<h2 id="rotation-matrix"><a class="markdownIt-Anchor" href="#rotation-matrix"></a> Rotation Matrix</h2>
<p>物體在三維空間中的旋轉可以使用旋轉矩陣來計算，以沿著 z 軸的主動旋轉來說 (在 xy 平面逆時針)，我們就可用下面的旋轉矩陣來求得旋轉後的位置：</p>
<p><img src="/images/2024/03/23/rotation_matrix_z.png" alt="Rotation Matrix Z" /></p>
<p>舉例來說，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">{[x, y, z] = [1, 0, 0]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">]</span></span></span></span></span> 沿 z 軸逆時針旋轉 90% 會變成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">{[x, y, z] = [0, 1, 0]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">]</span></span></span></span></span>：</p>
<p><img src="/images/2024/03/23/rotation_matrix_example.png" alt="Rotation Matrix Example" /></p>
<p>而旋轉矩陣的效果是可以疊加的，因此我們如果我們依序沿 z軸、y軸、x軸進行旋轉，得到的旋轉矩陣如下：</p>
<p><img src="/images/2024/03/23/rotation_matrix_xyz.png" alt="Rotation Matrix XYZ" /></p>
<p>有了旋轉矩陣後，我們就能去計算立方體的旋轉了！</p>
<h2 id="perspective-projection"><a class="markdownIt-Anchor" href="#perspective-projection"></a> Perspective Projection</h2>
<p><img src="/images/2024/03/23/perspective_projection.png" alt="Perspective Projection" /></p>
<p>投影的部分其實沒有像項中的難，用的的只是最基礎的<strong>等比三角形</strong>的概念，假設我們的眼睛到物體的距離是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">{z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span></span>，而我們的眼睛到螢幕的距離是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>z</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">{z&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span>，因此將點 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{(x,y)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span></span> 投影到螢幕上分別會落在：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><msup><mi>x</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mfrac><mrow><mi>x</mi><msup><mi>z</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><mi>z</mi></mfrac></mstyle></mrow><annotation encoding="application/x-tex">{\displaystyle  x&#x27; = {\frac {xz&#x27;}{z}}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.114892em;vertical-align:-0.686em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.428892em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><msup><mi>y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mfrac><mrow><mi>y</mi><msup><mi>z</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><mi>z</mi></mfrac></mstyle></mrow><annotation encoding="application/x-tex">{\displaystyle y&#x27; = {\frac {yz&#x27;}{z}}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.1148919999999998em;vertical-align:-0.686em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4288919999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></span></p>
<h2 id="python-code"><a class="markdownIt-Anchor" href="#python-code"></a> Python Code</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sin, cos</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rotation angles</span></span><br><span class="line">A = B = C = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Screen layout size</span></span><br><span class="line">width = <span class="number">100</span></span><br><span class="line">height = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Cube&#x27;s half side length </span></span><br><span class="line">cubeWidth = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Distances</span></span><br><span class="line">distance_to_screen = <span class="number">20</span></span><br><span class="line">distance_to_cube = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Rotation matrix</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculateX</span>(<span class="params">x, y, z</span>):</span><br><span class="line">    <span class="keyword">return</span> x * cosB * cosC \</span><br><span class="line">    + y * (sinA * sinB * cosC - cosA * sinC) \</span><br><span class="line">    + z * (cosA * sinB * cosC + sinA * sinC)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculateY</span>(<span class="params">x, y, z</span>):</span><br><span class="line">    <span class="keyword">return</span> x * cosB * sinC \</span><br><span class="line">    + y * (sinA * sinB * sinC + cosA * cosC) \</span><br><span class="line">    + z * (cosA * sinB * sinC - sinA * cosC)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculateZ</span>(<span class="params">x, y, z</span>):</span><br><span class="line">    <span class="keyword">return</span> - x * sinB + y * sinA * cosB + z * cosA * cosB</span><br><span class="line"></span><br><span class="line"><span class="comment"># Project 3D cube on 2D screen</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">project</span>(<span class="params">_x, _y, _z, char</span>):</span><br><span class="line">    <span class="comment"># Apply rotation transformations</span></span><br><span class="line">    x = calculateX(_x, _y, _z)</span><br><span class="line">    y = calculateY(_x, _y, _z)</span><br><span class="line">    z = calculateZ(_x, _y, _z) + distance_to_cube</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Perspective projection</span></span><br><span class="line">    z_ratio = distance_to_screen/z</span><br><span class="line">    xp = <span class="built_in">round</span>(width/<span class="number">2</span> + x*<span class="number">2</span>*z_ratio) <span class="comment"># x*2 becasue Letterspacing is smaller than Linespacing</span></span><br><span class="line">    yp = <span class="built_in">round</span>(height/<span class="number">2</span> + y*z_ratio)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Store the points nearest to us</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span>&lt;=xp&lt;width <span class="keyword">and</span> <span class="number">0</span>&lt;=yp&lt;height <span class="keyword">and</span> z_ratio&gt;buffer[yp][xp]):</span><br><span class="line">        buffer[yp][xp] = z_ratio</span><br><span class="line">        charbuffer[yp][xp] = char</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\x1b[2J&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        sinA, sinB, sinC = sin(A), sin(B), sin(C)</span><br><span class="line">        cosA, cosB, cosC = cos(A), cos(B), cos(C)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Initialize buffers to store projected points</span></span><br><span class="line">        buffer = [[<span class="number">0</span>]*width <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(height)]</span><br><span class="line">        charbuffer = [[<span class="string">&#x27; &#x27;</span>]*width <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(height)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Project each point of the cube onto the screen</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(-cubeWidth, cubeWidth+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(-cubeWidth, cubeWidth+<span class="number">1</span>):</span><br><span class="line">                project(x, y, -cubeWidth, <span class="string">&quot;#&quot;</span>)</span><br><span class="line">                project(x, y, cubeWidth, <span class="string">&quot;%&quot;</span>)</span><br><span class="line">                project(x, cubeWidth, y, <span class="string">&quot;&amp;&quot;</span>)</span><br><span class="line">                project(x, -cubeWidth, y, <span class="string">&quot;@&quot;</span>)</span><br><span class="line">                project(cubeWidth, x, y, <span class="string">&quot;*&quot;</span>)</span><br><span class="line">                project(-cubeWidth, x, y, <span class="string">&quot;+&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Clear the screen and print the current state of the 2D projection</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\x1b[H&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> charbuffer:</span><br><span class="line">            <span class="keyword">for</span> char <span class="keyword">in</span> row:</span><br><span class="line">                <span class="built_in">print</span>(char, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Increment rotation angles for the next frame</span></span><br><span class="line">        A += <span class="number">0.05</span></span><br><span class="line">        B += <span class="number">0.07</span></span><br><span class="line">        C += <span class="number">0.02</span></span><br></pre></td></tr></table></figure>
<h2 id="參考資料"><a class="markdownIt-Anchor" href="#參考資料"></a> 參考資料</h2>
<p><a href="https://www.youtube.com/watch?v=p09i_hoFdd0">ASMR Programming - Spinning Cube - No Talking</a><br />
<a href="https://en.wikipedia.org/wiki/Rotation_matrix">Rotation matrix - Wikipedia</a><br />
<a href="https://silverwind1982.pixnet.net/blog/post/165223625">旋轉矩陣(Rotation Matrix) - 拾人牙慧- 痞客邦</a></p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>ASCII Art</tag>
        <tag>Rotation Matrix</tag>
        <tag>Perspective Projection</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 隨便寫 - 用牛頓法 (Newton&#39;s method) 計算內部報酬率 (IRR)</title>
    <url>/posts/Others/2024/irr-with-newton-method/</url>
    <content><![CDATA[<h2 id="內部報酬率-internal-rate-of-returnirr"><a class="markdownIt-Anchor" href="#內部報酬率-internal-rate-of-returnirr"></a> 內部報酬率 (Internal Rate of Return，IRR)</h2>
<p><strong>內部報酬率</strong>是一種用來衡量投資效益的指標，其概念是計算出一個<strong>折現率</strong>，使淨資金流入的現值與淨資金流出的現值加總為 0，也就是淨現值為 0 (<strong>NPV=0</strong>)。</p>
<p>淨現值的數學公式如下:</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>P</mi><mi>V</mi><mo>=</mo><mstyle scriptlevel="0" displaystyle="true"><munderover><mo>∑</mo><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><mi>N</mi></munderover><mfrac><msub><mi>C</mi><mi>t</mi></msub><msup><mrow><mo fence="true">(</mo><mn>1</mn><mo>+</mo><mi>r</mi><mo fence="true">)</mo></mrow><mi>t</mi></msup></mfrac></mstyle></mrow><annotation encoding="application/x-tex">{NPV = \displaystyle \sum _{t=0}^{N}{\frac {C_{t}}{\left(1+r\right)^{t}}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0954490000000003em;vertical-align:-1.267113em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.882887em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.267113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.176544em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.933456em;"><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.073456em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p>
<p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></span> 是折現率、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span> 為期間、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">{C_{t}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 為第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">{t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">t</span></span></span></span></span> 年的淨現金流量。<br />
當我們帶入一個 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></span> 能使得 NPV=0 時，我們就把這個 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></span> 稱 IRR。</p>
<span id="more"></span>
<p>一般來說我們可以使用<strong>插值法</strong>來計算 IRR，假設 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></span>=5% 時 NPV &gt; 0，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></span>=6% 時 NPV &lt; 0，那我們就能說 IRR 在 5%~6% 之間，可以用 <strong>Binary Search</strong> 的概念去實作，但這次我決定用點不一樣的。</p>
<h2 id="牛頓法-newtons-method"><a class="markdownIt-Anchor" href="#牛頓法-newtons-method"></a> 牛頓法 (Newton’s method)</h2>
<p>所謂的<strong>牛頓法</strong>是一種求解方程式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">{f(x) = 0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span></span></span> 的根的方法。我們把上面 NPV 公式裡的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></span> 換成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span></span></span>，便可以把 NPV 視作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{f(x)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span> ，則 IRR 即是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">{f(x) = 0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span></span></span> 的根，因此牛頓法正好可以拿來求解 IRR。</p>
<p><img src="/images/2024/03/21/newton_method.png" alt="Newton method" /></p>
<p>我們讓 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{f(x)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span> 對 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">{x_{n}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 做偏微分得到一斜率，進一步計算出通過 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">{x_{n}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 之切線，接著找到切線與 x 軸的交點 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">{x_{n+1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></span>，其值為:</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><msub><mi>x</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>x</mi><mi>n</mi></msub><mo>−</mo><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mfrac></mstyle></mrow><annotation encoding="application/x-tex">{\displaystyle x_{n+1}=x_{n}-{\frac {f(x_{n})}{f&#x27;(x_{n})}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6778919999999999em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p>
<p>能發現 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">{x_{n+1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></span> 相比於 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">{x_{n}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 更靠近我們要求的根，因此我們能迭代的進行這個操作，直到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">{f(x_{n}) = 0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span></span></span>，或者 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>s</mi><mo stretchy="false">(</mo><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><mo>−</mo><mn>0</mn><mo stretchy="false">)</mo><mo>&lt;</mo><mi>t</mi><mi>o</mi><mi>l</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">{abs({f(x_{n})} - 0) &lt; tolerance}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mord mathnormal">b</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span></span></span></span></span>。</p>
<h2 id="python-程式碼"><a class="markdownIt-Anchor" href="#python-程式碼"></a> Python 程式碼</h2>
<p>首先是計算 NPV 的部分，這邊為了因應現金流不固定的情況所以會先計算每一期的 <code>time_diff</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">npv_with_dates</span>(<span class="params">cashflows, rate</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Calculate NPV (with date)</span></span><br><span class="line"><span class="string">    :param cashflows: [(date 1, cash 1), (date 2, cash 2) ...]</span></span><br><span class="line"><span class="string">    :param rate: discount rate</span></span><br><span class="line"><span class="string">    :return: NPV</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    npv = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> date, cashflow <span class="keyword">in</span> cashflows:</span><br><span class="line">        time_diff = (date - cashflows[<span class="number">0</span>][<span class="number">0</span>]).days / <span class="number">365.0</span></span><br><span class="line">        npv += cashflow / ((<span class="number">1</span> + rate) ** time_diff)</span><br><span class="line">    <span class="keyword">return</span> npv</span><br></pre></td></tr></table></figure>
<p>接著就是牛頓法的部分，給定一個初始的折現率開始迭代優化，<code>derivative</code> 是偏微分的結果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">irr_with_dates</span>(<span class="params">cashflows, initial_rate=<span class="number">0.1</span>, tolerance=<span class="number">1.0e-6</span>, max_iter=<span class="number">100</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Calculate IRR with Newton&#x27;s method (with date)</span></span><br><span class="line"><span class="string">    :param cashflows: [(date 1, cash 1), (date 2, cash 2) ...]</span></span><br><span class="line"><span class="string">    :param initial_rate: initial discount rate</span></span><br><span class="line"><span class="string">    :param tolerance</span></span><br><span class="line"><span class="string">    :param max_iter: max iterations</span></span><br><span class="line"><span class="string">    :return: IRR</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    rate = initial_rate</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(max_iter):</span><br><span class="line">        npv = npv_with_dates(cashflows, rate)</span><br><span class="line">        derivative = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> date, cashflow <span class="keyword">in</span> cashflows:</span><br><span class="line">            time_diff = (date - cashflows[<span class="number">0</span>][<span class="number">0</span>]).days / <span class="number">365.0</span></span><br><span class="line">            derivative += -time_diff * cashflow / ((<span class="number">1</span> + rate) ** (time_diff + <span class="number">1</span>))</span><br><span class="line">        rate -= npv / derivative</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(npv) &lt; tolerance:</span><br><span class="line">            <span class="keyword">return</span> rate</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>執行程式碼：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cashflows = [(datetime(<span class="number">2023</span>, <span class="number">1</span>, <span class="number">1</span>), -<span class="number">100</span>), (datetime(<span class="number">2023</span>, <span class="number">5</span>, <span class="number">1</span>), <span class="number">20</span>), (datetime(<span class="number">2023</span>, <span class="number">9</span>, <span class="number">1</span>), -<span class="number">10</span>), (datetime(<span class="number">2024</span>, <span class="number">1</span>, <span class="number">1</span>), <span class="number">50</span>), (datetime(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">1</span>), <span class="number">70</span>)]</span><br><span class="line">irr_value = irr_with_dates(cashflows)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;IRR: <span class="subst">&#123;irr_value*<span class="number">100</span>:<span class="number">.2</span>f&#125;</span> %&quot;</span>)</span><br><span class="line"><span class="comment"># IRR: 29.98 %</span></span><br></pre></td></tr></table></figure>
<h2 id="參考資料"><a class="markdownIt-Anchor" href="#參考資料"></a> 參考資料</h2>
<p><a href="https://highscope.ch.ntu.edu.tw/wordpress/?p=51169">牛頓法 ( Newton’s Method )</a></p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Newton&#39;s method</tag>
        <tag>IRR</tag>
      </tags>
  </entry>
</search>
